<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>第一次攀岩</title>
      <link href="/2022/09/04/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%80%E5%B2%A9/"/>
      <url>/2022/09/04/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%94%80%E5%B2%A9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录第一次攀岩。<br><img src="/2022/09/04/第一次攀岩/img.png" style="width: 24em;" alt="攀岩"></p></blockquote><a id="more"></a><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><ul><li>同学之前说起好久没找我吃饭了，恰巧妹子周天没空，想起之前同学有邀请过我去攀岩，我也想尝试一下，拓宽下自己的兴趣边界，遂约起同学一起去攀岩吃饭。</li></ul><h2 id="攀岩规则"><a href="#攀岩规则" class="headerlink" title="攀岩规则"></a>攀岩规则</h2><ul><li>攀岩不是看到石块就能随便踩上去，其具有不同的路线选择，通过不同颜色的石头标记不同路线，攀爬过程中手足只能触碰相同颜色的石块。攀岩起点有用难度胶带标记起始点四肢位置，胶带的颜色则表示难度。</li><li>大致如下图所示，圆圈代表起点，可以看到起点处有黄色胶带，代表起点四肢所处位置，不同颜色代表四肢的路径，对应关系为绿：左手，红：右手，蓝：左脚，黑：右脚。路径上使用的石块颜色都是与起点位置石块颜色一致的。最终双手抓住最顶上带有与起点相同颜色胶带的石块则为挑战成功。</li><li><img src="/2022/09/04/第一次攀岩/route.png" style="width: 24em;" alt="攀岩"></li></ul><h2 id="成绩"><a href="#成绩" class="headerlink" title="成绩"></a>成绩</h2><ul><li>此次初来，挑战场馆内所有最低难度（黄色）的路径，最终完成4条路径，2条失败。</li><li>两次失败原因分别为：<ol><li>左脚无法发挥着地点作用，在踩较小的石块时脚趾无法发力，会疼痛，致其中一条路径始终无法着力，挑战了6、7次后放弃。</li><li>重心调整能力不行，不能很好的将重心进行左右、上下转移，右臂力量也不足，致另一条失败的路径中由于无法更换重心，让重心一直在双手上，无法转移至脚上，从而无法继续攀爬。</li></ol></li></ul><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><ul><li>攀登成功会带来成就感，让人能为之着迷。</li><li>左脚趾弯曲会疼痛，右臂力量使用不畅，身体四肢协调较差，平时仅做跑步锻炼看来过于单一，需要刻意练习一下。</li></ul><h2 id="题外"><a href="#题外" class="headerlink" title="题外"></a>题外</h2><ul><li>同学鞋子被别人穿错穿走了，还坐上飞机了。。。幸好对方愿意赔偿一双新鞋，算是个有趣的插曲吧。。。。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 2022随记 </category>
          
          <category> 攀岩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PBR学习笔记</title>
      <link href="/2022/05/03/PBR%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/05/03/PBR%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>PBR(Physically Based Rendering)并不是为了追求游戏画面与真实照片一样真实，其更多的是为了只需要实现一个万能的shader，这个shader就可以渲染绝大部分类型的材质，而不用针对每种材质专门写一种shader。</p></blockquote><a id="more"></a><h1 id="光是什么"><a href="#光是什么" class="headerlink" title="光是什么"></a>光是什么</h1><ul><li>我的理解，光是一种能量，其在场景中由发光源（如太阳、电灯）发射出来，照射到场景的其他物体上时被物体吸收，未能吸收的部分经散射出来，其中部分恰好能进入我们的眼睛，形成了物体的颜色、光泽度。</li></ul><h1 id="PBR-Physically-Based-Rendering"><a href="#PBR-Physically-Based-Rendering" class="headerlink" title="PBR(Physically Based Rendering)"></a>PBR(Physically Based Rendering)</h1><h2 id="PBR是什么"><a href="#PBR是什么" class="headerlink" title="PBR是什么"></a>PBR是什么</h2><ul><li>PBR，即基于物理的渲染，但说是基于物理，它也只是对基于物理原理的现实世界的一种近似。</li><li>区分渲染是否为基于物理的，必须满足以下三个条件：<ol><li>基于微平面(Microfacet)的表面模型。<ul><li><img src="/2022/05/03/PBR学习笔记/rought_smooth.png" alt=""></li><li>光滑表面的微平面的法线变化较小，反射光线的方向变化也更小。 右图：粗糙表面的微平面的法线变化较大，反射光线的方向变化也更大。</li><li><img src="/2022/05/03/PBR学习笔记/ndf.png" alt=""></li><li>较高的粗糙度值显示出来的镜面反射的轮廓要更大一些。与之相反地，较小的粗糙值显示出的镜面反射轮廓则更小更锐利。</li><li><img src="/2022/05/03/PBR学习笔记/surface.png" alt=""></li><li>由微表面反射的光可以被认为是该点上一些方向变化不大的反射光，如上图的橙线。</li><li>对于散射光，需要考虑两种情况：<ol><li>如散射光线的出射位置离入射位置较远（大于像素距离），如左图所示，就需要考虑次表面散射渲染技术，如光线在皮肤、玉器上照射的效果。</li><li>如散射光线的出射位置离入射位置较近（小于像素距离），如右图所示，这些次表面散射所产生的距离就可以被忽视，我们可以认为散射光线也是从入射位置出射，进而让渲染完全在局部内完成。</li></ol></li></ul></li><li>满足能量守恒。<ul><li>出射光线的能量永远不能超过入射光线的能量（自发光除外）。</li></ul></li><li>应用基于物理的BRDF(Bidirectional Reflective Distribution Function)双向反射分布函数。<ul><li>BRDF是否基于物理，可以通过其是否满足两个特性来判断：<ol><li>交换律：<ul><li>即交换I和v的值后，BRDF值不变。</li><li>$ f(I,v)=f(v,I) $</li></ul></li><li>能量守恒：<ul><li>表面反射的能量不能超过入射的光能。</li><li>$ ∀I,\int_Ωf(I,v)(n·I)dω_o \le 1 $</li></ul></li></ol></li></ul></li></ol></li></ul><h2 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h2><ul><li>在学习PBR之前，我们先看下渲染方程。</li><li><img src="/2022/05/03/PBR学习笔记/渲染方程参数的通俗理解.jpg" alt=""></li><li>去掉自发光部分，我们便能得到反射率方程，要正确的理解PBR很重要的一点就是要首先透彻的理解反射率方程：</li><li><img src="/2022/05/03/PBR学习笔记/反射率方程.png" alt=""></li><li>反射率方程将在后面逐点讲解。</li></ul><h1 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h1><div class="table-container"><table><thead><tr><th>名称</th><th>符号</th><th>单位</th><th>公式</th><th>解析</th><th>图例</th></tr></thead><tbody><tr><td>辐射能量</td><td>$ Q $</td><td>焦耳($J$)</td><td>-</td><td>电磁辐射能量</td><td></td></tr><tr><td>辐射通量</td><td>$ Φ $</td><td>瓦特($W$)</td><td>$ Φ=\frac{dQ}{dt} $</td><td>单位时间辐射的能量，也叫辐射功率。</td><td></td></tr><tr><td>立体角</td><td>$ ω $</td><td>立体弧度，球面度($sr$)</td><td>$ ω=\frac{S}{r^2} $</td><td>二维弧度的三维拓展，按照球的表面积为$4πr^2$，那整个球的立体角为$4π$。</td><td><img src="/2022/05/03/PBR学习笔记/solid_angle.png" alt=""></td></tr><tr><td>辐射强度</td><td>$ I $</td><td>瓦/立体角($W/sr$)</td><td>$ I=\frac{dΦ}{dω} $</td><td>通过单位立体角的辐射通量。</td><td></td></tr><tr><td>辐射率</td><td>$ L $</td><td>瓦/平方米立体角($W/m^2sr$)</td><td>$ L=\frac{d^2Φ}{dωdAcosθ} $</td><td>通过单位面积单位立体角的辐射通量。</td><td><img src="/2022/05/03/PBR学习笔记/面积计算.png" alt=""> <img src="/2022/05/03/PBR学习笔记/辐射率.jpg" alt=""></td></tr></tbody></table></div><ul><li>辐射率方程：$ L=\frac{d^2Φ}{dωdAcosθ} $</li><li>辐射率方程很有用，因为它把大部分我们感兴趣的物理量都包含了进去。如果我们把立体角ω和面积A看作是无穷小的，那么我们就能用辐射率来表示单束光线穿过空间中的一个点的通量。这就使我们可以计算得出作用于单个（片段）点上的单束光线的辐射率，我们实际上把立体角ω转变为方向向量ω然后把面A转换为点p。这样我们就能直接在我们的着色器中使用辐射率来计算单束光线对每个片段的作用了。</li></ul><h1 id="反射率方程"><a href="#反射率方程" class="headerlink" title="反射率方程"></a>反射率方程</h1><h2 id="方程解读"><a href="#方程解读" class="headerlink" title="方程解读"></a>方程解读</h2><ul><li><img src="/2022/05/03/PBR学习笔记/反射率方程.png" alt=""></li></ul><div class="table-container"><table><thead><tr><th>符号</th><th>解析</th></tr></thead><tbody><tr><td>$ω_i$</td><td>入射方向无限小的立体角，可以视为入射方向向量。</td></tr><tr><td>$ω_o$</td><td>观察方向，也就是出射方向。</td></tr><tr><td>$p$</td><td>光线作用点。</td></tr><tr><td>$L_i$</td><td>通过某个无限小的立体角$ω_i$在某个点上的辐射率。</td></tr><tr><td>$n⋅ω_i$</td><td>光线和平面间的入射角的余弦值$cosθ$来计算能量。</td></tr><tr><td>$L_o$</td><td>从$ω_o$方向上观察，光线投射到点$p$上反射出来的辐照度。</td></tr></tbody></table></div><ul><li>基于反射率公式是围绕所有入射辐射率的总和，也就是辐照度来计算的，所以我们需要计算的就不只是单一的一个方向上的入射光，而是一个以点$p$为球心的半球领域$Ω$内所有方向上的入射光。一个半球领域(Hemisphere)可以描述为以平面法线$n$为轴所环绕的半个球体：<ul><li><img src="/2022/05/03/PBR学习笔记/hemisphere.png" alt=""></li></ul></li><li><p>计算半球的入射辐射率总和需要用到积分，而渲染方程和反射率方程没有解析解，我们使用离散求和的方式来求得积分的数值解。这个问题就转化为，在半球领域Ω中按一定的步长将反射率方程分散求解，然后再按照步长大小将所得到的结果平均化。这种方法被称为黎曼和(Riemann sum)。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> steps = <span class="hljs-number">100</span>;<br><span class="hljs-keyword">float</span> sum = <span class="hljs-number">0.0f</span>;<br>vec3 P    = ...;<br>vec3 Wo   = ...;<br>vec3 N    = ...;<br><span class="hljs-keyword">float</span> dW  = <span class="hljs-number">1.0f</span> / steps;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; steps; ++i)<br>&#123;<br>    vec3 Wi = getNextIncomingLightDir(i);<br>    sum += Fr(p, Wi, Wo) * L(p, Wi) * dot(N, Wi) * dW;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>现在唯一剩下的未知符号就是$fr$了，它被称为BRDF，或者双向反射分布函数(Bidirectional Reflective Distribution Function) ，它的作用是基于表面材质属性来对入射辐射率进行缩放或者加权。</p></li></ul><h2 id="Cook-Torrance-BRDF"><a href="#Cook-Torrance-BRDF" class="headerlink" title="Cook-Torrance BRDF"></a>Cook-Torrance BRDF</h2><ul><li>在本文中将学习使用到的是Cook-Torrance反射率方程：</li><li><img src="/2022/05/03/PBR学习笔记/Cook-Torrance反射率方程.png" alt=""></li><li><img src="/2022/05/03/PBR学习笔记/Cook-Torrance反射率方程文字描述.png" alt=""></li><li>BRDF可以分成两部分来查看，漫反射部分和镜面反射部分。</li><li><img src="/2022/05/03/PBR学习笔记/brdf.png" alt=""></li></ul><h3 id="漫反射部分"><a href="#漫反射部分" class="headerlink" title="漫反射部分"></a>漫反射部分</h3><ul><li>不看$k_d$，漫反射部分则为$\frac{c}{π}$，这即为大家熟知的Lambert模型。</li><li>$ f<em>{Lambert}(I,v)=\frac{c</em>{diff}}{π} $</li><li>式子除以$π$是因为我们假设漫反射在所有方向上的强度都是相同的，而BRDF要求在半球内的积分值为1。为何是$π$则需要根据能量守恒去计算，这里不作讲解。</li></ul><h3 id="镜面反射部分"><a href="#镜面反射部分" class="headerlink" title="镜面反射部分"></a>镜面反射部分</h3><ul><li>$ f_{specular}(I,v)=\frac{D(h)G(I,v,h)F(I,h)}{4(v·n)(I·n)} $</li><li><img src="/2022/05/03/PBR学习笔记/m_h.png" alt=""></li></ul><div class="table-container"><table><thead><tr><th>符号</th><th>解析</th></tr></thead><tbody><tr><td>$D(h)$</td><td>法线分布函数，用于表示有多少比例的微面元满足m=h，只有这部分微面元才会把光线从I方向反射到v上。</td></tr><tr><td>$G(I,v,h)$</td><td>阴影-遮掩函数，用于计算满足m=h的微面元中有多少会被遮挡而不被看到，因此它给出了活跃微面元所占的浓度比。</td></tr><tr><td>$F(I,h)$</td><td>活跃微面元的菲涅尔反射函数，用来表示每个活跃的微面元会把多少入射光线反射到观察方向上，即表示了反射光线占入射光线的比率。</td></tr><tr><td>$4(v·n)(I·n)$</td><td>用于矫正从微面元的局部空间到整体宏观表面数量差异的矫正因子。</td></tr></tbody></table></div><h4 id="法线分布函数-D-h"><a href="#法线分布函数-D-h" class="headerlink" title="法线分布函数$D(h)$"></a>法线分布函数$D(h)$</h4><ul><li><img src="/2022/05/03/PBR学习笔记/法线分布函数.jpg" alt=""></li><li>在这里$h$表示用来与平面上微平面做比较用的中间向量，而$α$表示表面粗糙度。</li><li>如果我们把$h$当成是不同粗糙度参数下，平面法向量和光线方向向量之间的中间向量的话，我们可以得到如下图示的效果：</li><li><img src="/2022/05/03/PBR学习笔记/ndf.png" alt=""></li></ul><h4 id="阴影-遮掩函数-G-I-v-h"><a href="#阴影-遮掩函数-G-I-v-h" class="headerlink" title="阴影-遮掩函数$G(I,v,h)$"></a>阴影-遮掩函数$G(I,v,h)$</h4><ul><li>这里介绍的阴影-遮掩函数是GGX与Schlick-Beckmann近似的结合体，因此又称为Schlick-GGX：</li><li><img src="/2022/05/03/PBR学习笔记/阴影-遮蔽函数.jpg" alt=""></li><li><img src="/2022/05/03/PBR学习笔记/geometry_shadowing.png" alt=""></li><li>从统计学上近似的求得了微平面间相互遮蔽的比率，这种相互遮蔽会损耗光线的能量。</li><li>这里的$k$是$α$基于几何函数是针对直接光照还是针对IBL光照的重映射(Remapping) :<ul><li>$ α=roughness $</li><li>$ k_{direct}=\frac{(α+1)^2}{8} $</li><li>$ k_{IBL}=\frac{α^2}{2} $</li></ul></li><li>由于遮蔽在入射方向和出射方向都会产生，需要将观察方向（几何遮蔽(Geometry Obstruction)）和光线方向向量（几何阴影(Geometry Shadowing)）都考虑进去。我们可以使用史密斯法(Smith’s method)来把两者都纳入其中：</li><li><img src="/2022/05/03/PBR学习笔记/smith_ggx.jpg" alt=""></li><li>使用史密斯法与Schlick-GGX作为$G_{sub}$可以得到如下所示不同粗糙度的视觉效果：</li><li><p><img src="/2022/05/03/PBR学习笔记/geometry.png" alt=""></p></li><li><p>在Unity中使用的阴影-遮蔽函数$G(I,v,h)$则使用了一种由GGX衍生出来的 Smith-Schlick 模型：</p><ul><li>$ G(I,v,h)=\frac{1}{((n·I)(1-k)+k)((n·v)(1-k)+k)} $</li><li>$ k=\frac{roughness^2}{2} $</li></ul></li></ul><h4 id="菲涅尔反射函数-F-I-h"><a href="#菲涅尔反射函数-F-I-h" class="headerlink" title="菲涅尔反射函数$F(I,h)$"></a>菲涅尔反射函数$F(I,h)$</h4><ul><li>菲涅尔方程是一个相当复杂的方程式，不过幸运的是菲涅尔方程可以用Fresnel-Schlick近似法求得近似解。</li><li>$ F_{Schlick}(h,v,F_0)=F0+(1−F_0)(1−(h⋅v))^5 $</li></ul><h1 id="PBR材质"><a href="#PBR材质" class="headerlink" title="PBR材质"></a>PBR材质</h1><ul><li>上面提及到的粗糙度可通过贴图指定，菲涅尔$F_0$值可通过查表得到。</li><li>PBR材质一般包含下面的纹理：</li><li><img src="/2022/05/03/PBR学习笔记/textures.png" alt=""></li><li>反照率：反照率(Albedo)纹理为每一个金属的纹素(Texel)（纹理像素）指定表面颜色或者基础反射率。漫反射纹理的图像当中常常包含一些细小的阴影或者深色的裂纹，而反照率纹理中是不会有这些东西的。它应该只包含表面的颜色（或者折射吸收系数）。</li><li>法线：法线贴图使我们可以逐片段的指定独特的法线，来为表面制造出起伏不平的假象。</li><li>金属度：金属(Metallic)贴图逐个纹素的指定该纹素是不是金属质地的。根据PBR引擎设置的不同，美术师们既可以将金属度编写为灰度值又可以编写为1或0这样的二元值。</li><li>粗糙度：粗糙度(Roughness)贴图可以以纹素为单位指定某个表面有多粗糙。采样得来的粗糙度数值会影响一个表面的微平面统计学上的取向度。</li><li>AO：环境光遮蔽(Ambient Occlusion)贴图或者说AO贴图为表面和周围潜在的几何图形指定了一个额外的阴影因子。比如如果我们有一个砖块表面，反照率纹理上的砖块裂缝部分应该没有任何阴影信息。然而AO贴图则会把那些光线较难逃逸出来的暗色边缘指定出来。在光照的结尾阶段引入环境遮蔽可以明显的提升你场景的视觉效果。网格/表面的环境遮蔽贴图要么通过手动生成，要么由3D建模软件自动生成。</li></ul><h1 id="学习参考资料："><a href="#学习参考资料：" class="headerlink" title="学习参考资料："></a>学习参考资料：</h1><ul><li>《Unity Shader入门精要》</li><li><a href="https://zhuanlan.zhihu.com/p/427854383" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/427854383</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> PBR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> PBR </tag>
            
            <tag> BRDF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高性能定点数实现方案</title>
      <link href="/2021/10/17/%E9%AB%98%E6%80%A7%E8%83%BD%E5%AE%9A%E7%82%B9%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
      <url>/2021/10/17/%E9%AB%98%E6%80%A7%E8%83%BD%E5%AE%9A%E7%82%B9%E6%95%B0%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>《腾讯游戏开发精粹》学习笔记。<br>高性能的定点数实现方案。</p></blockquote><a id="more"></a><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><ul><li>游戏中通常使用浮点数来表示实数，但各个硬件平台并没有严格遵守浮点数标准IEEE 754，导致不同平台上的浮点计算不能保证严格一致，这些浮点计算的误差累积，容易导致游戏后续在不同机器上存在不同表现。</li><li>如两台机器用同一个随机数种子，但由于误差累积，会出现一台机器计算随机概率通过产生暴击伤害，另一台不通过不产生暴击伤害的情况。</li><li>书中的定点数运算基于整数运算实现，其可保证在不同平台上计算结果具有一致性。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul><li>浮点数的小数点位置是跟随最高位浮动的，因此它的精度也是浮动的。在CPU架构里，浮点运算通常由FPU来处理，遵循IEEE 754标准，但实践中并不完全遵守，如在同一个CPU里，FPU和SSE指令得到的结果不一致。<h3 id="浮点数的表示原理"><a href="#浮点数的表示原理" class="headerlink" title="浮点数的表示原理"></a>浮点数的表示原理</h3></li><li><img src="/2021/10/17/高性能定点数实现方案/32位浮点数结构.png" style="width: 36em;" alt="32位浮点数结构"></li><li><script type="math/tex; mode=display">value = (-1)^S*2^{E-127}</script></li></ul><h3 id="基于整数的二进制表示的定点数"><a href="#基于整数的二进制表示的定点数" class="headerlink" title="基于整数的二进制表示的定点数"></a>基于整数的二进制表示的定点数</h3><ul><li><img src="/2021/10/17/高性能定点数实现方案/32位定点数结构.png" style="width: 36em;" alt="32位定点数结构"></li><li>把整数的二进制表示中较低的n位视为小数部分，设a位定点数，f(a)为这个定点数对应的整数值，那么a的值为：</li><li><script type="math/tex; mode=display">a = 2^{-n}f(a)</script></li><li>精度为$ 1/2^{10} = 1/1024 = 0.0009765625 $ ， 数字范围为 $ [-2^{21}, 2^{21}-2^{-10}] $ 。</li><li>正负不对称是因为存在正负0，负0用于表示一个非0负数，故负数范围会大一个精度的值。</li><li>代码实现：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FScalar</span><br>&#123;</span><br>    <span class="hljs-built_in">std</span>::<span class="hljs-keyword">int32_t</span> rawValue;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">int32_t</span> fractionBits = <span class="hljs-number">10</span>;    <span class="hljs-comment">// 小数位数。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-keyword">int32_t</span> wholeBits = <span class="hljs-number">22</span>;   <span class="hljs-comment">// 整数位数。</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="运算中的trick"><a href="#运算中的trick" class="headerlink" title="运算中的trick"></a>运算中的trick</h3><h4 id="乘法实现"><a href="#乘法实现" class="headerlink" title="乘法实现"></a>乘法实现</h4><ul><li>定点数两数相乘的计算方式是 <code>result = (a * b)&gt;&gt;10</code>，先乘后除的方式存在信息丢失和溢出的可能，故这里先转为64位乘法相乘结果再做除法，即：<code>result = (std::int64_t(a) * b)&gt;&gt;10</code>。</li><li>对于64位的定点数，如果使用GCC，可以用<code>_int128_t</code>做乘法中间结果，对于VC，则可用<code>intrinsic function _mull128</code>来将中间结果存放于两个<code>int64_t</code>中。<h4 id="除法实现"><a href="#除法实现" class="headerlink" title="除法实现"></a>除法实现</h4></li><li>除法与乘法类似，其计算方式是 <code>result = (std::int64_t(a) &lt;&lt; 10) / b</code>。<h4 id="多项式拟合及在函数上的应用"><a href="#多项式拟合及在函数上的应用" class="headerlink" title="多项式拟合及在函数上的应用"></a>多项式拟合及在函数上的应用</h4></li><li>在区间[a, b]上可以用n次多项式$P{n}(x)$近似求解我们要求解的函数$f(x)$。</li><li>近似求解的误差有多种表示方式，书中使用的方式是用误差绝对值在区间[a, b]上的最大值来衡量近似求解方式的误差，从而将问题转换为对于给定的n，求出$P{n}$的系数，使得误差绝对值在区间[a, b]上的最大值最小，即：$ \min<em>{P</em>{n}}max<em>{x∈[a, b]}|P</em>{n}(x) - f(x)| $</li><li>为何不查表替代多项式拟合法，书中给出其两个缺点：<ol><li>依赖定点数的表示，一旦对定点数的表示格式做出微小的调整，表中所有的数据都要更新。</li><li>在进行密集的数学运算时，查表法对高速缓存利用率高；对于其他常用的情况，则容易遇到缓存命中失败的情况。</li></ol></li><li>书中正弦/余弦函数的实现，很好的体现了MinMax多项式拟合法的应用。<ul><li><img src="/2021/10/17/高性能定点数实现方案/正余弦函数.png" style="width: 24em;" alt="正余弦函数"></li></ul><ol><li>将平面8等分，则所有的角度均可表示为：$ angle = kπ/4 + x $，这里k用于表示angle落于8等分的平面的哪一分块中。</li><li>记角的终边和最近的坐标轴所在直线的夹角θ，如果k是偶数，则θ=x，反之θ=π/4-x。</li><li>先利用拟合多项式求出θ/2的正弦/余弦值，再利用二倍角公式即可求出sinθ，cosθ。<ul><li><script type="math/tex; mode=display">sinθ = 2sin\fracθ{2}cos\fracθ{2}</script></li><li><script type="math/tex; mode=display">cosθ = cos^2\fracθ{2} - sin^2\fracθ{2}</script></li><li>这里不直接拟合θ而是拟合θ/2，是为了将拟合函数的取值约束在[0, π/4)中， 从而只需要使用一个拟合函数即可。</li></ul></li><li>最后再根据角的终边所在的位置，即可得出终边 $sin<em>{angle}, cos</em>{angle}$ 和sinθ， cosθ间的关系，从而算出结果。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> 《腾讯游戏开发精粹》学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一个简易RPG游戏的搭建</title>
      <link href="/2021/10/07/%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93RPG%E6%B8%B8%E6%88%8F%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/10/07/%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93RPG%E6%B8%B8%E6%88%8F%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用Unity版本为：2019.4.10f1。<br>最终效果：<img src="/2021/10/07/一个简易RPG游戏的搭建/result.png" style="width: 36em;" alt="效果展示"></p></blockquote><hr><a id="more"></a><h2 id="场景搭建"><a href="#场景搭建" class="headerlink" title="场景搭建"></a>场景搭建</h2><h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><ul><li><img src="/2021/10/07/一个简易RPG游戏的搭建/asset_scene.png" style="width: 30em;" alt="资源"></li></ul><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><ul><li>资源包中已有大量prefab，将它们拖拽到场景中进行摆放即可。</li><li><img src="/2021/10/07/一个简易RPG游戏的搭建/scene_prefab.png" style="width: 38em;" alt="资源"></li><li>摆放场景物体，建议将它们分门别类收纳在一个空对象下放置，方便后续对整一类物体做统一修改。</li><li><img src="/2021/10/07/一个简易RPG游戏的搭建/场景物品分类摆放.png" style="width: 12em;" alt=""></li><li>这里我直接白嫖资源包中自带的场景demo（真香）。</li></ul><h2 id="场景主角"><a href="#场景主角" class="headerlink" title="场景主角"></a>场景主角</h2><h3 id="资源-1"><a href="#资源-1" class="headerlink" title="资源"></a>资源</h3><ul><li><img src="/2021/10/07/一个简易RPG游戏的搭建/asset_hero.png" style="width: 30em;" alt=""></li></ul><h3 id="动作管理"><a href="#动作管理" class="headerlink" title="动作管理"></a>动作管理</h3><ul><li>这里使用动作状态机（Animator）来管理主角的动作，根据Idle和Walk状态的切换通过move来控制。</li><li><img src="/2021/10/07/一个简易RPG游戏的搭建/animator_hero.png" style="width: 36em;" alt=""></li><li>正常而言，主角还应设置攻击、施法、跑动、受到攻击、死亡等动作，由于没做相关功能实现，便没添加。</li></ul><h3 id="角色移动"><a href="#角色移动" class="headerlink" title="角色移动"></a>角色移动</h3><ul><li>主角移动可以用character control配合脚本来使用，也可以用navigation省去繁杂的设置，这里选择使用导航系统navigation来支持角色移动。</li><li>先将场景中与寻路相关，会与角色产生阻挡、碰撞的模型都选中，将它们Static都设置为Navigation Static。</li><li><img src="/2021/10/07/一个简易RPG游戏的搭建/navigation_map.png" style="width: 28em;" alt=""></li><li>然后再预烘焙好寻路网格，具体为点击下图的bake按钮，Navigation还可以设置跳跃，坡度等，详细使用方式这里不展开说明。</li><li><img src="/2021/10/07/一个简易RPG游戏的搭建/navigation_bake.png" style="width: 28em;" alt=""></li><li>如果没能找到Navigation分页，则通过点击Window-&gt;AI-&gt;Navigation将其显示出来。</li><li><img src="/2021/10/07/一个简易RPG游戏的搭建/navigation_widget.png" style="width: 28em;" alt=""></li><li>给主角添加Nav Mesh Agent，再通过脚本用Agent来控制主角移动即可，具体代码如下，关键代码是 m_NavMeshAgent.SetDestination 这句。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(Input.GetMouseButtonDown(<span class="hljs-number">0</span>) &amp;&amp; !EventSystem.current.IsPointerOverGameObject()) &#123;<br>        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);<br>        RaycastHit hitInfo;<br>        <span class="hljs-keyword">bool</span> bCollider = Physics.Raycast(ray, out hitInfo);<br>        <span class="hljs-keyword">if</span>(bCollider &amp;&amp; hitInfo.collider.tag == Tags.Ground) &#123;<br>            ShowClickEff(hitInfo.point);<br>            m_IsMoving = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(Input.GetMouseButtonUp(<span class="hljs-number">0</span>)) &#123;<br>        m_IsMoving = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(m_IsMoving) &#123;<br>        <span class="hljs-keyword">if</span> (m_MoveStateMask == (<span class="hljs-keyword">int</span>)STATE_MOVE.MAP_MOVE) &#123;<br>            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);<br>            RaycastHit hitInfo;<br>            <span class="hljs-keyword">bool</span> bCollider = Physics.Raycast(ray, out hitInfo);<br>            <span class="hljs-keyword">if</span> (bCollider &amp;&amp; Vector3.Distance(hitInfo.point, <span class="hljs-keyword">this</span>.transform.position) &gt; <span class="hljs-number">1.2f</span>) &#123; <span class="hljs-comment">// 防止原地LookAt导致头朝地。</span><br>                m_NavMeshAgent.isStopped = <span class="hljs-literal">false</span>;<br>                m_NavMeshAgent.SetDestination(hitInfo.point);   <span class="hljs-comment">// TODO 每帧都设置相同位置会不移动，原因未知，点击房屋可重现。</span><br>                                                                <span class="hljs-comment">// LookAtTarget(hitInfo.point);</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (m_MoveStateMask != (<span class="hljs-keyword">int</span>)STATE_MOVE.MAP_MOVE) &#123;<br>        m_NavMeshAgent.isStopped = <span class="hljs-literal">true</span>;<br>    &#125;<br>    m_Animtor.SetBool(<span class="hljs-string">"move"</span>, m_NavMeshAgent.velocity.magnitude &gt; <span class="hljs-number">1.0f</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="摄像机跟随、旋转、缩放"><a href="#摄像机跟随、旋转、缩放" class="headerlink" title="摄像机跟随、旋转、缩放"></a>摄像机跟随、旋转、缩放</h3><ul><li>跟随只需要让摄像机与主角一直保持相同的位置偏移即可，那么即是在Update中每帧更新摄像机位置，让其与主角保持设定的位置偏移。</li><li><p>为了避免摄像机出现剧烈抖动，即主角快速跨过高低不平的路面时摄像机也会跟随着剧烈抖动，这里对摄像机位置的设置是通过Vector3.Lerp逐渐平滑过去。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">UpdateCameraPos</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// m_Player 是主角的transform。</span><br>    Vector3 v3Target = m_Player.position + m_CamAndPlayerOffset;<br>    <span class="hljs-keyword">this</span>.transform.position = Vector3.Lerp(<span class="hljs-keyword">this</span>.transform.position, v3Target, Time.deltaTime * <span class="hljs-number">3.0f</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>旋转和缩放则是通过获取鼠标右键输入来控制，并添加一定范围限制。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ScrollView</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">float</span> fValue = Input.GetAxis(<span class="hljs-string">"Mouse ScrollWheel"</span>);<br>    <span class="hljs-keyword">float</span> fDis = m_CamAndPlayerOffset.magnitude - fValue * m_ScrollViewSpeed;<br>    fDis = Mathf.Clamp(fDis, <span class="hljs-number">10</span>, <span class="hljs-number">24</span>);<br>    m_CamAndPlayerOffset = fDis * m_CamAndPlayerOffset.normalized;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RotateView</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span> (Input.GetMouseButtonDown(<span class="hljs-number">1</span>)) &#123;<br>        m_IsRotatingView = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (Input.GetMouseButtonUp(<span class="hljs-number">1</span>)) &#123;<br>        m_IsRotatingView = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (m_IsRotatingView) &#123;<br>        <span class="hljs-keyword">this</span>.transform.position = m_Player.position + m_CamAndPlayerOffset;<br><br>        <span class="hljs-keyword">float</span> fXValue = Input.GetAxis(<span class="hljs-string">"Mouse X"</span>);<br>        <span class="hljs-keyword">this</span>.transform.RotateAround(m_Player.transform.position, m_Player.transform.up, fXValue * m_RotateViewSpeed);<br><br>        <span class="hljs-keyword">float</span> fYValue = Input.GetAxis(<span class="hljs-string">"Mouse Y"</span>);<br>        Vector3 vOrgPos = <span class="hljs-keyword">this</span>.transform.position;<br>        Quaternion sOrgRotation = <span class="hljs-keyword">this</span>.transform.rotation;<br>        <span class="hljs-keyword">this</span>.transform.RotateAround(m_Player.transform.position, <span class="hljs-keyword">this</span>.transform.right, -fYValue * m_RotateViewSpeed);<br>        <span class="hljs-keyword">float</span> fEulerAngleX = <span class="hljs-keyword">this</span>.transform.eulerAngles.x;<br>        <span class="hljs-keyword">if</span> (fEulerAngleX &lt; <span class="hljs-number">30</span> || fEulerAngleX &gt; <span class="hljs-number">70</span>) &#123;<br>            <span class="hljs-keyword">this</span>.transform.position = vOrgPos;<br>            <span class="hljs-keyword">this</span>.transform.rotation = sOrgRotation;<br>        &#125;<br><br>        m_CamAndPlayerOffset = <span class="hljs-keyword">this</span>.transform.position - m_Player.position;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h2><h3 id="资源-2"><a href="#资源-2" class="headerlink" title="资源"></a>资源</h3><ul><li><img src="/2021/10/07/一个简易RPG游戏的搭建/asset_gui.png" style="width: 30em;" alt="资源"><h3 id="UI排布"><a href="#UI排布" class="headerlink" title="UI排布"></a>UI排布</h3></li><li><img src="/2021/10/07/一个简易RPG游戏的搭建/ui.png" alt=""></li><li>如上图所示，该例子只做了4个小UI界面，对话框、选项框、主角状态栏、小地图，它们都是Panels的子节点，Panels的锚点设置选择<img src="/2021/10/07/一个简易RPG游戏的搭建/panels_anchor.png" style="width: 5em;" alt="">，以让其子节点能跟随画面缩放自动适配到正确位置。</li><li>对话框、选项框、主角状态栏、小地图的UI设置和摆放方式按自己喜欢的方式弄即可，都是一些常用UI组建组合使用。<h3 id="小地图、对话框NPC头像"><a href="#小地图、对话框NPC头像" class="headerlink" title="小地图、对话框NPC头像"></a>小地图、对话框NPC头像</h3></li><li>小地图的实现可以通过离线方式输出地图简略版，同步更新主角在其上的位置，也可以用比较省事的方式，在主角头上挂一个正交摄像机从地图高空中拍下当前地图输出到RenderTexture中，再将该RenderTexture作为Raw Image的texture输入进行显示。</li><li>使用RrenderTexture的好处是省事，坏处是场景需要渲染两遍，场景绘制消耗直接翻倍。</li><li>对于NPC头像，可以用离线资源做NPC头像，切换不同NPC时切换不同头像，这里由于只有NPC模型资源，所以NPC头像也采用小地图的做法。场景添加绘制NPC头像使用的摄像机，在显示对话框时，根据与哪个NPC对话来移动摄像机至该NPC前方，从而将NPC拍下来作为头像使用，摄像机需要设置Culling Mask为只绘制NPC，且Clipping Planes的远平面设置尽量小些，以避免拍摄到远处的NPC。</li><li><img src="/2021/10/07/一个简易RPG游戏的搭建/npc_photo_camera.png" style="width: 28em;" alt="NPC头像摄像机"></li></ul><h2 id="地图NPC"><a href="#地图NPC" class="headerlink" title="地图NPC"></a>地图NPC</h2><h3 id="资源-3"><a href="#资源-3" class="headerlink" title="资源"></a>资源</h3><ul><li><img src="/2021/10/07/一个简易RPG游戏的搭建/asset_npc.png" style="width: 30em;" alt="资源"><h3 id="NPC配置"><a href="#NPC配置" class="headerlink" title="NPC配置"></a>NPC配置</h3></li><li><img src="/2021/10/07/一个简易RPG游戏的搭建/npc_inspector.png" style="width: 26em;" alt=""></li><li>该项目中的NPC只会站在原地，不走动，故给它们设置的Animator弄成循环播放一些动作即可。</li><li>添加Box Collider以让鼠标能点击它们。</li><li>添加脚本拓展，支持设置其角色、名字、对话内容，弹出的选项框内容，具体不同NPC用不同脚本，对选项做不同处理。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMouseOver</span><span class="hljs-params">()</span><br></span>&#123;<br>    <span class="hljs-keyword">if</span>(Input.GetMouseButtonDown(<span class="hljs-number">0</span>) &amp;&amp; heromove.GetInst().IsInStateMapMove()) &#123;<br>        OnShowDialog();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnShowDialog</span><span class="hljs-params">()</span><br></span>&#123;<br>    GameObject oUIPanel = GameObject.FindGameObjectWithTag(Tags.UIPanel);<br>    <span class="hljs-keyword">if</span> (oUIPanel != null) &#123;<br>        GameObject oDialog = oUIPanel.transform.Find(<span class="hljs-string">"TalkDlg"</span>).gameObject;<br>        oDialog.SetActive(<span class="hljs-literal">true</span>);<br>        StartCoroutine(oDialog.GetComponent&lt;talkdlg&gt;().ShowDlg(<span class="hljs-keyword">this</span>.transform, m_Role, m_NPCName, m_Talk, OnShowDlgEnd));<br>    &#125;<br>&#125;<br><br><span class="hljs-function">override <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnShowDlgEnd</span><span class="hljs-params">()</span><br></span>&#123;<br>    GameObject oUIPanel = GameObject.FindGameObjectWithTag(Tags.UIPanel);<br>    <span class="hljs-keyword">if</span> (oUIPanel != null) &#123;<br>        GameObject oDialog = oUIPanel.transform.Find(<span class="hljs-string">"SelectDlg"</span>).gameObject;<br>        oDialog.SetActive(<span class="hljs-literal">true</span>);<br>        oDialog.GetComponent&lt;selectdlg&gt;().ShowDlg(ref m_Options, OnSelectCallback);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">OnSelectCallback</span><span class="hljs-params">(<span class="hljs-keyword">int</span> iSelect)</span><br></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="地图怪物"><a href="#地图怪物" class="headerlink" title="地图怪物"></a>地图怪物</h2><h3 id="资源-4"><a href="#资源-4" class="headerlink" title="资源"></a>资源</h3><ul><li><img src="/2021/10/07/一个简易RPG游戏的搭建/asset_dragon.png" style="width: 30em;" alt="资源"><h3 id="怪物配置"><a href="#怪物配置" class="headerlink" title="怪物配置"></a>怪物配置</h3></li><li><img src="/2021/10/07/一个简易RPG游戏的搭建/enemy_inspector.png" style="width: 22em;" alt=""></li><li><img src="/2021/10/07/一个简易RPG游戏的搭建/enemy_animator.png" style="width: 52em;" alt=""><h3 id="随机移动"><a href="#随机移动" class="headerlink" title="随机移动"></a>随机移动</h3></li><li>添加定时器，在触发时随机移动或停留即可，注意需要计算与出生点的距离，不宜走太远。<h3 id="攻击主角"><a href="#攻击主角" class="headerlink" title="攻击主角"></a>攻击主角</h3></li><li>在挨打时设置主角为其攻击目标，当攻击距离不足时则走向主角，攻击距离满足时则进行攻击。<h3 id="挨打死亡"><a href="#挨打死亡" class="headerlink" title="挨打死亡"></a>挨打死亡</h3></li><li><p>这里主角只做了个简单的范围法术，范围法术特效带有Collider，通过OnTriggerEnter方法来对其触碰到的敌人造成伤害。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> STATE_ENEMY<br>&#123;<br>    ALIVE,<br>    HURT,<br>    DEATH,<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">enemy</span> :</span> MonoBehaviour<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> m_HP;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> m_AttackDis = <span class="hljs-number">2.0f</span>;    <span class="hljs-comment">// 攻击距离。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> m_AttackTime = <span class="hljs-number">3.0f</span>;   <span class="hljs-comment">// 多少秒打一次。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> m_RandomMoveRadius = <span class="hljs-number">8.0f</span>; <span class="hljs-comment">// 随机移动半径。</span><br><br>    <span class="hljs-keyword">public</span> Animator m_Animator;<br><br>    <span class="hljs-keyword">private</span> UnityEngine.AI.NavMeshAgent m_NavMeshAgent;<br>    <span class="hljs-keyword">private</span> Transform m_Target = null;<br>    <span class="hljs-keyword">private</span> Vector3 m_OrgPos;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> m_RandomMoveTimer = <span class="hljs-number">0.0f</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> m_IsChangingToMove = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> m_AttackTimer = <span class="hljs-number">0.0f</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">bool</span> m_CanAttack = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> m_HurtTimer = <span class="hljs-number">0f</span>;<br>    <span class="hljs-keyword">private</span> STATE_ENEMY m_State;<br><br>    <span class="hljs-comment">// Start is called before the first frame update</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Start</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        m_State = STATE_ENEMY.ALIVE;<br>        m_Animator = GetComponent&lt;Animator&gt;();<br>        m_NavMeshAgent = <span class="hljs-keyword">this</span>.gameObject.GetComponent&lt;UnityEngine.AI.NavMeshAgent&gt;();<br>        m_OrgPos = <span class="hljs-keyword">this</span>.transform.position;<br>    &#125;<br><br>    <span class="hljs-comment">// Update is called once per frame</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Update</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_State == STATE_ENEMY.ALIVE) &#123;<br>            <span class="hljs-keyword">if</span> (!m_CanAttack) &#123;<br>                m_AttackTimer += Time.deltaTime;<br>                <span class="hljs-keyword">if</span> (m_AttackTimer &gt; m_AttackTime) &#123;<br>                    m_CanAttack = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (m_Target != null) &#123;<br>                <span class="hljs-keyword">float</span> fDis2Target = Vector3.Distance(<span class="hljs-keyword">this</span>.transform.position, m_Target.position);<br>                <span class="hljs-keyword">if</span> (fDis2Target &lt; m_AttackDis) &#123;<br>                    <span class="hljs-keyword">if</span> (m_CanAttack) &#123;<br>                        AttackTarget();<br>                        m_CanAttack = <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        SetNoMove();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    SeekToTarget();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                RandomMove();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m_State == STATE_ENEMY.HURT) &#123;<br>            m_HurtTimer -= Time.deltaTime;<br>            <span class="hljs-keyword">if</span> (m_HurtTimer &lt; <span class="hljs-number">0.0f</span>) &#123;<br>                m_HurtTimer = <span class="hljs-number">0.0f</span>;<br>                m_State = STATE_ENEMY.ALIVE;<br>                m_Animator.SetBool(<span class="hljs-string">"hurt"</span>, <span class="hljs-literal">false</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AttackTarget</span><span class="hljs-params">()</span><br>    </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SeekToTarget</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        <span class="hljs-keyword">if</span> (m_Animator.GetCurrentAnimatorStateInfo(<span class="hljs-number">0</span>).IsName(<span class="hljs-string">"Run"</span>)) &#123;<br>            m_NavMeshAgent.SetDestination(m_Target.position);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">SetNoMove</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        m_Animator.SetBool(<span class="hljs-string">"move"</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">RandomMove</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        m_RandomMoveTimer += Time.deltaTime;<br>        <span class="hljs-keyword">if</span> (m_RandomMoveTimer &gt; <span class="hljs-number">2.0f</span>) &#123;<br>            m_RandomMoveTimer = <span class="hljs-number">0.0f</span>;<br>            <span class="hljs-keyword">int</span> iState = Random.Range(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>);<br>            <span class="hljs-keyword">float</span> fYRotation = Random.Range(<span class="hljs-number">0f</span>, <span class="hljs-number">360f</span>);<br>            <span class="hljs-keyword">this</span>.transform.Rotate(<span class="hljs-keyword">this</span>.transform.up, fYRotation);<br>            <span class="hljs-keyword">if</span> (iState == <span class="hljs-number">0</span>) &#123;<br>                m_Animator.SetBool(<span class="hljs-string">"move"</span>, <span class="hljs-literal">false</span>);<br>                m_IsChangingToMove = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                m_Animator.SetBool(<span class="hljs-string">"move"</span>, <span class="hljs-literal">true</span>);<br>                m_IsChangingToMove = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (m_Animator.GetCurrentAnimatorStateInfo(<span class="hljs-number">0</span>).IsName(<span class="hljs-string">"Run"</span>) &amp;&amp; m_IsChangingToMove) &#123;<br>            m_IsChangingToMove = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">float</span> fDis = Random.Range(<span class="hljs-number">0.1f</span>, m_RandomMoveRadius);<br>            Vector3 v3TargetPos = <span class="hljs-keyword">this</span>.transform.position + <span class="hljs-keyword">this</span>.transform.forward * fDis;<br>            <span class="hljs-keyword">float</span> fDis2OrgPos = Vector3.Distance(m_OrgPos, v3TargetPos);<br>            <span class="hljs-keyword">if</span> (fDis2OrgPos &gt; m_RandomMoveRadius) &#123;<br>                v3TargetPos = (v3TargetPos - m_OrgPos) / fDis2OrgPos * m_RandomMoveRadius + m_OrgPos;<br>            &#125;<br>            m_NavMeshAgent.SetDestination(v3TargetPos);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TakeHurt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> iHurt)</span><br>    </span>&#123;<br>        m_HP -= iHurt;<br>        <span class="hljs-keyword">if</span> (m_HP &lt;= <span class="hljs-number">0</span>) &#123;<br>            m_HP = <span class="hljs-number">0</span>;<br>            m_State = STATE_ENEMY.DEATH;<br>            m_NavMeshAgent.isStopped = <span class="hljs-literal">true</span>;<br>            m_Animator.SetBool(<span class="hljs-string">"move"</span>, <span class="hljs-literal">false</span>);<br>            m_Animator.SetBool(<span class="hljs-string">"die"</span>, <span class="hljs-literal">true</span>);<br><br>            Invoke(<span class="hljs-string">"DestorySelf"</span>, <span class="hljs-number">3.0f</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            m_State = STATE_ENEMY.HURT;<br>            m_NavMeshAgent.SetDestination(<span class="hljs-keyword">this</span>.transform.position);<br>            m_HurtTimer = <span class="hljs-number">0.5f</span>;<br>            m_Animator.SetBool(<span class="hljs-string">"hurt"</span>, <span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DestorySelf</span><span class="hljs-params">()</span><br>    </span>&#123;<br>        Destroy(<span class="hljs-keyword">this</span>.gameObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最终效果：<img src="/2021/10/07/一个简易RPG游戏的搭建/result.gif" style="width: 36em;" alt="效果展示"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
            <tag> RPG游戏 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>河流渲染</title>
      <link href="/2021/08/16/%E5%8D%A1%E9%80%9A%E6%B2%B3%E6%B5%81%E6%B8%B2%E6%9F%93/"/>
      <url>/2021/08/16/%E5%8D%A1%E9%80%9A%E6%B2%B3%E6%B5%81%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用Unity版本为：2019.4.10f1。<br>最终效果：<img src="/2021/08/16/卡通河流渲染/result.gif" style="width: 36em;" alt="效果展示"><br><a id="more"></a></p></blockquote><h2 id="河流的组成"><a href="#河流的组成" class="headerlink" title="河流的组成"></a>河流的组成</h2><ul><li>凹陷的地表。<ul><li><img src="/2021/08/16/卡通河流渲染/ground.png" style="width: 36em;" alt="凹陷的地表"></li></ul></li><li>与地面水平的一个平面用于渲染水体。<ul><li>给平面赋予蓝色让其颜色接近水体。</li><li><img src="/2021/08/16/卡通河流渲染/waterquad.png" style="width: 36em;" alt="水体平面"></li></ul></li></ul><h2 id="河流深浅的表现"><a href="#河流深浅的表现" class="headerlink" title="河流深浅的表现"></a>河流深浅的表现</h2><h3 id="修改混合方式，让其具有透明度"><a href="#修改混合方式，让其具有透明度" class="headerlink" title="修改混合方式，让其具有透明度"></a>修改混合方式，让其具有透明度</h3><ul><li>注意，Tags要加上”Queue” = “Transparent”，让其在绘制半透明的批次上。<ul><li><img src="/2021/08/16/卡通河流渲染/usealphablend.png" style="width: 36em;" alt="修改混合方式"><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Tags &#123; "Queue" = "Transparent" &#125;<br>Pass &#123;<br>    Blend SrcAlpha OneMinusSrcAlpha<br><br>    CGPROGRAM<br>    ...<br>    ENDCG<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="根据水的深浅决定水体颜色"><a href="#根据水的深浅决定水体颜色" class="headerlink" title="根据水的深浅决定水体颜色"></a>根据水的深浅决定水体颜色</h3><ul><li><p>定义深浅的水体颜色，当水比较深的时候，用_WaterColorDeep，当水浅的时候，用_WaterColorShallow的颜色，过渡时用它们的插值。</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Properties<br>&#123;<br>    _WaterColorDeep("Water Color Deep", Color) = (0.086, 0.407, 1, 0.749)<br>    _WaterColorShallow("Water Color Shallow", Color) = (0.325, 0.807, 0.971, 0.725)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>关闭深入写入，根据水体表面与水底视线距离计算水体颜色。</p><ul><li><img src="/2021/08/16/卡通河流渲染/waterdepth.png" style="width: 36em;" alt="水面与地表的深度差"></li></ul></li><li>这里通过_CameraDepthTexture来获取深度值，由于透视摄像机下深度是非线性的，在计算深度差前，需要将深度转换为线性深度。</li><li>在渲染水面时，通过获取水面点的w分量即可获得其距离摄像机的线性深度，具体原理参考：<a href="http://www.songho.ca/opengl/gl_projectionmatrix.html" target="_blank" rel="noopener">http://www.songho.ca/opengl/gl_projectionmatrix.html</a></li><li><p><img src="/2021/08/16/卡通河流渲染/usedepth.png" style="width: 36em;" alt="根据水体表面与水底距离计算水体颜色"></p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Pass &#123;<br>    Blend SrcAlpha OneMinusSrcAlpha<br>    ZWrite Off<br><br>    CGPROGRAM<br>    <span class="hljs-meta">#pragma vertex vert</span><br>    <span class="hljs-meta">#pragma fragment frag</span><br><br>    <span class="hljs-meta">#include "UnityCG.cginc"</span><br><br>    <span class="hljs-type">sampler2D</span> _CameraDepthTexture;<br><br>    float4 _WaterColorDeep;<br>    float4 _WaterColorShallow;<br><br>    struct appdata &#123;<br>        float4 vertex: POSITION;<br>        float3 normal: NORMAL;<br>        float4 texcoord: TEXCOORD0;<br>    &#125;;<br><br>    struct v2f &#123;<br>        float4 pos: SV_POSITION;<br>        float4 screenPosition : TEXCOORD0;<br>    &#125;;<br><br>    v2f vert(appdata v) &#123;<br>        v2f f;<br>        f.pos = UnityObjectToClipPos(v.vertex);<br>        f.screenPosition = ComputeScreenPos(f.pos);<br><br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br><br>    float4 frag(v2f f) : SV_Target&#123;<br>        <span class="hljs-type">float</span> linearWaterDepthInView = tex2Dproj(_CameraDepthTexture, UNITY_PROJ_COORD(f.screenPosition)).r;<span class="hljs-comment">// 从摄像机角度看过去的水深。</span><br>        linearWaterDepthInView = LinearEyeDepth(linearWaterDepthInView); <span class="hljs-comment">// 将深度转换为线性深度。</span><br>        float4 waterColor = lerp(_WaterColorShallow, _WaterColorDeep, (linearWaterDepthInView - f.screenPosition.w) / <span class="hljs-number">3.0</span>);<br><br>        <span class="hljs-keyword">return</span> waterColor;<br>    &#125;<br>    ENDCG<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可以开启castshadows，让水体具有阴影，效果会更好些。</p></li><li><img src="/2021/08/16/卡通河流渲染/castshadows.png" style="width: 36em;" alt="Cast Shadows"></li><li><img src="/2021/08/16/卡通河流渲染/usecastshadows.png" style="width: 36em;" alt="使用Cast Shadows效果"></li></ul><h2 id="河流的流动效果"><a href="#河流的流动效果" class="headerlink" title="河流的流动效果"></a>河流的流动效果</h2><h3 id="使用噪声纹理让水面出现水纹"><a href="#使用噪声纹理让水面出现水纹" class="headerlink" title="使用噪声纹理让水面出现水纹"></a>使用噪声纹理让水面出现水纹</h3><ul><li><img src="/2021/08/16/卡通河流渲染/noise.png" style="width: 24em;" alt="Surface Noise"></li><li>通过_SurfaceNoiseCutoff来控制噪声纹理的显示范围，达到下图效果。</li><li><img src="/2021/08/16/卡通河流渲染/noisecutoff.gif" style="width: 36em;" alt="调整SurfaceNoiseCutoff效果"></li><li>最终将SurfaceNoiseCutoff定为0.8。</li><li><img src="/2021/08/16/卡通河流渲染/usenoise.png" style="width: 36em;" alt="使用噪声纹理制造水纹"></li><li>具体代码如下：<figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs glsl">Properties<br>&#123;<br>    _SurfaceNoise("Surface Noise", 2D) = "white" &#123;&#125;<br>    _SurfaceNoiseCutoff("Surface Noise Cutoff", Range(0, 1)) = 0.8<br>    _SurfaceNoiseColor("Surface Noise Color", Color) = (1.0, 1.0, 1.0, 1.0)<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs glsl">struct v2f &#123;<br>    float4 pos: SV_POSITION;<br>    float4 screenPosition : TEXCOORD0;<br>    float2 noiseUV: TEXCOORD1;<br>&#125;;<br><br>v2f vert(appdata v) &#123;<br>    ...<br>    f.noiseUV = TRANSFORM_TEX(v.texcoord, _SurfaceNoise);<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br><br>float4 Blend(float4 srcColor, float4 dstColor) &#123;<br>    float4 resultColor;<br>    resultColor.rgb = srcColor.a * srcColor.rgb + (<span class="hljs-number">1.0</span> - srcColor.a) * dstColor.rgb;<br>    resultColor.a = srcColor.a + dstColor.a * (<span class="hljs-number">1.0</span> - srcColor.a);<br>    <span class="hljs-keyword">return</span> resultColor;<br>&#125;<br><br>float4 frag(v2f f) : SV_Target&#123;<br>    ...<br>    float2 noiseUV = f.noiseUV;<br>    <span class="hljs-type">float</span> surfaceNoiseSample = tex2D(_SurfaceNoise, noiseUV).r;<br>    <span class="hljs-type">float</span> surfaceNoise = <span class="hljs-built_in">smoothstep</span>(_SurfaceNoiseCutoff - <span class="hljs-number">0.01</span>, _SurfaceNoiseCutoff + <span class="hljs-number">0.01</span>, surfaceNoiseSample);<br>    float4 surfaceNoiseColor = _SurfaceNoiseColor;<br>    surfaceNoiseColor.a *= surfaceNoise;<br><br>    <span class="hljs-keyword">return</span> Blend(surfaceNoiseColor, waterColor);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="让水纹动起来"><a href="#让水纹动起来" class="headerlink" title="让水纹动起来"></a>让水纹动起来</h3><ul><li>让噪声采样uv与时间关联起来，从而让水纹动起来。</li><li>添加扭曲纹理，让水纹不是一直线性移动，而是带有一点儿扭曲效果。<figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl">_SurfaceNoiseScroll("Surface Noise Scroll", Vector) = (0.03, 0.03, 0, 0)    // 水流流动方向。<br><br>_SurfaceDistortion("Surface Distortion", 2D) = "white" &#123;&#125;<br>_SurfaceDistortionAmount("Surface Distortion Amount", Range(0, 1)) = 0.233<br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl">float4 frag(v2f f) : SV_Target&#123;<br>    ...<br><br>    float2 distort = (tex2D(_SurfaceDistortion, f.distortUV).xy * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>) * _SurfaceDistortionAmount;<br>    float2 noiseUV = float2(f.noiseUV.x + _Time.y * _SurfaceNoiseScroll.x + distort.x, f.noiseUV.y + _Time.y * _SurfaceNoiseScroll.y + distort.y);<br>    <span class="hljs-type">float</span> surfaceNoiseSample = tex2D(_SurfaceNoise, noiseUV).r;<br>    <span class="hljs-type">float</span> surfaceNoise = <span class="hljs-built_in">smoothstep</span>(_SurfaceNoiseCutoff - <span class="hljs-number">0.01</span>, _SurfaceNoiseCutoff + <span class="hljs-number">0.01</span>, surfaceNoiseSample);<br>    float4 surfaceNoiseColor = _SurfaceNoiseColor;<br>    surfaceNoiseColor.a *= surfaceNoise;<br><br>    <span class="hljs-keyword">return</span> Blend(surfaceNoiseColor, waterColor);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><img src="/2021/08/16/卡通河流渲染/ani.gif" style="width: 36em;" alt="流动的水流"></li><li>在河流上放上小船看看效果：</li><li><img src="/2021/08/16/卡通河流渲染/result.gif" style="width: 36em;" alt="效果展示"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>塞尔达风格卡通渲染</title>
      <link href="/2021/08/08/%E5%A1%9E%E5%B0%94%E8%BE%BE%E9%A3%8E%E6%A0%BC%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93/"/>
      <url>/2021/08/08/%E5%A1%9E%E5%B0%94%E8%BE%BE%E9%A3%8E%E6%A0%BC%E5%8D%A1%E9%80%9A%E6%B8%B2%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用Unity版本为：2019.4.10f1。<br>最终效果：<img src="/2021/08/08/塞尔达风格卡通渲染/result.png" style="width: 36em;" alt="效果展示"><br><a id="more"></a></p></blockquote><h2 id="游戏效果分析"><a href="#游戏效果分析" class="headerlink" title="游戏效果分析"></a>游戏效果分析</h2><ul><li><img src="/2021/08/08/塞尔达风格卡通渲染/zelda_analyze.png" style="width: 36em;" alt="塞尔达游戏效果"></li><li>造型有明显的向光面（阳面）和背光面（阴面），它们分界明显。</li><li>造型阳面有高亮的边缘光。</li><li>头发高光处理分了层次分明的三档。</li></ul><h2 id="阴阳面效果实现"><a href="#阴阳面效果实现" class="headerlink" title="阴阳面效果实现"></a>阴阳面效果实现</h2><ul><li>阴阳面可以通过模型法线与光照夹角来计算，当法线与光夹角越小，说明越面向光源，反之则越背对光源。</li><li>法线与光的夹角可通过它们的向量点乘结果模拟，那么只需要规定点乘值小于某个阈值则显示阴影效果，反之则不显示，即达到阴阳面分界的效果。</li><li>这里我使用点乘结果作为纹理索引值在下面纹理中进行采样，来决定阴阳面分界的过度值，以方便控制阴阳面分界的过度。</li><li>阴面效果通过对颜色取平方值来让颜色变得暗淡些，这里也可采样其他方式。</li><li><img src="/2021/08/08/塞尔达风格卡通渲染/FO_RIM1.png" style="width: 12em;" alt="_FalloffSampler"></li><li>效果：<img src="/2021/08/08/塞尔达风格卡通渲染/cloth_light.png" style="width: 36em;" alt="阴阳面效果"></li><li>代码实现：<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl">float4 diffSamplerColor = tex2D(_MainTex, f.uv.xy);<br>float3 normalVec = GetNormalFromMap(f);<br><br><span class="hljs-type">float</span> normalDotLight = <span class="hljs-built_in">dot</span>(normalVec, f.lightDir);<br><span class="hljs-type">float</span> falloffU = <span class="hljs-built_in">clamp</span>(<span class="hljs-number">1.0</span> - normalDotLight, <span class="hljs-number">0.02</span>, <span class="hljs-number">0.98</span>);<br>falloffU = tex2D(_FalloffSampler, float2(falloffU, <span class="hljs-number">0.25</span>)).r;<br>float3 combinedColor = lerp(diffSamplerColor.rgb, diffSamplerColor.rgb * diffSamplerColor.rgb, falloffU);<br></code></pre></td></tr></table></figure></li></ul><h2 id="边缘光实现"><a href="#边缘光实现" class="headerlink" title="边缘光实现"></a>边缘光实现</h2><ul><li>边缘光可以通过模型法线与视线夹角来计算，当法线与视线夹角越接近90度，说明越接近边缘，即法线与视线的夹角点乘值越接近0，则表示越接近边缘。</li><li>这样处理下来，阴阳面都会有边缘光，所以在边缘的判定上，我再乘以了阴阳面的判定系数（阳面为1.0， 阴面为0.0），从而让只有阳面边缘被判定为边缘。</li><li>最终在边缘上加上加一层自身的颜色值达到高亮效果。</li><li>边缘边界的判定也是用阴阳面边界的判定方式，通过纹理来控制。</li><li>效果：<img src="/2021/08/08/塞尔达风格卡通渲染/cloth_rim.png" style="width: 36em;" alt="边缘光效果"></li><li><img src="/2021/08/08/塞尔达风格卡通渲染/cloth_rim_anim.gif" style="width: 14em;" alt="边缘光效果"></li><li><p>代码实现：</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> rimlightDot = <span class="hljs-built_in">dot</span>(normalVec, f.eyeDir);<br>falloffU = (<span class="hljs-number">1.0</span> - rimlightDot) * (<span class="hljs-number">1.0</span> - falloffU);<br>falloffU = tex2D(_RimLightSampler, float2(falloffU, <span class="hljs-number">0.25</span>f)).r;<br>float3 lightColor = diffSamplerColor.rgb;<br>combinedColor += falloffU * lightColor;<br></code></pre></td></tr></table></figure></li><li><p>为了让边缘离光越近，边缘光越强，这里改为通过乘以 法线与光的点乘结果，让其有离光越近边缘光越强，通过pow来调整强度。</p></li><li>为了参数调整方便，改用smoothstep来设定边缘光粗细。</li><li>效果对比：</li><li><img src="/2021/08/08/塞尔达风格卡通渲染/rim_a.png" style="width: 12em;" alt="边缘光效果A"></li><li><img src="/2021/08/08/塞尔达风格卡通渲染/rim_b.png" style="width: 12em;" alt="边缘光效果B"><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> rimlightDot = <span class="hljs-number">1.0</span> - <span class="hljs-built_in">dot</span>(normalVec, f.eyeDir);<br><span class="hljs-type">float</span> rimIntensity = <span class="hljs-built_in">smoothstep</span>(<span class="hljs-number">0.66</span>, <span class="hljs-number">0.78</span>, rimlightDot * <span class="hljs-built_in">pow</span>(normalDotLight, <span class="hljs-number">0.2</span>)) * (<span class="hljs-number">1.0</span> - falloffU);<br>float3 lightColor = diffSamplerColor.rgb;<br>combinedColor += rimIntensity * lightColor;<br></code></pre></td></tr></table></figure></li></ul><h2 id="层次分明的高光"><a href="#层次分明的高光" class="headerlink" title="层次分明的高光"></a>层次分明的高光</h2><ul><li>有层次分明的高光，可以将其拆分成多个高光系数不同的高光叠加的效果。</li><li>这里我用了两次高光的效果叠加在一起，配合上面的阴阳面效果，头发颜色会根据离光远近分成四块。</li><li>最后，为了让效果偏卡通，这里用smoothstep来对高光效果做了明显的分界。</li><li>效果：<img src="/2021/08/08/塞尔达风格卡通渲染/hair_specular.gif" style="width: 14em;" alt="头发高光"><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs glsl">float3 halfVector = <span class="hljs-built_in">normalize</span>(f.lightDir + f.eyeDir);<br><span class="hljs-type">float</span> NdotH = <span class="hljs-built_in">dot</span>(normalVec, halfVector);<br><span class="hljs-type">float</span> specularIntensity = <span class="hljs-built_in">pow</span>(NdotH * (<span class="hljs-number">1.0</span> - falloffU), <span class="hljs-number">512</span>);<br>float3 specularColor = diffSamplerColor * <span class="hljs-number">0.4</span>;<br>specularIntensity = <span class="hljs-built_in">smoothstep</span>(<span class="hljs-number">0.005</span>, <span class="hljs-number">0.01</span>, specularIntensity);<br>combinedColor += specularIntensity * specularColor;<br><br>specularIntensity = <span class="hljs-built_in">pow</span>(NdotH * (<span class="hljs-number">1.0</span> - falloffU), <span class="hljs-number">32</span>);<br>specularIntensity = <span class="hljs-built_in">smoothstep</span>(<span class="hljs-number">0.005</span>, <span class="hljs-number">0.01</span>, specularIntensity);<br>combinedColor += specularIntensity * specularColor * <span class="hljs-number">0.4</span>;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>UnityChan渲染分析</title>
      <link href="/2021/08/01/UnityChan%E6%B8%B2%E6%9F%93%E5%88%86%E6%9E%90/"/>
      <url>/2021/08/01/UnityChan%E6%B8%B2%E6%9F%93%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用Unity版本为：2019.4.10f1。<br>-<br>使用素材地址：<br><a href="https://github.com/unity3d-jp/UnityChanToonShaderVer2_Project" target="_blank" rel="noopener">https://github.com/unity3d-jp/UnityChanToonShaderVer2_Project</a><br>Unity商店unity-chan!<br>-<br>shader代码源地址：于Unity商店中搜索unity-chan!导入，目录为:unity-chan!/Unity-chan! Model/Art/UnityChanShader/Shader/Unitychan_chara_fuku.shader<br>-<br>最终效果：<img src="/2021/08/01/UnityChan渲染分析/最终结果.png" style="width: 12em;" alt="效果展示"></p><p><img src="/2021/08/01/UnityChan渲染分析/unity-chan.png" style="width: 24em;" alt="unity-chan"><br><a id="more"></a></p></blockquote><h2 id="UnityChan渲染分析"><a href="#UnityChan渲染分析" class="headerlink" title="UnityChan渲染分析"></a>UnityChan渲染分析</h2><p>Author: MoriMiya</p><h3 id="Unitychan-chara-fuku模块"><a href="#Unitychan-chara-fuku模块" class="headerlink" title="Unitychan_chara_fuku模块"></a>Unitychan_chara_fuku模块</h3><ol><li><p>Properties中有以下类型变量，可以看出该shader渲染将会包含：</p><ol><li>普通纹理漫反射颜色，配合递减贴图将会对颜色做一定的亮度梯度区分。</li><li>有边缘光贴图，表示模型边缘将会有高光。</li><li>有描边宽度设置，表示模型会有描边。</li><li>其他剩余的变量都是常规的光照会使用到的数据，值得注意的是环境贴图是一张2D贴图，而不是MapCube。<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">Properties<br>&#123;<br>    _Color (<span class="hljs-string">"Main Color"</span>, Color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    _ShadowColor (<span class="hljs-string">"Shadow Color"</span>, Color) = (<span class="hljs-number">0.8</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 阴影颜色。</span><br>    _SpecularPower (<span class="hljs-string">"Specular Power"</span>, Float) = <span class="hljs-number">20</span>           <span class="hljs-comment">// 高光乘方次数。</span><br>    _EdgeThickness (<span class="hljs-string">"Outline Thickness"</span>, Float) = <span class="hljs-number">1</span>         <span class="hljs-comment">// 描边宽度。</span><br><br>    _MainTex (<span class="hljs-string">"Diffuse"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span> &#123;&#125;                   <span class="hljs-comment">// 主纹理。</span><br>    _FalloffSampler (<span class="hljs-string">"Falloff Control"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span> &#123;&#125;    <span class="hljs-comment">// 递减贴图。</span><br>    _RimLightSampler (<span class="hljs-string">"RimLight Control"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span> &#123;&#125;  <span class="hljs-comment">// 边缘光贴图。</span><br>    _SpecularReflectionSampler (<span class="hljs-string">"Specular / Reflection Mask"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">"white"</span> &#123;&#125;  <span class="hljs-comment">// 高光贴图。</span><br>    _EnvMapSampler (<span class="hljs-string">"Environment Map"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">""</span> &#123;&#125;          <span class="hljs-comment">// 环境贴图。</span><br>    _NormalMapSampler (<span class="hljs-string">"Normal Map"</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">""</span> &#123;&#125;            <span class="hljs-comment">// 法线贴图。</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>接下来看它的Pass里做了什么：</p><ol><li>第一个Pass：<ul><li>引入了常规CG内置模块和AutoLight内置模块。</li><li>还加入了CharaMain.cg模块。</li></ul></li><li>第二个Pass：<ul><li>深度剔除方式是正面剔除。</li><li>引入了常规UnityCG模块。</li><li>引入了CharaOutline.cg模块。</li></ul></li><li>第二个Pass不涉及光照计算，比较简单，先从该Pass进行分析。<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++">Pass<br>&#123;<br>    Cull Back<br>    ZTest LEqual<br>CGPROGRAM<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> multi_compile_fwdbase</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> target 3.0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> fragment frag</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"UnityCG.cginc"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"AutoLight.cginc"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ENABLE_NORMAL_MAP</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"CharaMain.cg"</span></span><br>ENDCG<br>&#125;<br><br>Pass<br>&#123;<br>    Cull Front<br>    ZTest Less<br>CGPROGRAM<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> target 3.0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> vertex vert</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> fragment frag</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"UnityCG.cginc"</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"CharaOutline.cg"</span></span><br>ENDCG<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="描边-Charaoutline-cg"><a href="#描边-Charaoutline-cg" class="headerlink" title="描边(Charaoutline.cg)"></a>描边(Charaoutline.cg)</h3><ul><li>第二个Pass中Charaoutline.cg做的事情便是给模型进行描边。</li><li><p>vertex代码：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Vertex shader</span><br><span class="hljs-function">v2f <span class="hljs-title">vert</span><span class="hljs-params">( appdata_base v )</span><br></span>&#123;<br>v2f o;<br>o.uv = TRANSFORM_TEX( v.texcoord.xy, _MainTex );<br><br>half4 projSpacePos = UnityObjectToClipPos( v.vertex );<br>half4 projSpaceNormal = normalize( UnityObjectToClipPos( half4( v.normal, <span class="hljs-number">0</span> ) ) );<br>half4 scaledNormal = _EdgeThickness * INV_EDGE_THICKNESS_DIVISOR * projSpaceNormal; <span class="hljs-comment">// * projSpacePos.w;</span><br><br>scaledNormal.z += <span class="hljs-number">0.00001</span>;<br>o.pos = projSpacePos + scaledNormal;<br><br><span class="hljs-keyword">return</span> o;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>代码中做的事情是先计算出法线在透视矩阵空间下的方向，让模型坐标沿法线方向进行偏移。</p></li><li><p>这里的法线偏移值最终z值加了0.00001的值，是为了避免如眉毛等会被其他网格遮挡住的边缘的网格能够正常进行描边。</p></li><li><p>fragment代码：</p><figure class="hljs highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">// Fragment shader<br>float4 frag( v2f i ) : COLOR<br>&#123;<br>float4_t diffuseMapColor = tex2D( _MainTex, i.uv );<br><br>float_t maxChan = max( max( diffuseMapColor.r, diffuseMapColor.g ), diffuseMapColor.b );<br>float4_t newMapColor = diffuseMapColor;<br><br>maxChan -= ( 1.0 / 255.0 );<br>float3_t lerpVals = saturate( ( newMapColor.rgb - float3( maxChan, maxChan, maxChan ) ) * 255.0 );<br>newMapColor.rgb = lerp( SATURATION_FACTOR * newMapColor.rgb, newMapColor.rgb, lerpVals );<br><br>return float4( BRIGHTNESS_FACTOR * newMapColor.rgb * diffuseMapColor.rgb, diffuseMapColor.a ) * _Color * _LightColor0;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这里通过将纹理颜色与其最大通道值作差，选出哪些颜色通道是具有代表性的通道，通过saturate函数和lerp函数的配合，对于有代表性的通道，则让其显示纹理原来该通道的值，对于代表性不强的通道，则让其通道颜色乘SATURATION_FACTOR，让其值变得更小更加不突出，这些值存于newMapColor中。</p></li><li>最后将newMapColor于漫反射颜色相乘，在乘以亮度系数BRIGHTNESS_FACTOR，最后乘以_Color和光照颜色，得出描边颜色。</li><li><img src="/2021/08/01/UnityChan渲染分析/仅漫反射贴图.png" style="width: 12em;" alt="效果展示"> <img src="/2021/08/01/UnityChan渲染分析/漫反射贴图+描边.png" style="width: 12em;" alt="描边效果"></li></ul><h3 id="光照处理-CharaMain-cg"><a href="#光照处理-CharaMain-cg" class="headerlink" title="光照处理(CharaMain.cg)"></a>光照处理(CharaMain.cg)</h3><ul><li><p>vertex代码：</p><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">v2f <span class="hljs-title">vert</span><span class="hljs-params">(appdata v)</span> </span>&#123;<br>v2f f;<br>f.pos = UnityObjectToClipPos(v.vertex);<br>f.uv.xy = v.texcoord.xy * _MainTex_ST.xy + _MainTex_ST.zw;<br><br>half4 worldPos = mul( unity_ObjectToWorld, v.vertex );<br>f.eyeDir.xyz = normalize( _WorldSpaceCameraPos.xyz - worldPos.xyz ).xyz;<br>f.lightDir = WorldSpaceLightDir( v.vertex );<br><br>f.normal = normalize(UnityObjectToWorldDir(v.normal));<br>f.tangent = normalize(UnityObjectToWorldDir(v.tangent));<br>f.binormal = normalize(cross(f.normal, f.tangent));<br><br>    <span class="hljs-comment">// COMPUTE_LIGHT_COORDS(f) TRANSFER_SHADOW(f)</span><br>TRANSFER_VERTEX_TO_FRAGMENT(f);<span class="hljs-comment">// 计算世界空间顶点到光的方向，光源空间的顶点坐标。</span><br><span class="hljs-keyword">return</span> f;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>顶点着色计算了在世界坐标空间下的视线eyeDir方向，光照方向lightDir，以及TBN向量，方便后续进行切线计算。</p></li><li><p>TRANSFER_VERTEX_TO_FRAGMENT的实质是COMPUTE_LIGHT_COORDS(f) TRANSFER_SHADOW(f)，即计算世界空间顶点到光的方向，光源空间的顶点坐标（不屏幕空间的阴影方法下成立），具体看AutoLight.cginc实现。</p></li><li><p>fragment代码：</p></li><li>片段着色器代码内容较多，下面详细分块讲解。</li><li>这里所有的计算都基于世界空间坐标系计算，除了影子的计算得看情况。</li></ul><h4 id="漫反射颜色和法向量"><a href="#漫反射颜色和法向量" class="headerlink" title="漫反射颜色和法向量"></a>漫反射颜色和法向量</h4><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">inline</span> fixed3 <span class="hljs-title">GetNormalFromMap</span><span class="hljs-params">(v2f input)</span> </span>&#123;<br>fixed3 normalVec = normalize( tex2D( _NormalMapSampler, input.uv ).xyz * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span> );<br>fixed3x3 localToWorldTranspose = fixed3x3(<br>input.tangent,<br>input.binormal,<br>input.normal<br>);<br><br>normalVec = normalize( mul( normalVec, localToWorldTranspose ) );<br><span class="hljs-keyword">return</span> normalVec;<br>&#125;<br>float4 diffSamplerColor = tex2D(_MainTex, f.uv.xy);<br>float3 normalVec = GetNormalFromMap(f);<br></code></pre></td></tr></table></figure><ul><li>中规中矩得代码，采样贴图获得漫反射颜色，通过TBN矩阵将法线从切线空间转换至世界空间。</li></ul><h4 id="Falloff衰减色"><a href="#Falloff衰减色" class="headerlink" title="Falloff衰减色"></a>Falloff衰减色</h4><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 衰减色（Falloff），根据法线与视线的夹角的cos值作为漫反射的衰减值；利用lookup贴图来将衰减值作明显的区间分段。</span><br><span class="hljs-keyword">float</span> normalDotEye = dot(normalVec, f.eyeDir.xyz);<br><span class="hljs-keyword">float</span> falloffU = clamp(<span class="hljs-number">1.0</span> - <span class="hljs-built_in">abs</span>(normalDotEye), <span class="hljs-number">0.02</span>, <span class="hljs-number">0.98</span>);<br>float4 falloffSamplerColor = FALLOFF_POWER * tex2D(_FalloffSampler, float2(falloffU, <span class="hljs-number">0.25</span>));<span class="hljs-comment">// 将线性连续值得通过lookup贴图变成分段区间较为离散的值。</span><br>float3 shadowColor = diffSamplerColor.rgb * diffSamplerColor.rgb;<span class="hljs-comment">// 暗色。</span><br>float3 combinedColor = lerp(diffSamplerColor.rgb, shadowColor, falloffSamplerColor.r);<br>combinedColor *= (<span class="hljs-number">1.0</span> + falloffSamplerColor.rgb * falloffSamplerColor.a);<span class="hljs-comment">// 这里再混上边缘变白的颜色。</span><br></code></pre></td></tr></table></figure><ul><li>首先用1.0 - 法线与视线的夹角的cos值 得到一个falloffU得值，该值得特点是法线与视线同方向则为0，垂直则为1.0，即该值会越接近模型边缘越趋向于1.0。</li><li>使用falloffU在一张lookup贴图中进行采样来获得分段区间较为离散的值falloffSamplerColor。<img src="/2021/08/01/UnityChan渲染分析/FO_CLOTH1.png" style="width: 6em;" alt="FalloffSampler"></li><li>通过falloffSamplerColor来确定颜色在暗色（原色的二次方）和原色间的过度值，从而计算出目标色combinedColor。</li><li>最后目标色再加上了falloffSamplerColor，让边缘会偏向白（亮）一些。</li><li>单纯的falloffColor：<img src="/2021/08/01/UnityChan渲染分析/falloffColor.png" style="width: 12em;" alt="falloffColor"></li><li>边缘白色：<img src="/2021/08/01/UnityChan渲染分析/边缘白色.png" style="width: 12em;" alt="边缘白色"></li><li>falloffColor+边缘白边：<img src="/2021/08/01/UnityChan渲染分析/falloffColor+边缘白边.png" style="width: 12em;" alt="falloffColor+边缘白边"></li></ul><h4 id="Sepcular高光"><a href="#Sepcular高光" class="headerlink" title="Sepcular高光"></a>Sepcular高光</h4><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Sepcular高光。</span><br><span class="hljs-comment">// 这里把视线eyeDir向量当作光照方向来计算Specular高光。</span><br>float4 reflectionMaskColor = tex2D(_SpecularReflectionSampler, f.uv.xy);<br><span class="hljs-keyword">float</span> specularDot = dot(normalVec, f.eyeDir.xyz);<br><span class="hljs-comment">// lit(NdotL, NdotH, m) N表示法向量；L表示入射光向量；H表示半角向量；m表示高光系数。</span><br><span class="hljs-comment">// Returns a lighting vector (ambient, diffuse, specular, 1)</span><br>float4 lighting = lit( normalDotEye, specularDot, _SpecularPower );<br><span class="hljs-comment">// saturate: Clamps x to the range [0, 1]</span><br>float3 specularColor = saturate(lighting.z) * reflectionMaskColor.rgb * diffSamplerColor.rgb;<br>combinedColor += specularColor;<br></code></pre></td></tr></table></figure><ul><li>这里把视线eyeDir向量当作光照方向来计算光照。</li><li>乘以高光反射贴图的颜色，让高光的颜色更加准确，我这里没有好的高光反射贴图，使用了一张漫反射贴图来替代。</li><li>高光颜色：<img src="/2021/08/01/UnityChan渲染分析/specular颜色.png" style="width: 12em;" alt="specular颜色"></li><li>加上高光颜色效果：<img src="/2021/08/01/UnityChan渲染分析/加上specular颜色.png" style="width: 12em;" alt="加上specular颜色"></li></ul><h4 id="Reflection环境反射"><a href="#Reflection环境反射" class="headerlink" title="Reflection环境反射"></a>Reflection环境反射</h4><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Reflection</span><br><span class="hljs-function"><span class="hljs-keyword">inline</span> float3 <span class="hljs-title">GetOverlayColor</span><span class="hljs-params">( float3 inUpper, float3 inLower )</span> </span>&#123;<br>float3 oneMinusLower = float3( <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ) - inLower;<br>float3 valUnit = <span class="hljs-number">2.0</span> * oneMinusLower;<br>float3 minValue = <span class="hljs-number">2.0</span> * inLower - float3( <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> );<span class="hljs-comment">// 需要保证：minValue + valUnit = float3(1.0)，因为这样即表示为minValue变纯白的过程。</span><br>float3 greaterResult = inUpper * valUnit + minValue;<span class="hljs-comment">// 通过inUpper来决定每个通道的增长valUnit值，结果会偏向于float3(1.0)。</span><br>float3 lowerResult = <span class="hljs-number">2.0</span> * inLower * inUpper;<span class="hljs-comment">// 这里没能看出套路，猜测是一个经验值，根据inUpper*inLower来决定最低值，*2为了让它不太暗。</span><br><br>half3 lerpVals = round(inLower);<span class="hljs-comment">// 类四舍五入取整，让lerp结果分割明显。</span><br><span class="hljs-keyword">return</span> lerp(lowerResult, greaterResult, lerpVals);<br>&#125;<br><br>float3 reflectVector = reflect( -f.eyeDir.xyz, normalVec ).xzy;<span class="hljs-comment">// 把yz互换，边缘会更光亮点。</span><br>float2 sphereMapCoords = <span class="hljs-number">0.5</span> * ( float2( <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> ) + reflectVector.xy );<span class="hljs-comment">// 将坐标从[-1, 1] 映射到[0, 1]。</span><br>float3 reflectColor = tex2D( _EnvMapSampler, sphereMapCoords ).rgb;<br>reflectColor = GetOverlayColor( reflectColor, combinedColor );<br><br>combinedColor = lerp( combinedColor, reflectColor, reflectionMaskColor.a );<br>combinedColor *= _Color.rgb * _LightColor0.rgb;<br><span class="hljs-keyword">float</span> opacity = diffSamplerColor.a * _Color.a * _LightColor0.a;<br></code></pre></td></tr></table></figure><ul><li>这里在计算反射光向量的时候，把yz互换了，这样做回是的边缘更光亮些，对比效果如下。</li><li>reflect_xyz：<img src="/2021/08/01/UnityChan渲染分析/reflect_xyz.png" style="width: 12em;" alt="reflect_xyz"></li><li>reflect_xzy：<img src="/2021/08/01/UnityChan渲染分析/reflect_xzy.png" style="width: 12em;" alt="reflect_xzy"></li><li>然后这里从环境贴图采样只用到了xy值，不使用z值，采样器也不是Cube，这里与传统做法相比较省显存，算是一种取巧的方式。</li><li>在计算反射颜色的时候也做了一些有趣的处理，其相当于在求下面两图的一个混合效果，混合的方式则为根据至今计算的combinedColor每个通道的颜色值，如果&gt;0.5，则该通道用高亮色，否则使用暗色。</li><li>高亮色greaterResult和暗色lowerResult的定义都是一些取巧方式或经验值，具体可查看代码及我标注的注释。</li><li>lowerResult：<img src="/2021/08/01/UnityChan渲染分析/lowerResult.png" style="width: 12em;" alt="lowerResult"></li><li>greaterResult：<img src="/2021/08/01/UnityChan渲染分析/greaterResult.png" style="width: 12em;" alt="greaterResult"></li><li>由于我是用一张漫反射贴图替代高光反射贴图，reflectionMaskColor.a的值必然为1.0，会让结果显示为greaterResult，因此我实际代码中改为写0.5来获得一个还能看的效果。</li><li>效果图：<img src="/2021/08/01/UnityChan渲染分析/加上reflection.png" style="width: 12em;" alt="加上reflection"></li></ul><h4 id="Cast-Shadow"><a href="#Cast-Shadow" class="headerlink" title="Cast Shadow"></a>Cast Shadow</h4><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Cast shadows 这里目前没使用到。</span><br>shadowColor = _ShadowColor.rgb * combinedColor;<br><span class="hljs-keyword">float</span> attenuation = saturate( <span class="hljs-number">2.0</span> * LIGHT_ATTENUATION( f ) - <span class="hljs-number">1.0</span> );<br>combinedColor = lerp( shadowColor, combinedColor, attenuation );<br></code></pre></td></tr></table></figure><h4 id="Rimlight-边缘高光"><a href="#Rimlight-边缘高光" class="headerlink" title="Rimlight 边缘高光"></a>Rimlight 边缘高光</h4><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Rimlight 边缘高光。</span><br><span class="hljs-keyword">float</span> rimlightDot = saturate( <span class="hljs-number">0.5</span> * ( dot( normalVec, f.lightDir ) + <span class="hljs-number">1.0</span> ) );<br><span class="hljs-comment">// float falloffU = clamp(1.0 - abs(normalDotEye), 0.02, 0.98);</span><br>falloffU = saturate( rimlightDot * falloffU );<span class="hljs-comment">// (1.0-视线与法线的夹角)得出越是边缘值越大，*rimlightDot即与该处实际光照强度相乘，让暗处边缘光不会太亮。</span><br>falloffU = tex2D( _RimLightSampler, float2( falloffU, <span class="hljs-number">0.25f</span> ) ).r;<br>float3 lightColor = diffSamplerColor.rgb; <span class="hljs-comment">// * 2.0;</span><br>combinedColor += falloffU * lightColor;<br></code></pre></td></tr></table></figure><ul><li>(1.0-视线与法线的夹角)得出越是边缘值越大，*rimlightDot即与该处实际光照强度相乘，让暗处边缘光不会太亮。</li><li>边缘高光仅用falloffU：<img src="/2021/08/01/UnityChan渲染分析/边缘高光_仅用falloffU.png" style="width: 12em;" alt="边缘高光_仅用falloffU"></li><li>边缘高光falloffUXrimlightDot：<img src="/2021/08/01/UnityChan渲染分析/边缘高光_falloffUXrimlightDot.png" style="width: 12em;" alt="边缘高光_falloffUXrimlightDot"></li><li>也是在一张lookup贴图中获取离散的值得，让falloffU有较明显的分层。</li><li>最后加上边缘光颜色，获得下图效果。</li><li>最终结果：<img src="/2021/08/01/UnityChan渲染分析/最终结果.png" style="width: 12em;" alt="最终结果"></li><li><img src="/2021/08/01/UnityChan渲染分析/unity-chan.png" style="width: 24em;" alt="unity-chan"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> Unity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> 游戏开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CocosCreator-合成大西瓜</title>
      <link href="/2021/02/17/CocosCreator-%E5%90%88%E6%88%90%E5%A4%A7%E8%A5%BF%E7%93%9C/"/>
      <url>/2021/02/17/CocosCreator-%E5%90%88%E6%88%90%E5%A4%A7%E8%A5%BF%E7%93%9C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用CocosCreator 3.0制作《合成大西瓜》。<br><img src="/2021/02/17/CocosCreator-合成大西瓜/result.png" style="width: 12em;" alt="效果展示"><br><a id="more"></a></p></blockquote><h2 id="使用CocosCreator-3-0制作《合成大西瓜》"><a href="#使用CocosCreator-3-0制作《合成大西瓜》" class="headerlink" title="使用CocosCreator 3.0制作《合成大西瓜》"></a>使用CocosCreator 3.0制作《合成大西瓜》</h2><p>Author: MoriMiya</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><ol><li>一个不让水果跑到界面外的场景。</li><li>场景能显示分数。</li><li>场景具有警戒线，有水果超过警戒线则表示游戏失败。</li></ol><h4 id="水果"><a href="#水果" class="headerlink" title="水果"></a>水果</h4><ol><li>支持水果按类型在指定位置生成，以方便生成下一个水果及合成的水果。</li><li>水果间不可重叠，需要使用2D物理。</li><li>水果合成需要有合成特效及分数加成。</li></ol><h3 id="资源准备"><a href="#资源准备" class="headerlink" title="资源准备"></a>资源准备</h3><ol><li>在资源管理器中创建Images文件夹，将游戏所需要用到的贴图素材放进去，再将贴图素材Type改为sprite-frame。</li><li><img src="/2021/02/17/CocosCreator-合成大西瓜/res.png" style="width: 22em;" alt="资源"></li></ol><h3 id="场景设置"><a href="#场景设置" class="headerlink" title="场景设置"></a>场景设置</h3><ol><li>在项目设置中配置设计宽度和设计高度，设置为640X960，勾选适配屏幕宽度。<ul><li><img src="/2021/02/17/CocosCreator-合成大西瓜/项目设置.png" style="width: 42em;" alt="项目设置"></li></ul></li><li>在资源管理器中创建Scenes文件夹，在下面创建一个Main场景，作为游戏主场景。</li><li>双击进入Main场景，删除自带的Main Camera和Main Light。</li><li>创建一个名为BG的单色Sprite，作为游戏背景。</li><li>在背景BG左边、右边、下边创建单色Sprite，在其中加入RigidBody2D和BoxCollider2D，RigidBody2D的Type设置为Static，以避免其受重力影响而下坠。<ul><li><img src="/2021/02/17/CocosCreator-合成大西瓜/layermanager.png" alt="layermanager"></li><li><img src="/2021/02/17/CocosCreator-合成大西瓜/wallleft_rigidbody2d.png" alt="rigidbody2d"></li><li><img src="/2021/02/17/CocosCreator-合成大西瓜/wallleft_boxcollider2d.png" alt="boxcollider2d"></li></ul></li><li>在左上角及上方添加分数Score和WarnLine的Label。</li><li>在资源管理器中创建Scripts文件夹，创建GameManager.ts脚本。</li><li>给Canvas添加GameManager脚本组件，将Score和WarnLine两个Label作为脚本的property。<ul><li><img src="/2021/02/17/CocosCreator-合成大西瓜/gamemanager.png" alt="gamemanager"></li></ul></li><li>至此，场景便完成布置了。<ul><li><img src="/2021/02/17/CocosCreator-合成大西瓜/背景.png" alt="背景"></li></ul></li></ol><h3 id="水果生成"><a href="#水果生成" class="headerlink" title="水果生成"></a>水果生成</h3><ol><li><p>创建一个名为fruit的Sprite，将SpriteFrame替换为fruit_1。</p></li><li><p>添加RigidBody2D和CircleCollider2D。</p><ul><li><p><img src="/2021/02/17/CocosCreator-合成大西瓜/fruit_rigidbody2d.png" alt="fruit_rigidbody2d"></p></li><li><p><img src="/2021/02/17/CocosCreator-合成大西瓜/fruit_circlecollider2d.png" alt="fruit_circlecollider2d"></p></li></ul></li><li><p>在Script文件夹里面创建Fruit.ts脚本。将该脚本设置为水果的脚本组件。</p></li><li><p>创建Prefabs文件夹，将fruit拖到Prefabs文件夹中，让fruit成为预制体并将该预制体设置为GameManager.ts的property，方便后续程序动态生成水果。</p></li><li><p>给GameManager创建一个带有水果编号ID和水果SpriteFrame的数组property，在编辑器中逐个编辑好内容。</p></li></ol><h3 id="水果合成特效"><a href="#水果合成特效" class="headerlink" title="水果合成特效"></a>水果合成特效</h3><ol><li>创建一个名为juice的Sprite，将SpriteFrame替换为juice_l_1。</li><li>给该sprite添加两个ParticleSystem2D子节点，分别命名为sarcocarp和dewdrop，分别作为果粒和水珠的爆炸特效。<ul><li><img src="/2021/02/17/CocosCreator-合成大西瓜/juice.png" alt="juice"></li></ul></li><li>调好sarcocarp和dewdrop的粒子参数，调到自己满意即可。<ul><li><img src="/2021/02/17/CocosCreator-合成大西瓜/juice_sarcocarp_particle.png" alt="juice_sarcocarp_particle"></li></ul></li><li>将juice拖到Prefabs文件夹中，让juice成为预制体并将该预制体设置为GameManager.ts的property，方便后续程序动态生成水果合成特效。</li><li>给GameManager创建一个带有水果果粒、水珠、水花SpriteFrame的数组property，在编辑器中逐个编辑好内容。</li><li>给GameManager.ts添加两个AudioClip，放进合成使用的音效，给Canvas添加AudioSource，用于后续脚本播放音效使用。</li></ol><h3 id="游戏逻辑"><a href="#游戏逻辑" class="headerlink" title="游戏逻辑"></a>游戏逻辑</h3><ol><li>至此，游戏准备工作都完成了，剩下的便是游戏脚本逻辑，这里直接上最终代码。<figure class="hljs highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// fruit.ts</span><br><span class="hljs-keyword">import</span> &#123; _decorator, Component, Node, Sprite, Collider2D, Contact2DType &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'cc'</span>;<br><span class="hljs-keyword">import</span> &#123;FruitItem&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./GameManager"</span><br><span class="hljs-keyword">const</span> &#123; ccclass, property &#125; = _decorator;<br><br><span class="hljs-meta">@ccclass</span>(<span class="hljs-string">'Fruit'</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> Fruit <span class="hljs-keyword">extends</span> Component &#123;<br><br>    <span class="hljs-keyword">private</span> id: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br><br>    init (data: FruitItem) &#123;<br>        <span class="hljs-keyword">this</span>.id = data.id;<br>        <span class="hljs-keyword">let</span> sprite = <span class="hljs-keyword">this</span>.node.getComponent(Sprite);<br>        <span class="hljs-keyword">if</span> (sprite) &#123;<br>            sprite.spriteFrame = data.img;<br>        &#125;<br>    &#125;<br><br>    getID() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.id;<br>    &#125;<br><br>    onBeginContact (selfCollider: Collider2D, otherCollider: Collider2D, contact: <span class="hljs-built_in">any</span>) &#123;<br>        <span class="hljs-comment">// 只在两个碰撞体开始接触时被调用一次</span><br>        <span class="hljs-keyword">if</span> (selfCollider.node &amp;&amp; otherCollider.node) &#123;<br>            <span class="hljs-keyword">const</span> s = selfCollider.node.getComponent(Fruit);<br>            <span class="hljs-keyword">const</span> o = otherCollider.node.getComponent(Fruit);<br>            <span class="hljs-keyword">if</span> (s &amp;&amp; o) &#123;<br>                <span class="hljs-keyword">if</span> (s.id === o.id) &#123;<br>                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"emit sameContact"</span>);<br>                    selfCollider.node.emit(<span class="hljs-string">'sameContact'</span>, selfCollider, otherCollider);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    start () &#123;<br>        <span class="hljs-keyword">let</span> collider = <span class="hljs-keyword">this</span>.getComponent(Collider2D);<br>        <span class="hljs-keyword">if</span> (collider) &#123;<br>            collider.on(Contact2DType.BEGIN_CONTACT, <span class="hljs-keyword">this</span>.onBeginContact, <span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><figure class="hljs highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// GameManager.ts</span><br><span class="hljs-keyword">import</span> &#123; _decorator, Component, Node, CCClass, SpriteFrame, CCInteger, instantiate, Prefab, CircleCollider2D, Vec3, log, EventTouch, Vec2, director, PhysicsSystem2D, EPhysics2DDrawFlags, PHYSICS_2D_PTM_RATIO, UITransform, utils, tween, RigidBody2D, ERigidBody2DType, Collider2D, Sprite, math, ParticleSystem2D, AudioClip, AudioSource, Label, spriteAssembler &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'cc'</span>;<br><span class="hljs-keyword">import</span> &#123; Fruit &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./Fruit"</span><br><span class="hljs-keyword">const</span> &#123; ccclass, property &#125; = _decorator;<br><br><span class="hljs-meta">@ccclass</span>(<span class="hljs-string">"FruitItem"</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> FruitItem &#123;<br>    <span class="hljs-meta">@property</span>(&#123;<span class="hljs-keyword">type</span>: CCInteger&#125;)<br><span class="hljs-keyword">public</span> id: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-meta">@property</span>(&#123;<span class="hljs-keyword">type</span>: SpriteFrame&#125;)<br>    <span class="hljs-keyword">public</span> img: SpriteFrame = <span class="hljs-literal">null</span>!;<br>&#125;<br><br><span class="hljs-meta">@ccclass</span>(<span class="hljs-string">"JuiceItem"</span>)<br><span class="hljs-keyword">class</span> JuiceItem &#123;<br>    <span class="hljs-meta">@property</span>(&#123;<span class="hljs-keyword">type</span>: SpriteFrame&#125;)<br>    <span class="hljs-keyword">public</span> juiceSF: SpriteFrame = <span class="hljs-literal">null</span>!;<br>    <span class="hljs-meta">@property</span>(&#123;<span class="hljs-keyword">type</span>: SpriteFrame&#125;)<br>    <span class="hljs-keyword">public</span> sarcocarpSF: SpriteFrame = <span class="hljs-literal">null</span>!;<br>    <span class="hljs-meta">@property</span>(&#123;<span class="hljs-keyword">type</span>: SpriteFrame&#125;)<br>    <span class="hljs-keyword">public</span> dewdropSF: SpriteFrame = <span class="hljs-literal">null</span>!;<br>&#125;<br><br><span class="hljs-meta">@ccclass</span>(<span class="hljs-string">'GameManager'</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> GameManager <span class="hljs-keyword">extends</span> Component &#123;<br><br>    <span class="hljs-meta">@property</span>(&#123;<span class="hljs-keyword">type</span>: Label&#125;)<br>    <span class="hljs-keyword">public</span> scoreLabel: Label = <span class="hljs-literal">null</span>!;<br>    <span class="hljs-meta">@property</span>(&#123;<span class="hljs-keyword">type</span>: Label&#125;)<br>    <span class="hljs-keyword">public</span> warnlineLabel: Label = <span class="hljs-literal">null</span>!;<br><br>    <span class="hljs-meta">@property</span>(&#123;<span class="hljs-keyword">type</span>: Prefab&#125;)<br>    <span class="hljs-keyword">public</span> fruitPrefab: Prefab = <span class="hljs-literal">null</span>!;<br>    <span class="hljs-meta">@property</span>(&#123;<span class="hljs-keyword">type</span>: FruitItem&#125;)<br><span class="hljs-keyword">public</span> fruits: FruitItem[] = [];<br><br>    <span class="hljs-meta">@property</span>(&#123;<span class="hljs-keyword">type</span>: Prefab&#125;)<br>    <span class="hljs-keyword">public</span> juicePrefab: Prefab = <span class="hljs-literal">null</span>!;<br>    <span class="hljs-meta">@property</span>(&#123;<span class="hljs-keyword">type</span>: JuiceItem&#125;)<br><span class="hljs-keyword">public</span> juices: JuiceItem[] = [];<br><br>    <span class="hljs-meta">@property</span>(&#123;<span class="hljs-keyword">type</span>: AudioClip&#125;)<br><span class="hljs-keyword">public</span> boomAudio: AudioClip = <span class="hljs-literal">null</span>!;<br>    <span class="hljs-meta">@property</span>(&#123;<span class="hljs-keyword">type</span>: AudioClip&#125;)<br><span class="hljs-keyword">public</span> waterAudio: AudioClip = <span class="hljs-literal">null</span>!;<br><br>    <span class="hljs-keyword">private</span> curFruit: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> curWarnlineFruit: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> lastWarnlineFruitPos: Vec3 = <span class="hljs-keyword">new</span> Vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> warnlineFruitLastTime: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> isCreating: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> isMoving: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> score: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> combineList: <span class="hljs-built_in">any</span>[] = [];<br><br>    onLoad() &#123;<br>        <span class="hljs-keyword">this</span>.initPhysics()<br><br>        <span class="hljs-keyword">this</span>.isCreating = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">this</span>.isMoving = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">this</span>.score = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">this</span>.node.on(Node.EventType.TOUCH_START, <span class="hljs-keyword">this</span>.onTouchStart, <span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">this</span>.node.on(Node.EventType.TOUCH_MOVE, <span class="hljs-keyword">this</span>.onTouchMove, <span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">this</span>.node.on(Node.EventType.TOUCH_END, <span class="hljs-keyword">this</span>.onTouchEnd, <span class="hljs-keyword">this</span>);<br><br>        <span class="hljs-keyword">this</span>.initOneFruit()<br>    &#125;<br><br>    start () &#123;<br>        log(<span class="hljs-string">"Start"</span>);<br>    &#125;<br><br>    initPhysics() &#123;<br>        <span class="hljs-keyword">const</span> system = PhysicsSystem2D.instance;<br>        system.debugDrawFlags = EPhysics2DDrawFlags.Aabb |<br>                                                EPhysics2DDrawFlags.Pair |<br>                                                EPhysics2DDrawFlags.CenterOfMass |<br>                                                EPhysics2DDrawFlags.Joint |<br>                                                EPhysics2DDrawFlags.Shape;<br><br>        system.gravity = <span class="hljs-keyword">new</span> Vec2(<span class="hljs-number">0</span>, <span class="hljs-number">-20</span> * PHYSICS_2D_PTM_RATIO);<br><br>        <span class="hljs-comment">// 物理步长，默认 fixedTimeStep 是 1/60</span><br>        system.fixedTimeStep = <span class="hljs-number">1</span>/<span class="hljs-number">60</span>;<br>        <span class="hljs-comment">// 每次更新物理系统处理速度的迭代次数，默认为 10</span><br>        system.velocityIterations = <span class="hljs-number">8</span>;<br>        <span class="hljs-comment">// 每次更新物理系统处理位置的迭代次数，默认为 10</span><br>        system.positionIterations = <span class="hljs-number">8</span>;<br>    &#125;<br><br>    initOneFruit() &#123;<br>        <span class="hljs-keyword">this</span>.curFruit = <span class="hljs-keyword">this</span>.createOneFruit(<span class="hljs-number">0</span>, <span class="hljs-number">400</span>, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    getNextFruitId() &#123;<br>        <span class="hljs-comment">// return 2;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">5</span>) + <span class="hljs-number">1</span><br>    &#125;<br><br>    createOneFruit(x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, iFruitID: <span class="hljs-built_in">number</span>) &#123;<br>        <span class="hljs-keyword">let</span> oFruit = instantiate(<span class="hljs-keyword">this</span>.fruitPrefab);<br>        <span class="hljs-keyword">const</span> config = <span class="hljs-keyword">this</span>.fruits[iFruitID - <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">let</span> fruitComponent = oFruit.getComponent(Fruit);<br>        <span class="hljs-keyword">if</span> (fruitComponent) &#123;<br>            fruitComponent.init(&#123;<br>                id: config.id,<br>                img: config.img<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">let</span> rigidBody2D = oFruit.getComponent(RigidBody2D);<br>        <span class="hljs-keyword">if</span> (rigidBody2D)<br>            rigidBody2D.type = ERigidBody2DType.Static;<br><br>        <span class="hljs-keyword">let</span> collider2D = oFruit.getComponent(CircleCollider2D);<br>        <span class="hljs-keyword">if</span> (collider2D) &#123;<br>            collider2D.enabled = <span class="hljs-literal">false</span>;<br>            collider2D.apply();<br>        &#125;<br><br>        oFruit.setPosition(<span class="hljs-keyword">new</span> Vec3(x, y, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">this</span>.node.addChild(oFruit);<br><br>        oFruit.on(<span class="hljs-string">'sameContact'</span>, <span class="hljs-keyword">this</span>.onSameContact, <span class="hljs-keyword">this</span>);<br><br>        <span class="hljs-keyword">return</span> oFruit;<br>    &#125;<br><br>    enablePhysics(oFruit: Node) &#123;<br>        <span class="hljs-keyword">let</span> rigidBody2D = oFruit.getComponent(RigidBody2D);<br>        <span class="hljs-keyword">if</span> (rigidBody2D)<br>            rigidBody2D.type = ERigidBody2DType.Dynamic;<br><br>        <span class="hljs-keyword">let</span> collider2D = oFruit.getComponent(CircleCollider2D);<br>        <span class="hljs-keyword">if</span> (collider2D) &#123;<br>            collider2D.enabled = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">let</span> uiTransform = oFruit.getComponent(UITransform);<br>            <span class="hljs-keyword">if</span> (uiTransform) &#123;<br>                collider2D.radius = uiTransform.contentSize.width / <span class="hljs-number">2</span>;<br>                collider2D.apply();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    enableFruitContactWarnline(oFruit: Node) &#123;<br>        oFruit.on(<span class="hljs-string">'warnlineContact'</span>, <span class="hljs-keyword">this</span>.onSameContact, <span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    showJuice(x: <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span>, iFruitID: <span class="hljs-built_in">number</span>) &#123;<br>        <span class="hljs-keyword">let</span> oJuice = instantiate(<span class="hljs-keyword">this</span>.juicePrefab);<br>        oJuice.setPosition(<span class="hljs-keyword">new</span> Vec3(x, y, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">const</span> config = <span class="hljs-keyword">this</span>.juices[iFruitID - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">let</span> sprite = oJuice.getComponent(Sprite);<br>        oJuice.setScale(<span class="hljs-keyword">new</span> Vec3(<span class="hljs-number">0.4</span> * <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">1.2</span>, iFruitID - <span class="hljs-number">1</span>), <span class="hljs-number">0.4</span> * <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">1.2</span>, iFruitID - <span class="hljs-number">1</span>), <span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">if</span> (sprite) &#123;<br>            sprite.spriteFrame = config.juiceSF;<br>        &#125;<br>        <span class="hljs-keyword">let</span> sarcocarp = oJuice.getChildByName(<span class="hljs-string">"sarcocarp"</span>);<br>        <span class="hljs-keyword">if</span> (sarcocarp) &#123;<br>            <span class="hljs-keyword">let</span> particle2D = sarcocarp.getComponent(ParticleSystem2D);<br>            <span class="hljs-keyword">if</span> (particle2D) &#123;<br>                particle2D.spriteFrame = config.sarcocarpSF;<br>                particle2D.startSize = <span class="hljs-number">20</span> * <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">1.2</span>, iFruitID - <span class="hljs-number">1</span>);<br>                particle2D.endSize = <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">1.2</span>, iFruitID - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">let</span> dewdrop = oJuice.getChildByName(<span class="hljs-string">"dewdrop"</span>);<br>        <span class="hljs-keyword">if</span> (dewdrop) &#123;<br>            <span class="hljs-keyword">let</span> particle2D = dewdrop.getComponent(ParticleSystem2D);<br>            <span class="hljs-keyword">if</span> (particle2D) &#123;<br>                particle2D.spriteFrame = config.dewdropSF;<br>                particle2D.startSize = <span class="hljs-number">20</span> * <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">1.2</span>, iFruitID - <span class="hljs-number">1</span>);<br>                particle2D.endSize = <span class="hljs-number">4</span> * <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">1.2</span>, iFruitID - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">this</span>.node.addChild(oJuice);<br><br>        <span class="hljs-keyword">this</span>.scheduleOnce(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            oJuice.destroy();<br>        &#125;, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    addScore(iFruitID: <span class="hljs-built_in">number</span>) &#123;<br>        <span class="hljs-keyword">this</span>.score += iFruitID;<br>        <span class="hljs-keyword">if</span> (iFruitID === <span class="hljs-number">10</span>) &#123;<br>            <span class="hljs-keyword">this</span>.score += <span class="hljs-number">100</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.scoreLabel) &#123;<br>            <span class="hljs-keyword">this</span>.scoreLabel.string = <span class="hljs-string">''</span> + <span class="hljs-keyword">this</span>.score;<br>        &#125;<br>    &#125;<br><br>    gameEnd() &#123;<br>        <span class="hljs-keyword">this</span>.node.children.forEach(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (element.name == <span class="hljs-string">"fruit"</span> &amp;&amp; element != <span class="hljs-keyword">this</span>.curFruit) &#123;<br>                <span class="hljs-keyword">let</span> pos = element.getPosition();<br>                <span class="hljs-keyword">let</span> iFruitID = element.getComponent(Fruit)?.getID();<br>                <span class="hljs-keyword">if</span> (iFruitID) &#123;<br>                    element.active = <span class="hljs-literal">false</span>;<br>                    element.destroy();<br>                    <span class="hljs-keyword">this</span>.addScore(iFruitID);<br>                    <span class="hljs-keyword">this</span>.showJuice(pos.x, pos.y, iFruitID);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">this</span>.curWarnlineFruit = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    onTouchStart(event: EventTouch) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isCreating)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isMoving)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">this</span>.isMoving = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">const</span> pos = event.getUILocation();    <span class="hljs-comment">// letf-bottom pos.</span><br>        <span class="hljs-keyword">let</span> x = pos.x;<br>        <span class="hljs-keyword">let</span> uiTransform = <span class="hljs-keyword">this</span>.getComponent(UITransform);<br>        <span class="hljs-keyword">if</span> (uiTransform) &#123;<br>            x -= uiTransform.width / <span class="hljs-number">2</span>;<br>        &#125;<br>        tween(<span class="hljs-keyword">this</span>.curFruit)<br>            .to(<span class="hljs-number">0.1</span>, &#123;position: <span class="hljs-keyword">new</span> Vec3(x, <span class="hljs-number">400</span>, <span class="hljs-number">0</span>)&#125;, &#123; easing: <span class="hljs-string">'cubicIn'</span>, <span class="hljs-string">'onComplete'</span>: <span class="hljs-function">(<span class="hljs-params">oFruit: <span class="hljs-built_in">any</span></span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">this</span>.isMoving = <span class="hljs-literal">false</span>;<br>            &#125;&#125;)<br>            .start();<br>    &#125;<br><br>    onTouchMove(event: EventTouch) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isCreating)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isMoving)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curFruit != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">const</span> pos = event.getUILocation();    <span class="hljs-comment">// letf-bottom pos.</span><br>            <span class="hljs-keyword">let</span> x = pos.x;<br>            <span class="hljs-keyword">let</span> uiTransform = <span class="hljs-keyword">this</span>.getComponent(UITransform);<br>            <span class="hljs-keyword">if</span> (uiTransform) &#123;<br>                x -= uiTransform.width / <span class="hljs-number">2</span>;<br>            &#125;<br>            <span class="hljs-keyword">this</span>.curFruit.setPosition(<span class="hljs-keyword">new</span> Vec3(x, <span class="hljs-number">400</span>, <span class="hljs-number">0</span>));<br>        &#125;<br>    &#125;<br><br>    onTouchEnd(event: EventTouch) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isCreating)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curFruit === <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span>;<br>        tween(<span class="hljs-keyword">this</span>.curFruit).stop();<br>        <span class="hljs-keyword">this</span>.isMoving = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">const</span> pos = event.getUILocation();    <span class="hljs-comment">// letf-bottom pos.</span><br>        <span class="hljs-keyword">let</span> x = pos.x;<br>        <span class="hljs-keyword">let</span> uiTransform = <span class="hljs-keyword">this</span>.getComponent(UITransform);<br>        <span class="hljs-keyword">if</span> (uiTransform) &#123;<br>            x -= uiTransform.width / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.curFruit.setPosition(<span class="hljs-keyword">new</span> Vec3(x, <span class="hljs-number">400</span>, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">this</span>.enablePhysics(<span class="hljs-keyword">this</span>.curFruit);<br>        <span class="hljs-keyword">this</span>.curFruit = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">this</span>.isCreating = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">this</span>.scheduleOnce(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">this</span>.curFruit = <span class="hljs-keyword">this</span>.createOneFruit(<span class="hljs-number">0</span>, <span class="hljs-number">400</span>, <span class="hljs-keyword">this</span>.getNextFruitId());<br>            <span class="hljs-keyword">this</span>.isCreating = <span class="hljs-literal">false</span>;<br>        &#125;, <span class="hljs-number">0.6</span>);<br>    &#125;<br><br>    onSameContact(selfCollider: Collider2D, otherCollider: Collider2D) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"---onSameContact"</span>);<br>        <span class="hljs-keyword">if</span> ((selfCollider.node === <span class="hljs-keyword">this</span>.curFruit) || (otherCollider.node == <span class="hljs-keyword">this</span>.curFruit))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">let</span> oSelfFruit = selfCollider.node.getComponent(Fruit);<br>        <span class="hljs-keyword">let</span> iFruitID = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (oSelfFruit)<br>            iFruitID = oSelfFruit.getID();<br>        <span class="hljs-keyword">if</span> (iFruitID &lt; <span class="hljs-number">11</span>) &#123;<br>            <span class="hljs-keyword">this</span>.combineList.push(&#123;<br>                nodeA: selfCollider.node,<br>                nodeB: otherCollider.node<br>            &#125;);<br>        &#125;<br>    &#125;<br><br>    lateUpdate(deltaTime: <span class="hljs-built_in">number</span>) &#123;<br>        <span class="hljs-keyword">this</span>.combineList.forEach(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (element.nodeA.isValid &amp;&amp; element.nodeB.isValid &amp;&amp; element.nodeA.active &amp;&amp; element.nodeB.active) &#123;<br>                <span class="hljs-keyword">let</span> oSelfFruit = element.nodeA.getComponent(Fruit);<br>                <span class="hljs-keyword">let</span> iFruitID = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (oSelfFruit)<br>                    iFruitID = oSelfFruit.getID();<br><br>                <span class="hljs-keyword">const</span> &#123;x, y&#125; = element.nodeB.getPosition();<br><br>                element.nodeA.active = <span class="hljs-literal">false</span>;<br>                element.nodeB.active = <span class="hljs-literal">false</span>;<br><br>                element.nodeA.destroy();<br>                element.nodeB.destroy();<br><br>                <span class="hljs-keyword">this</span>.addScore(iFruitID);<br><br>                <span class="hljs-keyword">const</span> nextId = iFruitID + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (nextId &lt;= <span class="hljs-number">11</span>) &#123;<br>                    <span class="hljs-keyword">let</span> oFruit = <span class="hljs-keyword">this</span>.createOneFruit(x, y, nextId);<br>                    <span class="hljs-keyword">this</span>.enablePhysics(oFruit);<br>                    <span class="hljs-keyword">this</span>.showJuice(x, y - <span class="hljs-number">6</span>, iFruitID);<br>                    <span class="hljs-keyword">this</span>.getComponent(AudioSource)?.playOneShot(<span class="hljs-keyword">this</span>.waterAudio, <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">this</span>.getComponent(AudioSource)?.playOneShot(<span class="hljs-keyword">this</span>.boomAudio, <span class="hljs-number">0.2</span>);<br><br>                    oFruit.setScale(<span class="hljs-keyword">new</span> Vec3(<span class="hljs-number">0.4</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">1</span>));<br>                    tween(oFruit)<br>                        .to(<span class="hljs-number">0.5</span>, &#123;scale: <span class="hljs-keyword">new</span> Vec3(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)&#125;, &#123; easing: <span class="hljs-string">'backOut'</span>&#125;)<br>                        .start();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.combineList.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">this</span>.combineList = [];<br>            <span class="hljs-keyword">this</span>.curWarnlineFruit = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">this</span>.warnlineFruitLastTime = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> warnY = <span class="hljs-keyword">this</span>.warnlineLabel.node.getPosition().y;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.curWarnlineFruit != <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">this</span>.curWarnlineFruit != <span class="hljs-keyword">this</span>.curFruit) &#123;<br>                <span class="hljs-keyword">let</span> pos = <span class="hljs-keyword">this</span>.curWarnlineFruit.getPosition().subtract(<span class="hljs-keyword">this</span>.lastWarnlineFruitPos);<br>                <span class="hljs-keyword">if</span> (pos.length() &lt; <span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">this</span>.warnlineFruitLastTime += <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.warnlineFruitLastTime &gt; <span class="hljs-number">90</span>) &#123;<br>                        <span class="hljs-keyword">this</span>.gameEnd();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">this</span>.curWarnlineFruit = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">this</span>.warnlineFruitLastTime = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">this</span>.curWarnlineFruit = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">this</span>.warnlineFruitLastTime = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">this</span>.node.children.forEach(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">if</span> (element.name == <span class="hljs-string">"fruit"</span> &amp;&amp; element != <span class="hljs-keyword">this</span>.curFruit) &#123;<br>                        <span class="hljs-keyword">let</span> pos = element.getPosition();<br>                        <span class="hljs-keyword">let</span> uiTransform = element.getComponent(UITransform);<br>                        <span class="hljs-keyword">if</span> (uiTransform) &#123;<br>                            <span class="hljs-keyword">const</span> h = uiTransform.contentSize.height;<br>                            <span class="hljs-keyword">if</span> (pos.y + (h / <span class="hljs-number">2</span>) &gt; warnY) &#123;<br>                                <span class="hljs-keyword">this</span>.curWarnlineFruit = element;<br>                                <span class="hljs-keyword">this</span>.lastWarnlineFruitPos = pos;<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> CocosCreator </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> CocosCreator </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2d-x学习笔记-第四章</title>
      <link href="/2020/05/02/cocos2d-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>/2020/05/02/cocos2d-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>cocos2d-x学习笔记-第四章。<br>cocos2d-x绘制系统。</p></blockquote><a id="more"></a><h2 id="新绘制系统的特点"><a href="#新绘制系统的特点" class="headerlink" title="新绘制系统的特点"></a>新绘制系统的特点</h2><h3 id="绘制逻辑从主循环中分离"><a href="#绘制逻辑从主循环中分离" class="headerlink" title="绘制逻辑从主循环中分离"></a>绘制逻辑从主循环中分离</h3><ul><li>cocos2d-x 3.0之前的架构是每个UI元素拥有自己的绘制逻辑，即使他们拥有相同的绘制方式。<h3 id="采用应用程序级别的视口裁剪"><a href="#采用应用程序级别的视口裁剪" class="headerlink" title="采用应用程序级别的视口裁剪"></a>采用应用程序级别的视口裁剪</h3></li><li>位于视窗区域外的UI元素，它不会将任何绘制命令发送到绘制栈上。<h3 id="自动批绘制"><a href="#自动批绘制" class="headerlink" title="自动批绘制"></a>自动批绘制</h3></li><li>减少Draw Calls能增强绘制的性能，在一个场景中，如果有很多元素都使用同一张纹理、同一个着色器程序等，理论上我们就可以只调用一次绘制命令。自动批绘制需要相关的绘制命令在执行顺序上相邻。<h3 id="更简单地实现绘制的自定义"><a href="#更简单地实现绘制的自定义" class="headerlink" title="更简单地实现绘制的自定义"></a>更简单地实现绘制的自定义</h3></li><li>cocos2d-x 3.0以更清晰的方式定义了怎样实现自定义绘制，自定义绘制仍然可以加入cocos2d-x的绘制命令栈，参与所有命令的绘制排序等。</li></ul><h2 id="绘制系统概览"><a href="#绘制系统概览" class="headerlink" title="绘制系统概览"></a>绘制系统概览</h2><ul><li>首先，通过UI树的遍历，给每个元素生成一个绘制命令。新的绘制系统实现的基础是将与绘制相关的部分从UI元素中分离。RenderCommand表示一个绘制类型，它定义了怎样绘制一个元素。一般情况下，一个UI元素会关联零个或一个RenderCommand，并在重写的Node::draw()方法中将绘制命令发送给renderer。  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> Sprite::draw(Renderer *renderer, <span class="hljs-keyword">const</span> Mat4 &amp;transform, <span class="hljs-keyword">bool</span> transformUpdated)<br>&#123;<br>_insideBounds = transformUpdated ? renderer-&gt;CheckVisibility(transform, _contentSize) : _insideBounds;<br>    <span class="hljs-keyword">if</span>(_insideBounds) &#123;<br>    _quadCommand.init(_globalZOrder, _texture-&gt;getName(), getGLProgramState(), _blendFunc, &amp;_quad, <span class="hljs-number">1</span>, transform);<br>        renderer-&gt;addCommand(&amp;_quadCommand);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>_</p><ul><li><img src="/2020/05/02/cocos2d-x学习笔记-第四章/将绘制指令发送至绘制栈.png" alt="将绘制指令发送至绘制栈.png"></li><li>绘制流程的第二个阶段是将绘制命令进行排序。待场景中的UI元素被全部遍历完后，renderer线对栈上的绘制命令进行排序，然后再执行它们。排序顺序是，先按globalZOrderuxu，再根据元素遍历顺序排序。</li><li>最后，renderer对经过排序的绘制命令执行绘制。对于一般的RenderCommand，按顺序执行。对于Sprite使用的QuadCommand，如果两个QuadCommand相邻且使用相同的纹理、着色器等，renderer会将它们组合成一个QuadCommand，这便是自动批绘制（Auto Batch）。</li></ul><h2 id="RenderCommand"><a href="#RenderCommand" class="headerlink" title="RenderCommand"></a>RenderCommand</h2><ul><li>在渲染系统管理下的每一次绘制调用都是一个RenderCommand，一个RenderCommand是一种特定的绘制方式封装。如，QuadCommand根据一个纹理和4个顶点绘制一张图片。每个RenderCommand所包含的OpenGL ES命令会被放到一起按顺序执行，为了不影响其他RenderCommand的绘制，每个RenderCommand在结束后将对OpenGL ES的一些状态进行还原，如自定义的摄像机修改了观察点的位置和方向等。  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RenderCommand</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">enum</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Type</span><br>    &#123;</span><br>    UNKNOWN_COMMAND;<br>        QUAD_COMMAND;<br>        CUSTOM_COMMAND;<br>        BATCH_COMMAND;<br>        GROUP_COMMAND;<br>    &#125;;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getGlobalOrder</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _globalOrder; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> Type <span class="hljs-title">getType</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _type; &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>_</p><ul><li>GROUP_COMMAND可以用来包装多个RenderCommand的集合，GroupCommand中的每一个RenderCommand都不会参与全局排序。GROUP_COMMAND可以用来实现子元素的裁剪、绘制子元素到纹理等，如ClippingNode和RenderTexture。</li><li>自定义的RenderCommand全部继承自CustomCommand。</li></ul><h2 id="RenderQueue"><a href="#RenderQueue" class="headerlink" title="RenderQueue"></a>RenderQueue</h2><ul><li>场景中每个UI元素的绘制命令RenderCommand将被发送到RenderQueue的绘制命令栈中，RenderQueue中存储着一组RenderCommand。  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RenderQueue</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(RenderCommand* command)</span></span>;<br>    <span class="hljs-keyword">ssize_t</span> size() <span class="hljs-keyword">const</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">()</span></span>;<br>    RenderCommand* <span class="hljs-keyword">operator</span>[](<span class="hljs-keyword">ssize_t</span> index) <span class="hljs-keyword">const</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;RenderCommand*&gt; _queueNegZ;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;RenderCommand*&gt; _queue0;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;RenderCommand*&gt; _queuePosZ;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>_</p><ul><li>RenderQueue中用了三个RenderCommand的数组来存储globalOrder小于0，等于0，大于0的RenderCommand。由于每个RenderCommand的globalOrder几乎都来自于Node的globalZOrder属性，而Node的globalZOrder默认值为0。所以，对于globalOrder为0的情况，它们的绘制顺序取决于它被添加的顺序，即localZOrder，因此它们根本不需要再进行排序。因此，通过三个数组的方式，可以大大减少排序的消耗。</li><li>Renderer实际上维护着一个RenderQueue数组，每个RenderQueue对应一组RenderCommand或者一个GroupCommand，这些RenderQueue之间是通过GroupCommand构成的树状关系。</li></ul><h2 id="GroupCommand"><a href="#GroupCommand" class="headerlink" title="GroupCommand"></a>GroupCommand</h2><ul><li>GroupCommand通常不包含具体的GL绘制命令，它指向一个RenderQueue。当渲染系统绘制一个GroupCommand时，它将找到对应的RenderQueue，执行其中的RenderCommand。  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupCommand</span> :</span> <span class="hljs-keyword">public</span> RenderCommand<br>&#123;<br><span class="hljs-keyword">public</span>:<br>GroupCommand();<br>    ~GroupCommand();<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">float</span> depth)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getRenderQueueID</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>&#123; <span class="hljs-keyword">return</span> _renderQueueID; &#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-keyword">int</span> _renderQueueID;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>_</p><ul><li>如果把一组RenderCommand加入GroupCommand指向的RenderQueue中，则可以实现对这组RenderCommand的独立绘制，它们的执行顺序不受其他RenderCommand的影响。</li><li>GroupCommand在添加到Renderer的绘制栈上时，通过将其所包含的RenderCommand放到一个单独的RenderQueue中，从而将其所包含的RenderCommand“打包”，其所包含的RenderCommand不需要知道其祖先中有GroupCommand。</li><li>Renderer持有多个RenderQueue，用 _renderGroups 来存储，我们可以认为一个RenderQueue就是一个GroupCommand。默认情况下，所有RenderCommand被添加到索引为0的RenderQueue中，我们称其为主绘制栈。  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Renderer</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addCommand</span><span class="hljs-params">(RenderCommand* command)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addCommand</span><span class="hljs-params">(RenderCommand* command, <span class="hljs-keyword">int</span> renderQueue)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushGroup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> renderQueueID)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">popGroup</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">createRenderQueue</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">stack</span>&lt;<span class="hljs-keyword">int</span>&gt; _commandGroupStack;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;RenderQueue&gt; _renderGruops;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>_</p><ul><li>在添加GroupCommand的时候有一个约定操作：在创建一个GroupCommand并将其作为一个普通的RenderCommand发送到当前的RenderQueue上，GroupCommand会在Renderer上创建一个新的RenderQueue，并调用pushGroup方法将其renderQueueID添加到_commandGroupStack栈中。这样，后续所有的RenderCommand都会被添加到新创建的RenderQueue中，在结束的时候再调用popGroup()方法。</li><li><img src="/2020/05/02/cocos2d-x学习笔记-第四章/嵌套的GroupCommand.png" alt="嵌套的GroupCommand.png"></li></ul><h2 id="Render"><a href="#Render" class="headerlink" title="Render"></a>Render</h2><ul><li>在主线程遍历完UI树，并将每个UI元素的绘制发送到绘制栈上之后，绘制线程开始执行全部绘制命令。此时，Renderer需现对RenderCommand进行排序，然后再按照排序后的顺序分别执行绘制命令。</li><li>cocos2d-x对排序做了优化，对于所有globalOrder为0的RenderCommand都不执行排序，以它们被添加到RenderQueue中的顺序为准。RenderCommand被添加到RenderQueue中的顺序是由localZOrder决定的。对少数设置了globalOrder的Node才需要进行排序。</li><li>GroupCommand中可能会嵌套着GroupCommand，从而形成一颗由GroupCommand定义的树。在排序的时候，这颗树是按照深度优先遍历的方式进行排序的，即子GroupCommand树中的RenderCommand的globalOrder只在该子GroupCommand树种生效。</li><li>自动批绘制技术：<ul><li>如果多个相邻的QuadCommand它们具有相同的纹理、着色器程序、混合模式、一些OpenGL的状态设置等绘制特征，在cocos2d-x中会将它们的绘制自动合批，即只调用一次GL Call，从而提高绘制性能。</li><li>在遇到第一个QuadCommand时，并不会立即绘制，而是将其存放在一个数组中，然后继续遍历RenderCommand。</li><li>如果下一个RenderCommand的类型仍是QUAD_COMMAND，并且它们的纹理、着色器程序、混合参数等相同，则会将该QuadCommand继续放入缓存的数组中，直到遇到不满足条件RenderCommand，才将先前缓存的QuadCommand数据一并进行绘制。</li><li>判断两个QuadCommand是否使用相同的纹理、着色器、混合参数等，是通过材质ID（materialID）进行判断的。materialID是通过对着色器名称、纹理名称、混合方程等相关参数进行Hash计算，得出Hash值作为materialID，只有具有相同materialID的QuadCommand才能进行批绘制。</li><li>如果使用开发者自定义的着色器程序，该RenderCommand的materialID将会被设置为MATERIAL_ID_NOT_BATCH，即表示该RenderCommand不能参与任何批绘制。</li><li>在cocos2d-x中，所有顶点数据使用一个VBO对象，它能容纳的最大Quad数量是10922(65536/6)。所以，当Quad的数量大于这个值的时候，将会立即执行前面的命令。</li></ul></li></ul><h2 id="元素的可见性"><a href="#元素的可见性" class="headerlink" title="元素的可见性"></a>元素的可见性</h2><ul><li>自动裁剪技术<ul><li>仅在Sprite元素上，在遍历UI树时，若发现其位于屏幕之外（insideBounds为false），则不会发送绘制命令道Renderer中。</li><li>对于Node类，其有visible属性，当一个元素的visible微false时，在遍历UI树时将被忽略。</li><li>自动裁剪不会影响子元素的绘制，而visible为false时，其所有子元素都不会被绘制。</li></ul></li><li>visible()和insideBounds()方法都不会影响事件的分发，因为元素的可见性与事件没有完全对等的关系，因此，一个元素即使不可见，但它还是能接收触摸事件。因此，若一个类在不可视时不希望响应事件，需要自行处理，例如在Menu类中，其在处理触摸事件的逻辑中，首先会对自身及父级元素的可见性判断，如果自己所在的分支上有任意一个元素不可视，则不响应触摸事件。</li></ul><h2 id="绘制的时机"><a href="#绘制的时机" class="headerlink" title="绘制的时机"></a>绘制的时机</h2><ul><li>绘制与UI树的遍历分离后，我们只是将绘制命令发送到Renderer中，但并不知道元素什么时候被真正绘制了。对于想操作绘制完毕后的纹理的操作，如RenderTexture，则不方便。</li><li>一般有两种方式处理：<ul><li>注册Schedule，该Schedule在下一帧被执行时获取上一帧的绘制结果，并注销该Schedule。</li><li>添加一个CustomCommand来提供一个通知，它在被Renderer执行时会回调应用程序指定的一个func()进行自定义绘制，func中通常包含了一系列的GL命令的调用。但是，由于func是在Renderer执行绘制命令时发出的，所以，只要将其放置在合适的绘制位置，func则可以作为一个绘制时机的回调函数。</li><li>例子：  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">bool</span> RenderTexture::saveToFile(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; fileName, Image::Format format)<br>      &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> fullpath = FileUtils::getInstance()-&gt;getWritablePath() + fileName;<br>          _saveToFileCommand.init(_globalZOrder);<br>          _saveToFileCommand.func = CC_CALLBACK_0(RenderTexture::onSaveToFile, <span class="hljs-keyword">this</span>, fullpath);<br><br>          Director::getInstance()-&gt;getRenderer()-&gt;addCommand(&amp;_saveToFileCommand);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">void</span> RenderTexture::onSaveToFile(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; filename)<br>      &#123;<br>      Image *image = newImage(<span class="hljs-literal">true</span>);<br>          <span class="hljs-keyword">if</span> (image) &#123;<br>          image-&gt;saveToFile(filename.c_str(), <span class="hljs-literal">true</span>);<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> cocos2d-x学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2d-x学习笔记-第二章</title>
      <link href="/2020/03/15/cocos2d-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2020/03/15/cocos2d-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>cocos2d-x学习笔记-第二章。<br>cocos2d-x架构。</p></blockquote><a id="more"></a><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><ul><li>cocos2d-x 引擎系统结构：</li><li><img src="/2020/03/15/cocos2d-x学习笔记-第二章/cocos2dx引擎系统结构.png" alt="cocos2dx引擎系统结构.png"></li><li>cocos2d-x支持跨平台，其使用大量第三方开源库用于支持文件解压、图片解析、网络支持、物理引擎、音频等功能，自身则专注于渲染引擎的开发。</li><li>在使用了第三方库的基础上，其还封装了文件的加载、纹理解析、线程操作等跨平台接口，使得渲染和其他系统的设计可以与平台无关。</li></ul><h2 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h2><h3 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h3><ul><li><p>cocos2d-x不使用C++ 11中的只能指针，原因有二：</p><ul><li>其一，智能指针有较大的性能损失。shared_ptr为了保证线程安全，必须使用一定形式的互斥锁来保证所有线程访问时其引用计数的正确。对游戏这种实时性要求非常高的应用程序而言，这种性能损失是不可接受的。</li><li><p>其二，需要程序员显式的声明智能指针，如创建一个Node：</p>  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">share_ptr&lt;Node*&gt; node(<span class="hljs-keyword">new</span> Node());<br></code></pre></td></tr></table></figure><p>  另外，在需要引用的地方，一般应该使用weak_ptr指针，否则在Node被移除的时候，还需要手动减持shared_ptr指针的引用计数。如：</p>  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">weak_ptr&lt;Node*&gt; refNode=node;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>垃圾回收机制：</p><ul><li>基于引用计数：引用计数使用系统记录的一个对象被引用的次数，当对象被引用的次数变为零时，该对象即被视作垃圾而被回收。优点是实现比较简单。</li><li>基于跟踪处理：先产生跟踪对象的关系图，再进行垃圾回收。其算法是首先将程序中正在使用的对象视为根对象，从根对象开始查找它们所引用的堆空间，并在这些堆空间上做标记。做完标记后，所有未被标记的对象即被视为垃圾，会在第二阶段被清理。清理的方式是对正在使用的对象进行移动或者复制，从而减少内存碎片的产生。</li></ul></li></ul><h3 id="cocos2d-x-内存管理机制"><a href="#cocos2d-x-内存管理机制" class="headerlink" title="cocos2d-x 内存管理机制"></a>cocos2d-x 内存管理机制</h3><ul><li><p><strong>autorelease垃圾回收机制：</strong></p><ul><li><p>cocos2d-x中的所有对象几乎都继承自Ref基类。Ref基类主要的职责就是对对象进行引用计数管理。</p>  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC_DLL</span> <span class="hljs-title">Ref</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">retain</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">release</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Ref* <span class="hljs-title">autorelease</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getReferenceCount</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br><br><span class="hljs-keyword">protected</span>:<br>Ref();<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// count of references</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> _referenceCount;<br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoreleasePool</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>当一个对象使用new运算符分配的内存时候，其引用计数为1，调用retain()方法，会增加引用计数，调用release()则减少引用计数。在调用release()方法后，若其引用计数为0，则自动调用delete运算符删除对象并释放内存。</p></li><li>直接使用retain()和release()会增加程序复杂性，在cocos2d-x中支持用autorelease()方法声明一个“智能指针”。</li><li>使用autorelease()声明的智能指针，它们会被放进AutoreleasePool中，在每帧结束的时候，对AutoreleasePool中的对象进行清理。即，在cocos2d-x中，一个智能指针的生命周期是从创建开始到当前帧结束时结束。</li><li>AutoreleasePool的实现机制是对池子中的每个对象执行一次release()，然后清空池子。对象在new出来后，引用计数为1，在帧尾若未被其他地方引用，则在执行release()时引用计数清零，从而被释放。</li><li><p>cocos2d-x中大部分的类可以通过静态方法create()来返回一个智能指针对象，另外，自定义的UI元素也应该遵循这样的风格。</p>  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">Node * Node::create(<span class="hljs-keyword">void</span>)<br>&#123;<br>    Node * ret = <span class="hljs-keyword">new</span> Node();<br>    <span class="hljs-keyword">if</span> (ret &amp;&amp; ret-&gt;init()) &#123;<br>        ret-&gt;autorelease();<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        CC_SAFE_DELETE(ret);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>默认的AutoreleasePool一帧被清理一次，主要用来清理UI元素。若游戏中在一帧中创建大量的临时对象，且这些对象只在每个方法的作用域内被使用，若继续使用默认的AutoreleasePool来清理对象，那在帧尾前会有大量游戏对象残留，内存容易形成峰值。</p></li><li>在cocos2d-x中，支持程序员创建、销毁AutoreleasePool。在创建了新的AutoreleasePool后，之后新创建的autorelease()智能指针对象都会放进该AutoreleasePool中。在AutoreleasePool被销毁的时候，会自动执行其自身的clear()方法，对其管理的每个对象执行release()操作后，再将当前使用的AutoreleasePool设置为上一次创建的AutoreleasePool。简言之，就是一个栈的实现。</li><li><p>cocos2d-x中通过PoolManager来管理AutoreleasePool队列，创建AutoreleasePool时会放进PoolManager中，销毁AutoreleasePool时会从PoolManager中移除，PoolManager管理当前使用的是哪个AutoreleasePool队列。</p>  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC_DLL</span> <span class="hljs-title">PoolManager</span><br>&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">static</span> PoolManager* <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroyInstance</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">AutoreleasePool *<span class="hljs-title">getCurrentPool</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isObjectInPools</span><span class="hljs-params">(Ref* obj)</span> <span class="hljs-keyword">const</span></span>;<br><br>    <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoreleasePool</span>;</span><br><br><span class="hljs-keyword">private</span>:<br>PoolManager();<br>    ~PoolManager();<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(AutoreleasePool *pool)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-keyword">static</span> PoolManager* s_singleInstance;<br><br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;AutoreleasePool*&gt; _releasePoolStack;<br>    AutoreleasePool *_curReleasePool;<br>&#125;<br><br>AutoreleasePool::AutoreleasePool()<br>: _name(<span class="hljs-string">""</span>)<br>&#123;<br>_managedObjectArray.reserve(<span class="hljs-number">150</span>);<br>    PoolManager::getInstance()-&gt;push(<span class="hljs-keyword">this</span>);<br>&#125;<br><br>AutoreleasePool::AutoreleasePool(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span> &amp;name)<br>: _name(name)<br>&#123;<br>_managedObjectArray.reserve(<span class="hljs-number">150</span>);<br>    PoolManager::getInstance()-&gt;push(<span class="hljs-keyword">this</span>);<br>&#125;<br><br>AutoreleasePool::~AutoreleasePool()<br>&#123;<br>clear();<br>    PoolManager::getInstance()-&gt;pop();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>因此，可以在局部方法中通过创建AutoreleasePool的自动变量的方式，让方法结束时候自动清理该方法中创建的临时autorelease()对象。</p></li></ul></li><li><p><strong>RefPtr<t>智能指针：</t></strong></p><ul><li>对于单个的非集合元素对象，我们往往不会通过Autorelease进行管理，除非它是一个临时对象。此时，我们需要手动调用retain()和release()，这跟new和delete是等价的，容易导致内存管理问题。</li><li>cocos2d-x模仿C++ 11的std::shared_ptr实现RefPtr<t>智能指针，使用Ref的引用计数来管理多个智能对内存的共享。但它不是线程安全的，也因此比shared_ptr更高效。</t></li><li><strong>构造函数：</strong> 在RefPtr中，对于传入参数为左值的构造函数和复制构造函数，会对T*增加引用计数。对于右值的复制构造函数，则不会增加引用计数，而是将其对应的内存的占用转移过来。</li><li><strong>赋值操作符：</strong> 与构造函数类似，对于任何左值变量的赋值，RefPtr都应该与该左值共享资源从而增加其引用计数，对于右值，仍然应该转移而不是共享。特别的是，赋值操作符还会释放对之前旧的资源的引用计数。</li><li><p><strong>弱引用赋值：</strong> 无论是复制构造函数，还是赋值操作符，RefPtr都会对任何非空的左值资源保持一种强引用关系。RefPtr提供weakAssign()方法来实现弱引用。通过weakAssign()方法，我们可以不用再手动调用release()来实现若引用。</p>  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 不使用weakAssign。</span><br>RefPtr&lt;cocos2d::Image&gt; image;<br>image = <span class="hljs-keyword">new</span> cocos2d::Image();<br>image-&gt;release();<br><br><span class="hljs-comment">// 使用weakAssign。</span><br>RefPtr&lt;cocos2d::Image&gt; image;<br>image.weakAssign(<span class="hljs-keyword">new</span> cocos2d::Image());<br></code></pre></td></tr></table></figure></li><li><p><strong>RefPtr<t>与自动回收池的比较：</t></strong></p><ol><li>如果用autorelease替代RefPtr，由于autorelease完全依赖于自动回收池的释放，使得各个共享的变量几乎无法控制对资源的使用。</li><li>如果用RefPtr替代autorelease，那么任何一个对Node资源的引用都是强引用，使得当Node从UI树中移除时，需要调用reset释放其对Node资源的占用，这是无法控制的。</li><li>因此，对于UI元素，我们希望使用一种弱引用类型的内存管理方式，只有UI树本身才可分配和释放内存，其他地方都是弱引用，这里使用autorelease来管理会更合适。对于游戏中的数据，则使用智能指针RefPtr来管理。</li></ol></li><li><p><strong>RefPtr<t>的缺陷：</t></strong></p><ol><li><p>引用计数可以被RefPtr从外部控制，让RefPtr中的资源情况变得复杂。</p> <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">auto</span> str = <span class="hljs-keyword">new</span> __String(<span class="hljs-string">"Hello"</span>);<br>RefPrt&lt;__String&gt; prt;<br>prt.weakAssign(str);<br>str.release();<span class="hljs-comment">// 外部控制引用计数。</span><br>(*ptr)-&gt;GetCString();<span class="hljs-comment">// 访问野指针。</span><br></code></pre></td></tr></table></figure></li><li><p>RefPtr提供的弱引用智能指针可以对其资源进行修改，从而导致原智能指针的行为变得不可预期。</p> <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">RefPtr&lt;__String&gt; prt1(<span class="hljs-keyword">new</span> __String(<span class="hljs-string">"Hello"</span>));<br>RefPtr&lt;__String&gt; prt2;<br>ptr2.weakAssign(ptr1);<span class="hljs-comment">// 引用计数2。</span><br>ptr2.reset();<span class="hljs-comment">// 引用计数1。</span><br>ptr2.reset();<span class="hljs-comment">// 引用计数0，释放。</span><br>(*ptr)-&gt;GetCString();<span class="hljs-comment">// 出错。</span><br></code></pre></td></tr></table></figure></li></ol></li></ul></li><li><p><strong>怎样进行内存管理：</strong></p><ul><li>Ref的引用计数并不是线程安全的，在多线程中，我们需要通过处理互斥锁来保证线程的安全。处于性能等方面的考虑，cocos2d-x没有提供AutoreleasePool的安全实现。</li><li>对自定义的Node子类，为其添加create()方法，并使该方法返回一个autorelease对象。</li><li>对于自定义的数据类型，如果需要动态分配内存，继承自Ref，使用智能指针RefPtr来管理其内存的释放。</li><li>对于只在一个方法内部使用的Ref对象，需要使用自动回收池的，应使用自定义的AutoreleasePool来即时清理对内存的占用。</li><li>不要动态分配AutoreleasePool对象，要始终使用自动变量。</li><li>不要显式调用Refptr的构造函数，始终使用隐式方式调用构造函数（复制构造函数、赋值操作符）。因为显式的构造函数会导致同事执行构造函数和赋值操作符，这会造成一次不必要的临时智能指针变量的产生。</li></ul></li></ul><h2 id="UI树及运行时游戏对象"><a href="#UI树及运行时游戏对象" class="headerlink" title="UI树及运行时游戏对象"></a>UI树及运行时游戏对象</h2><ul><li>锚点：<ul><li>锚点取值是(0, 0)到(1, 1)之间。</li><li>其决定着元素的位置、旋转、缩放等操作的基准点。</li></ul></li><li>坐标系：<ul><li>右手坐标系。</li><li>本地坐标系以元素的左下角为原点（注意，<strong>不是锚点</strong>）。</li><li>使用convertToWorldSpaceAR计算世界坐标时，其返回的是以该元素的锚点为原点的坐标系中的某个位置的世界坐标。</li></ul></li><li>UI树：<ul><li>cocos2d-x的UI树根节点为Scene类，UI树中每个节点都是一个Node实例对象，每个Node对象具有一个children集合及一个parent集合，其中Scene的parent属性为空。</li><li>UI树使用中序遍历，将所有子元素分为两组，其中一组的逻辑深度小于0，表示其层级处于父节点之后，另一组的逻辑深度大于或等于0，表示层级在父节点之上。开发者可以通过制定逻辑深度来制定一个元素的绘制顺序。</li><li>逻辑深度：在visit()方法开始遍历子元素前，会对所有子元素按逻辑深度从小到大进行排序。逻辑深度使用localZOrder属性表示，若两个元素的逻辑深度一致，则按它们被添加到UI树种的顺序排序。</li><li>只按localZOrder来进行绘制顺序排序，会让游戏开发失去一定的灵活性，如希望将一个低层级的元素始终可见，我们不得不把它移至UI树的根部。cocos2d-x 3.0新增了globalZOrder，排序逻辑如下：<ol><li>默认每个元素的globalZOrder值为0。</li><li>如果一个元素的globalZOrder值不为0，则按globalZOrder进行排序。</li><li>否则，按localZOrder进行排序。</li></ol></li></ul></li></ul><h2 id="应用程序架构"><a href="#应用程序架构" class="headerlink" title="应用程序架构"></a>应用程序架构</h2><ul><li><p><strong>游戏生命周期</strong></p><ul><li><p>一个游戏对应于一个Application对象，Application的职责是管理游戏生命周期并设置默认窗口，获取平台及本地化信息等。在cocos2d-x种，通常会实现一个Application的子类供程序员自定义生命周期各个阶段的处理，这个子类叫作AppDelegate。</p>  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppDelegate</span> :</span> <span class="hljs-keyword">private</span> cocos2d::Application<br>&#123;<br><span class="hljs-keyword">public</span>:<br>AppDelegate();<br>    <span class="hljs-keyword">virtual</span> ~AppDelegate();<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">applicationDidFinishLaunching</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applicationDidEnterBackground</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applicationWillEnterForeground</span><span class="hljs-params">()</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>在applicationDidFinishLaunching事件中，我们需要创建和初始化一个Director，并未Director创建一个OpenGL ES窗口（cocos2d-x中封装为一个GLView），然后创建场景，并将场景交给Director绘制出来。一个Application可以创建多个Director，每个Director对应一个屏幕，以支持多屏设备。</p></li></ul></li><li><p><strong>场景管理</strong></p><ul><li>在游戏初始化时，我们通过Director::runWithScene()方法指定了第一个场景，之后可以通过getRunningScene()方法取得当前正在运行的场景。</li><li>Director支持replaceScene()方法直接替换场景，这回直接删除并释放之前的场景。也可以使用场景栈来进行场景管理，在这种情况下，切换到一个新的场景不会删除之前的场景，而是将新的场景加入场景栈的顶端。对应方法为pushScene和popScene，也可以通过popToRootScene方法切换到栈底场景。</li></ul></li><li><p><strong>游戏循环</strong></p><ul><li><p>当Application对象被初始化后，就开始根据设定的帧率执行游戏循环。Application::run是整个应用程序的入口，Director::mainLoop则定义了一个游戏循环所有的事件和内容。</p>  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> Application::run()<br>&#123;<br><span class="hljs-keyword">if</span>(!applicationDidFinishLaunching()) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    glview-&gt;retain();<br>    <span class="hljs-keyword">while</span> (!glview-&gt;windowShouldClose()) &#123;<br>    lastTime = getCurrentMillSecond();<br>        director-&gt;mainLoop();<br>        glview-&gt;pollEvents();<br><br>        curTime = getCurrentMillSecond();<br>        <span class="hljs-keyword">if</span> (curTime - lastTime &lt; _animationInterval) &#123;<br>        usleep(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">useconds_t</span>&gt;((_animationInterval - curTime + lastTime) * <span class="hljs-number">1000</span>));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2020/03/15/cocos2d-x学习笔记-第二章/游戏循环.png" alt="游戏循环.png"></p></li></ul></li><li><p><strong>实时更新游戏对象</strong></p><ul><li>游戏中通过Director::setAnimationInterval()方法来设置帧率。</li><li><p>Scheduler提供两种类型的回调更新，scheduleUpdate和schedule，scheduleUpdate与游戏循环的帧率保持一致，schedule则支持自定义的更新间隔、更新次数等。在实现上，每个自定义的更新回调需要使用一个Timer类（非线程中的Timer）来计时，这会花费更多的内存及计算时间，且不能指定更新的优先级。所以，在编写程序时应该尽量使用scheduleUpdate。</p>  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC_DLL</span> <span class="hljs-title">Scheduler</span> :</span> <span class="hljs-keyword">public</span> Ref<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 该回调更新与游戏循环的帧率保持一致。</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">T</span>&gt;<br>    <span class="hljs-title">void</span> <span class="hljs-title">scheduleUpdate</span>(<span class="hljs-title">T</span> *<span class="hljs-title">target</span>, <span class="hljs-title">int</span> <span class="hljs-title">priority</span>, <span class="hljs-title">bool</span> <span class="hljs-title">paused</span>)<br>    &#123;</span><br>    <span class="hljs-keyword">this</span>-&gt;schedulePerFrame([target](<span class="hljs-keyword">float</span> dt) &#123;<br>        target-&gt;update(dt);<br>        &#125;, target, priority, paused);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC_DLL</span> <span class="hljs-title">Scheduler</span> :</span> <span class="hljs-keyword">public</span> Ref<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ccSchedulerFunc&amp; callback, <span class="hljs-keyword">void</span> *target, <span class="hljs-keyword">float</span> interval, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> repeat, <span class="hljs-keyword">float</span> delay, <span class="hljs-keyword">bool</span> paused, <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; key)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Scheduler支持设置timeScale来设置其相对时间线。默认状态下,timeScale为1.0，表示与游戏循环更新频率一致。通过修改该值，可以产生加速、减速效果。</p>  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> Scheduler::update(<span class="hljs-keyword">float</span> dt)<br>&#123;<br><span class="hljs-keyword">if</span> (_timeScale != <span class="hljs-number">1.0f</span>) &#123;<br>    dt *= _timeScale;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>虽然Scheduler支持设置更新回调的优先级，但按游戏对象来划分逻辑更新优先级的方式并不是一种合理的方式。在游戏设计中，队逻辑，而不是游戏对象设计优先级往往更有意义。在cocos2d-x中，ActionManager和PhysicsWorld分别管理Node对象的动画更新和物理模拟相关的计算，而不是单独对每个Node对象执行动画和物理模拟。这样，ActionManager和PhysicsWorld可以作为一个逻辑子系统，我们只需要关心两个子系统的逻辑优先级。</p></li><li>ActionManager和PhysicsWorld给了我们一种启示，我们应该对一个逻辑注册一个更新回调，而不是对使用该逻辑的某个对象注册更新回调。这样我们便只需要关心逻辑优先级，而不用考虑对象优先级。</li></ul></li></ul><h2 id="coco2d-x的主线程"><a href="#coco2d-x的主线程" class="headerlink" title="coco2d-x的主线程"></a>coco2d-x的主线程</h2><ul><li><p>cocos2d-x目前仍然是一个单线程的游戏引擎，这使得我们几乎不用考虑游戏对象更新的线程安全性。</p></li><li><p><strong>主线程中执行异步处理</strong></p><ul><li>Scheduler提供performFunctionInCocosThread方法，让我们可以在主线程中执行一个方法，执行的时机所有系统或自定义的schedule之后，在UI树遍历之前。  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">void</span> Scheduler::performFunctionInCocosThread(<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">void</span>()&gt; &amp;function)<br>&#123;<br>_performMutex.lock();<br>    _functionsToPerform.push_back(function);<br>    _performMutex.unlock();<br>&#125;<br><br><span class="hljs-keyword">void</span> Scheduler::update(<span class="hljs-keyword">float</span> dt)<br>&#123;<br><span class="hljs-keyword">if</span> (!_functionsToPerform.empty()) &#123;<br>    _performMutex.lock();<br>        <span class="hljs-keyword">auto</span> temp = _functionsToPerform;<br>        _functionsToPerform.clear();<br>        _performMutex.unlock();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;function: temp) &#123;<br>        function();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>纹理的异步加载</strong></p><ul><li>所有想scheduler注册的方法都会在该帧结束的时候被全部执行，对于一些比较耗时的计算，为了不影响游戏的性能，我们需要把一些列耗时的方法分帧执行。</li><li>cocos2d-x纹理的异步加载完成后，将纹理上传至GL内存的操作必须要在主线程中执行，但是glTexImage2D是一个耗时的操作，同时执行太多容易造成卡顿。</li><li>cocos2d-x的纹理异步加载回调使用了一个自定义的Schedule，该Schedule内部，检查已经完成加载的纹理，每一帧处理一个纹理，直至所有纹理被处理完毕，则注销该Schedule。</li><li>TextureCache向Scheduler注册一个更新回调addImageAsyncCallBack。  <figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c">      <span class="hljs-keyword">void</span> TextureCache::addImageAsyncCallBack(<span class="hljs-keyword">float</span> dt)<br>      &#123;<br>      <span class="hljs-built_in">std</span>::<span class="hljs-built_in">deque</span>&lt;ImageInfo*&gt; *imageQueue = _imageInfoQueue;<br><br>          _imageInfoMutex.lock();<br>          <span class="hljs-keyword">if</span> (imagesQueue-&gt;empty()) &#123;<br>          _imageInfoMutex.unlock();<br>          &#125;<br>          <span class="hljs-keyword">else</span> &#123;<br>          ImageInfo *imageInfo = imagesQueue-&gt;front();<br>              imagesQueue-&gt;pop_front();<br>              _imageInfoMutex.unlock();<br><br>              AsyncStruct *asyncStruct = imageInfo-&gt;asyncStruct;<br>              Image *image = imageInfo-&gt;image;<br><br>              <span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&amp; filename = asyncStruct-&gt;filename;<br><br>              Texture2D *texture = <span class="hljs-literal">nullptr</span>;<br>              <span class="hljs-keyword">if</span> (image) &#123;<br>              texture = <span class="hljs-keyword">new</span> Texture2D();<br>                  texture-&gt;initWithImage(image);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> CC_ENABLE_CACHE_TEXTURE_DATA</span><br>      VolatileTextureMgr::addImageTexture(texture, filename);<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>      _textures.insert(<span class="hljs-built_in">std</span>::make_pair(filename, texture));<br>                  texture-&gt;retain();<br>                  texture-&gt;autorelease();<br>              &#125;<br>              <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">auto</span> it = _textures.find(asyncStruct-&gt;filename);<br>                  <span class="hljs-keyword">if</span> (it != _textures.end())<br>                  texture = it-&gt;second;<br>              &#125;<br><br>asyncStruct-&gt;callback(texture);<br>              <span class="hljs-keyword">if</span> (image) &#123;<br>              image-&gt;release();<br>              &#125;<br>              <span class="hljs-keyword">delete</span> asyncStruct;<br>              <span class="hljs-keyword">delete</span> imageInfo;<br><br>              --_asyncRefCount;<br>              <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == _asyncRefCount) &#123;<br>              Director::getInstance()-&gt;getScheduler()-&gt;unschedule(schedule_selector(TextureCache::addImageAsyncCallBack), <span class="hljs-keyword">this</span>);<br>              &#125;<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> cocos2d-x学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>cocos2d-x学习笔记-第一章</title>
      <link href="/2020/03/15/cocos2d-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2020/03/15/cocos2d-x%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>cocos2d-x学习笔记-第一章。</p></blockquote><a id="more"></a><h1 id="第一章-全新的cocos2d-x-3-0"><a href="#第一章-全新的cocos2d-x-3-0" class="headerlink" title="第一章 全新的cocos2d-x 3.0"></a>第一章 全新的cocos2d-x 3.0</h1><ul><li>重新设计了渲染机制。<ul><li>主线程遍历UI树的每一个元素时，不直接调用OpenGL ES进行绘制，而是将每个元素的绘制命令包装成一个RenderCommand对象发送到绘制栈，绘制栈在遍历完场景后才开始绘制。</li><li>将绘制命令从UI树的遍历中分离，多个不同的元素就可以使用相同的绘制命令进行组合。</li><li>将渲染从UI树遍历中分离出来，让架构更灵活，更容易拓展。还可以针对渲染进行优化，如自动批渲染。</li><li>在绘制栈开始绘制前，可以对绘制顺序进行重排（globalZOrdr），提高绘制顺序的自由性。</li><li>Sprite引入了自动裁剪技术，视窗外的Sprite不会发送绘制命令到绘制栈，减少了不必要的OpenGL ES绘制调用。</li></ul></li><li>clone()方法直接返回一个加入自动回收池的对象，调用者不需要手动将其加入自动回收池。</li><li>使用强类型枚举来避免枚举和常量被int型变量替换带来的难以察觉的错误，如用Texture2D::PixelFormat::RGBA8888替代kCCTexture2DPixelFormat_RGBA8888。</li><li>对字体进行了重构，新的Label更加不依赖各种平台，引擎的维护和拓展更加简单。</li><li>统一的事件分发器—-EventDispatcher，既能处理系统提供的事件，也能向EventDispatcher注册自定义的事件类型。支持将一个事件关联到一个UI元素，这个事件将根据该元素在场景中的绘制顺序被分发，事件与Node相关联时，当Node被移除出场景时，与其关联的所有订阅的处理者都会被全部移除，减少手动操作。</li><li>简化了物理引擎的使用方式。<ul><li>物理世界杯集成到Scene元素中，当创建一个场景的时候，可以选择是否创建一个物理世界。通过开启CC_USE_PHYSICS，可以使用与物理集成相关的属性。</li><li>Node元素包含physicsBody属性，使得我们可以对任何Node元素及其子元素设置物理刚体。包含physicsBody的Node元素被添加到场景时，会自动被加入到Scene的物理世界中。</li><li>物理刚体中包含了大多数的物理属性，如PhysicsShape、PhysicsContact。</li><li>可以通过EventListenerPhysicsContact来监听刚体间的碰撞事件。</li><li>程序员只需要处理刚体的定义及逻辑处理部分，关联、管理甚至刚体的移除等工作则由引擎自动处理。</li></ul></li><li>cocos2d-x 3.0提供Vector<t>和Map<k,v>来避免不必要的数据类型转换，且它们是对std库中的vector<t>和unordered_map<k,t>的封装，其能结合cocos2d-x的内存管理方式。这些新容器对右值使用了C++ 11的std::move特性，实现了移动拷贝函数和移动赋值操作符，从而减少了使用右值时一些不必要的临时变量的生成和复制。</k,t></t></k,v></t></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
          <category> cocos2d-x学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cocos </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019年总结</title>
      <link href="/2020/01/05/2019%E5%B9%B4%E6%80%BB%E7%BB%93/"/>
      <url>/2020/01/05/2019%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2019年的简单汇总。</p></blockquote><a id="more"></a><h3 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h3><ul><li>1月：<ul><li>日本旅游。</li><li>碧水湾泡温泉。</li><li>达成 Friend Zone 照片成就。</li></ul></li><li>2月：<ul><li>北京旅游。</li></ul></li><li>5月：<ul><li>入坑王者荣耀。</li></ul></li><li>6月：<ul><li>参加QCon广州。</li></ul></li><li>7月：<ul><li>带爸妈体检。</li></ul></li><li>8月：<ul><li>参加上海CGDC和CJ。</li></ul></li><li>9月：<ul><li>中秋节用椴木层板做了一个阵列灯的外罩，但后续没吧树莓派接上去控制灯光。</li></ul></li><li>10月：<ul><li>西北自驾游，看到了银河，好开心。</li></ul></li><li>12月：<ul><li>通关宝可梦盾，很一般的一作。</li><li>御温泉，并不是很喜欢泡温泉，时间也比较赶，玩狼人杀到凌晨四点，一天下来感觉反而更累了。</li></ul></li></ul><h3 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h3><ul><li>自学完LearnOpenGL课程，课程设计很适合入门者，收益颇多。</li><li>看完《游戏引擎架构》，大体整体结构上能明白理解，但我缺乏实践，没针对一个具体引擎进行剖析分解及实操，仅了解了理论知识。在动画系统一章中，缺乏对动画的了解，导致看得一知半解，未能完全吃透。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 2019随记 </category>
          
          <category> 年度总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>平直Alpha与预乘Alpha</title>
      <link href="/2019/12/01/%E5%B9%B3%E7%9B%B4Alpha%E4%B8%8E%E9%A2%84%E4%B9%98Alpha/"/>
      <url>/2019/12/01/%E5%B9%B3%E7%9B%B4Alpha%E4%B8%8E%E9%A2%84%E4%B9%98Alpha/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关于预乘Alpha的解析，以及平直Alpha和预乘Alpha的使用场景。</p></blockquote><a id="more"></a><h2 id="Alpha通道的概念"><a href="#Alpha通道的概念" class="headerlink" title="Alpha通道的概念"></a>Alpha通道的概念</h2><ul><li>在传统电影合成操作中，为了制作Matte，通常需要两盘独立的胶片，一盘记录运动影像，一盘则记录Matte信息。合成时，需要背景胶片、前景胶片、Matte胶片。也就是说Matte信息和图像信息独立存在。而Catmull/Smith小组开发的Alpha通道概念就方便了很多，而且可以让任何人使用Alpha通道。他们首次推出RGBA概念，即将Alpha通道和RGB通道并列，并一同存储在图像信息中。这样随着一幅图像的建立（这里说的是CGI），其Alpha通道也会随之产生或者存储。这样Alpha通道其实是Matte的概念，但它和图像信息一并存储和移动，这样Matte信息就变成影像的一部分，而不像传统电影合成时，需要单独的一盘胶片提供Matte信息，这也是RGBA的优势所在。有了RGBA的概念，数字合成变得更加轻松容易。当然为了提高合成效率，后来Catmull / Smith小组又在Integral Alpha的基础上提出Premultiplied Alpha。—-百度百科。</li></ul><h2 id="Alpha通道的表示方式"><a href="#Alpha通道的表示方式" class="headerlink" title="Alpha通道的表示方式"></a>Alpha通道的表示方式</h2><ul><li>图像中使用的Alpha通道通常有两种表示形式：平直Alpha（英语：straight alpha）和预乘Alpha（英语：premultiplied alpha）。</li><li>平直Alpha<ul><li>图像中的RGB分量仅表示像素的颜色，与是否透明无关。</li></ul></li><li>预乘Alpha<ul><li>图像中的RGB分量已和不透明度做了乘法。一些场景下，这样的做法可以在后续合成时节省一次乘法。</li></ul></li></ul><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>平直Alpha和预乘Alpha并没有孰优孰劣之说，它们有各自更加适用的场景。</li></ul><h3 id="平直Alpha的限制"><a href="#平直Alpha的限制" class="headerlink" title="平直Alpha的限制"></a>平直Alpha的限制</h3><ul><li><p>混合公式</p><script type="math/tex; mode=display">R = (R_{src} * A_{src} + (1 - A_{src}) * R_{dst} * A_{dst}) / A</script><script type="math/tex; mode=display">G = (G_{src} * A_{src} + (1 - A_{src}) * G_{dst} * A_{dst}) / A</script><script type="math/tex; mode=display">B = (B_{src} * A_{src} + (1 - A_{src}) * B_{dst} * A_{dst}) / A</script><script type="math/tex; mode=display">A = A_{src} + (1 - A_{scr}) * A_{dst}</script></li><li><p>从混合公式中可以看出，RGB与A并不相互独立，它们最终的展现效果都需要A参与计算，因此，插值相关的计算都不能在平直Alpha的图片上进行，如旋转、缩放等操作。</p></li><li><p>在<a href="https://developer.nvidia.com/content/alpha-blending-pre-or-not-pre" target="_blank" rel="noopener">https://developer.nvidia.com/content/alpha-blending-pre-or-not-pre</a> 一文中，给出了平直Alpha不适合进行插值的原因，简单总结如下：</p><ol><li>原图是2X1大小的两个像素点，分别为纯红和纯绿，但纯绿的alpha值为0.1。<ul><li><img src="/2019/12/01/平直Alpha与预乘Alpha/orgpic.png" style="width: 400px;"></li></ul></li><li>对上图求1X1的mipmap的时候，我们会得到下面的结果：<ul><li><img src="/2019/12/01/平直Alpha与预乘Alpha/straight_filter.png" style="width: 200px;"></li><li>原因是我们不仅对RGB进行了线性插值，也对alpha进行了线性插值，但RGB与alpha却又不是相互独立的变量，alpha会影响RGB的表现结果，导致结果与直观效果大相径庭。</li></ul></li><li>我们先将alpha进行预乘，再进行线性求插值，得到的结果与直观感受相符。<ul><li><img src="/2019/12/01/平直Alpha与预乘Alpha/premultiplied_filter.png" style="width: 200px;"></li><li>因为原图alpha参与进了RGB的插值运算当中，所以插值计算出来的结果是与视觉效果相符的。</li></ul></li></ol></li></ul><h3 id="预乘Alpha的限制"><a href="#预乘Alpha的限制" class="headerlink" title="预乘Alpha的限制"></a>预乘Alpha的限制</h3><ul><li><p>混合公式</p><script type="math/tex; mode=display">R = R_{src} + (1 - A_{src}) * R_{dst}</script><script type="math/tex; mode=display">G = G_{src} + (1 - A_{src}) * G_{dst}</script><script type="math/tex; mode=display">B = B_{src} + (1 - A_{src}) * B_{dst}</script><script type="math/tex; mode=display">A = A_{src} + (1 - A_{scr}) * A_{dst}</script></li><li><p>从混合公式中可以看出，原图RGB的混合不再受alpha参数影响，故直接进行RGB调整的变换都不能在预乘Alpha的图片上进行，如ContrastLum、Color-Add等调色行为。</p></li></ul><h2 id="黑边白边问题"><a href="#黑边白边问题" class="headerlink" title="黑边白边问题"></a>黑边白边问题</h2><ul><li><p>产生黑边、白边都是因为使用的软件、算法对图像是否已进行alpha预乘的理解有差异导致。如PS软件认为所有的图片都是平直alpha，而3DSMAX等软件输出的图像则是预乘alpha后的图像，将后者输出的图像直接在PS上进行叠加，则会多了一次乘原图alpha的计算，导致颜色偏暗。</p></li><li><p>简单解析如下（这里只对R分量进行解析，GB分量同理）：</p><ol><li>PS使用的混合公式（平直Alpha）：<script type="math/tex; mode=display">R = R_{src} * A_{src} + (1 - A_{src}) * R_{dst}</script></li><li>3DSMAX使用的混合公式（预乘Alpha）：<script type="math/tex; mode=display">R = R_{src} + (1 - A_{src}) * R_{dst}</script></li><li>在3DSMAX中输出的图是预乘Alpha图，将其还原回平直Alpha，其R值为：<script type="math/tex; mode=display">R = R_{src} * A_{src}</script></li><li>将3中的R套到1中的混合式子中：<script type="math/tex; mode=display">R = R_{src} * A_{src} * A_{src} + (1 - A_{src}) * R_{dst}</script></li><li>可以看出，乘多了一次 $A_{src}$ ，导致图像偏暗。</li><li>由于3D图像输出的时候，在边缘通常会使用抗锯齿技术，因此边缘上的像素的alpha值不是非0即1，而是介于0和1之间，这些抗锯齿产生的像素在进行4中的混合后，便是黑边所在。</li></ol></li></ul><h3 id="黑边的解决方式："><a href="#黑边的解决方式：" class="headerlink" title="黑边的解决方式："></a>黑边的解决方式：</h3><ol><li>输入的图像改回用平直Alpha图，即若输入的图像为预乘Alpha图，对其进行一次逆运算，RGB除以其Alpha值，获得平直Alpha图作为输入。</li><li>对混合的背景图进行一次 $(1 - A_{src})$ 计算，然后混合公式改用直接相加的方式。<ul><li>通过此种方式，混合公式就变为：</li><li><script type="math/tex; mode=display">R = R_{src} + (1 - A_{src}) * R_{dst}</script></li><li>该公式与预乘Alpha的混合公式是相同的。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预乘Alpha </tag>
            
            <tag> 平直Alpha </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019CGDC+CJ</title>
      <link href="/2019/08/30/2019CGDC-CJ/"/>
      <url>/2019/08/30/2019CGDC-CJ/</url>
      
        <content type="html"><![CDATA[<blockquote><p>2019CGDC、2019CJ、让游戏变香、让游戏变稳的一些方法。</p></blockquote><a id="more"></a><p><a href="/2019/08/30/2019CGDC-CJ/2019CGDC.pptx">2019CGDC.pptx</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CGDC </tag>
            
            <tag> CJ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>屏幕空间环境光遮蔽</title>
      <link href="/2019/06/09/%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%8E%AF%E5%A2%83%E5%85%89%E9%81%AE%E8%94%BD/"/>
      <url>/2019/06/09/%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E7%8E%AF%E5%A2%83%E5%85%89%E9%81%AE%E8%94%BD/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> SSAO学习笔记</p></blockquote><ul><li><img src="/2019/06/09/屏幕空间环境光遮蔽/without_ssao.png" alt=""></li><li><img src="/2019/06/09/屏幕空间环境光遮蔽/with_ssao.png" alt=""></li></ul><a id="more"></a><hr><h2 id="环境光遮蔽"><a href="#环境光遮蔽" class="headerlink" title="环境光遮蔽"></a>环境光遮蔽</h2><ul><li>在之前的光照模型中，我们一直用漫反射乘以一个较小的常数来模拟环境光的散射，然而，在现实世界中，物体的散射并不是一成不变的，在背光面，褶皱处，它们会更加的暗。环境光遮蔽(Ambient Occlusion)，它的原理是通过将褶皱、孔洞和非常靠近的墙面变暗的方法近似模拟出间接光照。这些区域很大程度上是被周围的几何体遮蔽的，光线会很难流失，所以这些地方看起来会更暗一些。</li><li>环境光遮蔽这一技术会带来很大的性能开销，因为它还需要考虑周围的几何体。我们可以对空间中每一点发射大量光线来确定其遮蔽量，但是这在实时运算中会很快变成大问题。</li></ul><h2 id="屏幕空间环境光遮蔽-SSAO"><a href="#屏幕空间环境光遮蔽-SSAO" class="headerlink" title="屏幕空间环境光遮蔽(SSAO)"></a>屏幕空间环境光遮蔽(SSAO)</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>对于铺屏四边形(Screen-filled Quad)上的每一个片段，我们都会根据周边深度值计算一个遮蔽因子(Occlusion Factor)。这个遮蔽因子之后会被用来减少或者抵消片段的环境光照分量。遮蔽因子是通过采集片段周围球型核心(Kernel)的多个深度样本，并和当前片段深度值对比而得到的。高于片段深度值样本的个数就是我们想要的遮蔽因子。</li></ul><p><img src="/2019/06/09/屏幕空间环境光遮蔽/ssao_crysis_circle.png" style="width: 400px;"></p><ul><li>上图中在几何体内灰色的深度样本都是高于片段深度值的，他们会增加遮蔽因子；几何体内样本个数越多，片段获得的环境光照也就越少。</li><li>使用球体作为采样核心容易使得显示效果灰蒙蒙，因为在法线背面的样本都在增加遮蔽因子。因此，我们将使用一个沿着表面法向量的半球体采样核心。</li></ul><p><img src="/2019/06/09/屏幕空间环境光遮蔽/ssao_hemisphere.png" style="width: 400px;"></p><ul><li>为了降低计算消耗，会使用随机性的采样核心(Sample Kernel)进行采样，从而减少样本的数目。再通过随机旋转采样核心，我们能在有限样本数量中得到高质量的结果。然而这仍然会有一定的麻烦，因为随机性引入了一个很明显的噪声图案，我们将需要通过模糊结果来修复这一问题。</li></ul><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul><li>SSAO的过程与延迟着色法相似，只是在最后处理光照部分需要加入对遮蔽因子的处理。因此这里最主要的问题便是如何计算遮蔽因子。遮蔽因子将存放于纹理附件中，供最终处理光照时使用。</li><li>对于一个片段，我们需要以下的数据来计算出其遮蔽因子：<ol><li>逐片段的 <em>位置</em> 向量。</li><li>逐片段的 <em>法线</em> 向量。</li><li><em>采样核心</em> 。</li><li>用来旋转采样核心的随机旋转矢量（ <em>噪声纹理</em> ）。</li></ol></li><li>位置向量和法线向量于延迟着色中的做法相似，直接计算输出到G缓冲中即可，需要注意的是要统一空间，这里将它们统一为观察空间输出。</li></ul><h4 id="采样核心"><a href="#采样核心" class="headerlink" title="采样核心"></a>采样核心</h4><ul><li>我们需要沿着表面法线方向生成大量的样本。由于对每个表面法线方向生成采样核心非常困难，也不合实际，我们将在切线空间(Tangent Space)内生成采样核心，法向量将指向正z方向。</li><li>随机的采样核心会在片段周围平均的进行采样，为了越靠近片段有越多的采样，这里对随机到的采样点乘以一个系数，让它们更多的靠近原片段。</li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::uniform_real_distribution&lt;GLfloat&gt; randomFloats(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// generates random floats between 0.0 and 1.0</span><br><span class="hljs-built_in">std</span>::default_random_engine generator;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;glm::vec3&gt; ssaoKernel;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i) &#123;<br>glm::<span class="hljs-function">vec3 <span class="hljs-title">sample</span><span class="hljs-params">(randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>, randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>, randomFloats(generator))</span></span>;<br>sample = glm::normalize(sample);<br>sample * = randomFloats(generator);<br><span class="hljs-keyword">float</span> scale = <span class="hljs-keyword">float</span>(i) / <span class="hljs-number">64.0</span>;<br><br><span class="hljs-comment">// scale samples s.t. they're more aligned to center of kernel</span><br>scale = <span class="hljs-number">0.1</span> + scale * scale * (<span class="hljs-number">1.0f</span> - <span class="hljs-number">0.1f</span>);<br>sample * = scale;<br>ssaoKernel.push_back(sample);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2019/06/09/屏幕空间环境光遮蔽/ssao_kernel_weight.png" style="width: 700px;"></p><h4 id="噪声纹理"><a href="#噪声纹理" class="headerlink" title="噪声纹理"></a>噪声纹理</h4><ul><li>通过引入一些随机性到采样核心上，我们可以大大减少获得不错结果所需的样本数量。我们可以对场景中每一个片段创建一个随机旋转向量，但这会很快将内存耗尽。所以，更好的方法是创建一个小的随机旋转向量纹理平铺在屏幕上。</li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;glm::vec3&gt; ssaoNoise;<br><span class="hljs-keyword">for</span> (GLuint i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++)<br>&#123;<br>glm::<span class="hljs-function">vec3 <span class="hljs-title">noise</span><span class="hljs-params">(<br>randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>,<br>randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>,<br><span class="hljs-number">0.0f</span>)</span></span>;<br>ssaoNoise.push_back(noise);<br>&#125;<br><br>GLuint noiseTexture;<br>glGenTextures(<span class="hljs-number">1</span>, &amp;noiseTexture);<br>glBindTexture(GL_TEXTURE_2D, noiseTexture);<br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB16F, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, GL_RGB, GL_FLOAT, &amp;ssaoNoise[<span class="hljs-number">0</span>]);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br></code></pre></td></tr></table></figure><h3 id="SSAO着色器"><a href="#SSAO着色器" class="headerlink" title="SSAO着色器"></a>SSAO着色器</h3><ul><li>为了对每一个屏幕上的片段都生成一个遮蔽值，并将该值存在纹理中，这里需要再使用一个帧缓冲对象用于缓存临时结果，供最后光照处理阶段使用。</li><li>由于环境遮蔽的结果是一个灰度值，我们将只需要纹理的红色分量，所以我们将颜色缓冲的内部格式设置为 <em>GL_RED</em> 。</li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">GLuint ssaoFBO;<br>glGenFramebuffers(<span class="hljs-number">1</span>, &amp;ssaoFBO);  <br>glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO);<br>GLuint ssaoColorBuffer;<br><br>glGenTextures(<span class="hljs-number">1</span>, &amp;ssaoColorBuffer);<br>glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer);<br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number">0</span>, GL_RGB, GL_FLOAT, <span class="hljs-literal">NULL</span>);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBuffer, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li>其完整渲染过程大致如下：</li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 几何处理阶段: 渲染到G缓冲中</span><br>glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);<br>[...]<br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);  <br><br><span class="hljs-comment">// 使用G缓冲渲染SSAO纹理</span><br>glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO);<br>glClear(GL_COLOR_BUFFER_BIT);<br>ssaoShader.Use();<br>glActiveTexture(GL_TEXTURE0);<br>glBindTexture(GL_TEXTURE_2D, gPosition);<br>glActiveTexture(GL_TEXTURE1);<br>glBindTexture(GL_TEXTURE_2D, gNormal);<br>glActiveTexture(GL_TEXTURE2);<br>glBindTexture(GL_TEXTURE_2D, noiseTexture);<br>SendKernelSamplesToShader();<br>glUniformMatrix4fv(projLocation, <span class="hljs-number">1</span>, GL_FALSE, glm::value_ptr(projection));<br>RenderQuad();<br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 光照处理阶段: 渲染场景光照</span><br>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>shaderLightingPass.Use();<br>[...]<br>glActiveTexture(GL_TEXTURE3);<br>glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer);<br>[...]<br>RenderQuad();<br></code></pre></td></tr></table></figure><ul><li>ssao的片段着色器实现如下：</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">float</span> FragColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> TexCoords;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> gPosition;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> gNormal;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texNoise;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> samples[<span class="hljs-number">64</span>];<br><br><span class="hljs-type">int</span> kernelSize = <span class="hljs-number">64</span>;<br><span class="hljs-type">float</span> radius = <span class="hljs-number">0.5</span>;<br><span class="hljs-type">float</span> bias = <span class="hljs-number">0.025</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">vec2</span> noiseScale = <span class="hljs-type">vec2</span>(<span class="hljs-number">800.0</span> / <span class="hljs-number">4.0</span>, <span class="hljs-number">400.0</span> / <span class="hljs-number">4.0</span>);<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-type">vec3</span> fragPos = <span class="hljs-built_in">texture</span>(gPosition, TexCoords).rgb;<br><span class="hljs-type">vec3</span> normal = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">texture</span>(gNormal, TexCoords).rgb);<br><span class="hljs-type">vec3</span> randomVec = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">texture</span>(texNoise, TexCoords * noiseScale).xyz);<br><br><span class="hljs-type">vec3</span> tangent = <span class="hljs-built_in">normalize</span>(randomVec - normal * <span class="hljs-built_in">dot</span>(randomVec, normal));<br>    <span class="hljs-type">vec3</span> bitangent = <span class="hljs-built_in">cross</span>(normal, tangent);<br>    <span class="hljs-type">mat3</span> TBN = <span class="hljs-type">mat3</span>(tangent, bitangent, normal);<br><br><span class="hljs-type">float</span> occlusion = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kernelSize; ++i) &#123;<br>        <span class="hljs-comment">// get sample position</span><br>        <span class="hljs-type">vec3</span> <span class="hljs-keyword">sample</span> = TBN * samples[i]; <span class="hljs-comment">// from tangent to view-space</span><br>        <span class="hljs-keyword">sample</span> = fragPos + <span class="hljs-keyword">sample</span> * radius;<br><br>        <span class="hljs-comment">// project sample position (to sample texture) (to get position on screen/texture)</span><br>        <span class="hljs-type">vec4</span> <span class="hljs-keyword">offset</span> = <span class="hljs-type">vec4</span>(<span class="hljs-keyword">sample</span>, <span class="hljs-number">1.0</span>);<br>        <span class="hljs-keyword">offset</span> = projection * <span class="hljs-keyword">offset</span>; <span class="hljs-comment">// from view to clip-space</span><br>        <span class="hljs-keyword">offset</span>.xyz /= <span class="hljs-keyword">offset</span>.w; <span class="hljs-comment">// perspective divide</span><br>        <span class="hljs-keyword">offset</span>.xyz = <span class="hljs-keyword">offset</span>.xyz * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>; <span class="hljs-comment">// transform to range 0.0 - 1.0</span><br><br>        <span class="hljs-comment">// get sample depth</span><br>        <span class="hljs-type">float</span> sampleDepth = <span class="hljs-built_in">texture</span>(gPosition, <span class="hljs-keyword">offset</span>.xy).z; <span class="hljs-comment">// get depth value of kernel sample</span><br><br>        <span class="hljs-comment">// range check &amp; accumulate</span><br>        <span class="hljs-type">float</span> rangeCheck = <span class="hljs-built_in">smoothstep</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, radius / <span class="hljs-built_in">abs</span>(fragPos.z - sampleDepth));<br>        occlusion += (sampleDepth &gt;= <span class="hljs-keyword">sample</span>.z + bias ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>) * rangeCheck;<br>    &#125;<br>    occlusion = <span class="hljs-number">1.0</span> - (occlusion / kernelSize);<br><br>    FragColor = occlusion;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">const</span> <span class="hljs-type">vec2</span> noiseScale = <span class="hljs-type">vec2</span>(<span class="hljs-number">800.0</span> / <span class="hljs-number">4.0</span>, <span class="hljs-number">400.0</span> / <span class="hljs-number">4.0</span>);<br><span class="hljs-type">vec3</span> randomVec = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">texture</span>(texNoise, TexCoords * noiseScale).xyz);<br></code></pre></td></tr></table></figure><ul><li>由于噪声纹理只为4X4的大小，通过REPEAT的方式将屏幕铺满，故在采样时需要乘上对应的缩放比率，缩放比率为屏幕大小除以噪声纹理大小。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec3</span> fragPos = <span class="hljs-built_in">texture</span>(gPosition, TexCoords).rgb;<br><span class="hljs-type">vec3</span> normal = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">texture</span>(gNormal, TexCoords).rgb);<br><span class="hljs-type">vec3</span> randomVec = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">texture</span>(texNoise, TexCoords * noiseScale).xyz);<br><br><span class="hljs-type">vec3</span> tangent = <span class="hljs-built_in">normalize</span>(randomVec - normal * <span class="hljs-built_in">dot</span>(randomVec, normal));<br><span class="hljs-type">vec3</span> bitangent = <span class="hljs-built_in">cross</span>(normal, tangent);<br><span class="hljs-type">mat3</span> TBN = <span class="hljs-type">mat3</span>(tangent, bitangent, normal);<br></code></pre></td></tr></table></figure><ul><li>这里使用一个随机的向量来构造切线向量来构建TBN矩阵，没有使用沿着几何体表面的TBN矩阵。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> occlusion = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kernelSize; ++i) &#123;<br>    <span class="hljs-comment">// get sample position</span><br>    <span class="hljs-type">vec3</span> <span class="hljs-keyword">sample</span> = TBN * samples[i]; <span class="hljs-comment">// from tangent to view-space</span><br>    <span class="hljs-keyword">sample</span> = fragPos + <span class="hljs-keyword">sample</span> * radius;<br><br>    <span class="hljs-comment">// project sample position (to sample texture) (to get position on screen/texture)</span><br>    <span class="hljs-type">vec4</span> <span class="hljs-keyword">offset</span> = <span class="hljs-type">vec4</span>(<span class="hljs-keyword">sample</span>, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-keyword">offset</span> = projection * <span class="hljs-keyword">offset</span>; <span class="hljs-comment">// from view to clip-space</span><br>    <span class="hljs-keyword">offset</span>.xyz /= <span class="hljs-keyword">offset</span>.w; <span class="hljs-comment">// perspective divide</span><br>    <span class="hljs-keyword">offset</span>.xyz = <span class="hljs-keyword">offset</span>.xyz * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>; <span class="hljs-comment">// transform to range 0.0 - 1.0</span><br><br>    <span class="hljs-comment">// get sample depth</span><br>    <span class="hljs-type">float</span> sampleDepth = <span class="hljs-built_in">texture</span>(gPosition, <span class="hljs-keyword">offset</span>.xy).z; <span class="hljs-comment">// get depth value of kernel sample</span><br><br>    <span class="hljs-comment">// range check &amp; accumulate</span><br>    <span class="hljs-type">float</span> rangeCheck = <span class="hljs-built_in">smoothstep</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, radius / <span class="hljs-built_in">abs</span>(fragPos.z - sampleDepth));<br>    occlusion += (sampleDepth &gt;= <span class="hljs-keyword">sample</span>.z + bias ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>) * rangeCheck;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>这里的kernelSize和radius变量都可以用来调整效果；在这里我们分别保持他们的默认值为64和1.0。对于每一次迭代我们首先变换各自样本到观察空间。之后我们会加观察空间核心偏移样本到观察空间片段位置上；最后再用radius乘上偏移样本来增加(或减少)SSAO的有效取样半径。</p></li><li><p>接下来我们变换sample到屏幕空间，从而我们可以就像正在直接渲染它的位置到屏幕上一样取样sample的(线性)深度值。由于这个向量目前在观察空间，我们将首先使用projection矩阵uniform变换它到裁剪空间。在变量被变换到裁剪空间之后，我们用xyz分量除以w分量进行透视划分。结果所得的标准化设备坐标之后变换到[0.0, 1.0]范围以便我们使用它们去取样深度纹理。</p></li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl">occlusion += (sampleDepth &gt;= <span class="hljs-keyword">sample</span>.z ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>);<br></code></pre></td></tr></table></figure><ul><li>接下来可以直接检查样本的当前深度值是否大于存储的深度值，如果是的，添加到最终的贡献因子上。</li><li>但在检测一个靠近表面边缘的片段时，它将会考虑测试表面之下的表面的深度值；这些值将会(不正确地)影响遮蔽因子。</li></ul><p><img src="/2019/06/09/屏幕空间环境光遮蔽/without_smoothstep.png" style="width: 600px;"></p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> rangeCheck = <span class="hljs-built_in">smoothstep</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, radius / <span class="hljs-built_in">abs</span>(fragPos.z - sampleDepth));<br>occlusion += (sampleDepth &gt;= <span class="hljs-keyword">sample</span>.z + bias ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>) * rangeCheck;<br></code></pre></td></tr></table></figure><ul><li>最后一步替换使用了GLSL的smoothstep函数，它非常光滑地在第一和第二个参数范围内插值了第三个参数。如果深度差因此最终取值在radius之间，它们的值将会光滑地根据下面这个曲线插值在0.0和1.0之间：</li></ul><p><img src="/2019/06/09/屏幕空间环境光遮蔽/ssao_smoothstep.png" style="width: 400px;"><br><img src="/2019/06/09/屏幕空间环境光遮蔽/with_smoothstep.png" style="width: 600px;"></p><h3 id="环境遮蔽模糊"><a href="#环境遮蔽模糊" class="headerlink" title="环境遮蔽模糊"></a>环境遮蔽模糊</h3><ul><li>直接使用SSAO的结果会发现噪声较为严重，从图中能看到阴影呈现格子块状，故需要在SSAO阶段和光照处理阶段中间插入对SSAO进行模糊的处理。因而需要再创建一个帧缓冲来保存模糊结果。</li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">GLuint ssaoBlurFBO, ssaoColorBufferBlur;<br>glGenFramebuffers(<span class="hljs-number">1</span>, &amp;ssaoBlurFBO);<br>glBindFramebuffer(GL_FRAMEBUFFER, ssaoBlurFBO);<br>glGenTextures(<span class="hljs-number">1</span>, &amp;ssaoColorBufferBlur);<br>glBindTexture(GL_TEXTURE_2D, ssaoColorBufferBlur);<br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number">0</span>, GL_RGB, GL_FLOAT, <span class="hljs-literal">NULL</span>);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBufferBlur, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> TexCoords;<br><span class="hljs-keyword">out</span> <span class="hljs-type">float</span> fragColor;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> ssaoInput;<br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-type">vec2</span> texelSize = <span class="hljs-number">1.0</span> / <span class="hljs-type">vec2</span>(<span class="hljs-built_in">textureSize</span>(ssaoInput, <span class="hljs-number">0</span>));<br>    <span class="hljs-type">float</span> result = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">-2</span>; x &lt; <span class="hljs-number">2</span>; ++x)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">-2</span>; y &lt; <span class="hljs-number">2</span>; ++y)<br>        &#123;<br>            <span class="hljs-type">vec2</span> <span class="hljs-keyword">offset</span> = <span class="hljs-type">vec2</span>(<span class="hljs-type">float</span>(x), <span class="hljs-type">float</span>(y)) * texelSize;<br>            result += <span class="hljs-built_in">texture</span>(ssaoInput, TexCoords + <span class="hljs-keyword">offset</span>).r;<br>        &#125;<br>    &#125;<br>    fragColor = result / (<span class="hljs-number">4.0</span> * <span class="hljs-number">4.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>这里我们遍历了周围在-2.0和2.0之间的SSAO纹理单元(Texel)，采样与噪声纹理维度相同数量的SSAO纹理。我们通过使用返回vec2纹理维度的textureSize，根据纹理单元的真实大小偏移了每一个纹理坐标。我们平均所得的结果，获得一个简单但是有效的模糊效果：</li></ul><p><img src="/2019/06/09/屏幕空间环境光遮蔽/ssao_blur.png" style="width: 600px;"></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ul><li>在最终处理光照阶段对环境光加上遮蔽值的影响即可。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> AmbientOcclusion = <span class="hljs-built_in">texture</span>(ssao, TexCoords).r;<br><span class="hljs-type">vec3</span> ambient = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.3</span> * Diffuse * AmbientOcclusion);<br></code></pre></td></tr></table></figure><p><img src="/2019/06/09/屏幕空间环境光遮蔽/with_ssao.png" style="width: 600px;"></p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 屏幕空间环境光遮蔽 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> 屏幕空间环境光遮蔽 </tag>
            
            <tag> SSAO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>延迟着色法</title>
      <link href="/2019/06/08/%E5%BB%B6%E8%BF%9F%E7%9D%80%E8%89%B2%E6%B3%95/"/>
      <url>/2019/06/08/%E5%BB%B6%E8%BF%9F%E7%9D%80%E8%89%B2%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 延迟着色法学习笔记</p></blockquote><ul><li><img src="/2019/06/08/延迟着色法/result.png" alt=""></li></ul><a id="more"></a><h3 id="延迟着色法-Deferred-Shading"><a href="#延迟着色法-Deferred-Shading" class="headerlink" title="延迟着色法(Deferred Shading)"></a>延迟着色法(Deferred Shading)</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><em>延迟着色法(Deferred Shading)</em> ，或者说是 <em>延迟渲染(Deferred Rendering)</em> 是为了解决 <em>正向渲染(Forward Rendering)</em> 中对每一个片段都需要遍历所有的光源进行迭代，而其中大部分片段着色器的输出都会被之后的输出覆盖，造成大量的计算浪费而提出的一种高效的渲染方式。</li></ul><h4 id="延迟着色原理"><a href="#延迟着色原理" class="headerlink" title="延迟着色原理"></a>延迟着色原理</h4><ul><li>延迟着色法基于我们延迟(Defer)或推迟(Postpone)大部分计算量非常大的渲染(像是光照)到后期进行处理的想法。</li><li><p>它包含两个处理阶段(Pass)：</p><ol><li><p>在第一个几何处理阶段(Geometry Pass)中，我们先渲染场景一次，之后获取对象的各种几何信息，并储存在一系列叫做G缓冲(G-buffer)的纹理中；像位置向量(Position Vector)、颜色向量(Color Vector)、法向量(Normal Vector)和/或镜面值(Specular Value)。场景中这些储存在G缓冲中的几何信息将会在之后用来做(更复杂的)光照计算。</p></li><li><p>第二个光照处理阶段(Lighting Pass)中使用G缓冲内的纹理数据。在光照处理阶段中，我们渲染一个屏幕大小的方形，并使用G缓冲中的几何数据对每一个片段计算场景的光照；在每个像素中我们都会对G缓冲进行迭代。我们对于渲染过程进行解耦，将它高级的片段处理挪到后期进行，而不是直接将每个对象从顶点着色器带到片段着色器。光照计算过程还是和以前一样，但是现在需要从对应的G缓冲而不是顶点着色器(和一些uniform变量)那里获取输入变量了。</p></li></ol></li><li><p><img src="/2019/06/08/延迟着色法/deferred_g_buffer.png" alt="G缓冲内容"></p></li><li><p><img src="/2019/06/08/延迟着色法/deferred_overview.png" alt="延迟着色法过程"></p></li><li><p>优点：</p><ol><li><p>这种渲染方法一个很大的好处就是能保证在G缓冲中的片段和在屏幕上呈现的像素所包含的片段信息是一样的，因为深度测试已经最终将这里的片段信息作为最顶层的片段。这样保证了对于在光照处理阶段中处理的每一个像素都只处理一次，所以我们能够省下很多无用的渲染调用。</p></li><li><p>除此之外，延迟渲染还允许我们做更多的优化，从而渲染更多的光源。</p></li><li><p>在几何处理阶段中填充G缓冲非常高效，因为我们直接储存像是位置，颜色或者是法线等对象信息到帧缓冲中，而这几乎不会消耗处理时间。在此基础上使用多渲染目标(Multiple Render Targets, MRT)技术，我们甚至可以在一个渲染处理之内完成这所有的工作。</p></li></ol></li><li><p>缺陷：</p><ol><li><p>由于G缓冲要求我们在纹理颜色缓冲中存储相对比较大的场景数据，这会消耗比较多的显存，尤其是类似位置向量之类的需要高精度的场景数据。</p></li><li><p>不支持混色(因为我们只有最前面的片段信息)， 因此也不能使用MSAA了。</p></li></ol></li></ul><hr><h3 id="G缓冲和延迟渲染"><a href="#G缓冲和延迟渲染" class="headerlink" title="G缓冲和延迟渲染"></a>G缓冲和延迟渲染</h3><ul><li><p>G缓冲(G-buffer)是对所有用来储存光照相关的数据，并在最后的光照处理阶段中使用的所有纹理的总称。因此，G缓冲中需要有正向渲染中光照所用到的所有数据：</p><ol><li>一个3D位置向量来计算(插值)片段位置变量供lightDir和viewDir使用</li><li>一个RGB漫反射颜色向量，也就是反照率(Albedo)</li><li>一个3D法向量来判断平面的斜率</li><li>一个镜面强度(Specular Intensity)浮点值</li><li>所有光源的位置和颜色向量</li><li>观察者的位置向量</li></ol></li><li><p>对于在每个片段上都相同的值，如光源位置、颜色、观察者位置这些，我们可以通过uniform来设置。对于在每个片段上都不同的值，如漫反射颜色、镜面强度等，我们则通过纹理贴图来存储，这样，我们只需要在最后阶段绘制一个矩形，它从纹理贴图中来采样RGB漫反射颜色，反照率、法向量等数据，进而进行绘制。</p></li><li>大致过程如下：</li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(...) <span class="hljs-comment">// 游戏循环</span><br>&#123;<br>    <span class="hljs-comment">// 1. 几何处理阶段：渲染所有的几何/颜色数据到G缓冲</span><br>    glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);<br>    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>    gBufferShader.Use();<br>    <span class="hljs-keyword">for</span>(Object obj : Objects)<br>    &#123;<br>        ConfigureShaderTransformsAndUniforms();<br>        obj.Draw();<br>    &#125;  <br>    <span class="hljs-comment">// 2. 光照处理阶段：使用G缓冲计算场景的光照</span><br>    glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br>    glClear(GL_COLOR_BUFFER_BIT);<br>    lightingPassShader.Use();<br>    BindAllGBufferTextures();<br>    SetLightingUniforms();<br>    RenderQuad();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>将位置、法线、颜色、镜面值等存储于多个目标纹理缓冲中可以使用多渲染目标(Multiple Render Targets)方式。</li><li>因为有光照计算，需要保证所有变量在一个坐标空间。将它们在世界空间中存储(并计算)所有的变量是一种较方便的方式。</li></ul><hr><h3 id="结合延迟渲染与正向渲染"><a href="#结合延迟渲染与正向渲染" class="headerlink" title="结合延迟渲染与正向渲染"></a>结合延迟渲染与正向渲染</h3><ul><li><p>若想要渲染每一个光源为一个3D立方体，并放置在光源的位置上随着延迟渲染器一起发出光源的颜色。那么在处理完光照阶段后，还需要再将这些立方体绘制上去。不利用之前在G缓冲中的深度信息直接绘制立方体的话，所有立方体都会置于最前，丢失与原场景中物体交错的层次。</p></li><li><p><img src="/2019/06/08/延迟着色法/without_deep.png" alt="未使用G缓冲的深度信息"></p></li><li><p>OpenGL提供直接将帧缓冲中的数据拷贝至另一个帧缓冲中的方法，通过这种方式，便可以方便的将G缓冲中的深度信息单独拷贝至默认缓冲中。</p></li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">glBindFramebuffer(GL_READ_FRAMEBUFFER, gBuffer);<br>glBindFramebuffer(GL_DRAW_FRAMEBUFFER, <span class="hljs-number">0</span>); <span class="hljs-comment">// 写入到默认帧缓冲</span><br>glBlitFramebuffer(<br>  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCR_WIDTH, SCR_HEIGHT, GL_DEPTH_BUFFER_BIT, GL_NEAREST<br>);<br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li>这种方式需要两个缓冲的内部格式一致才可成功复制，若无法成功复制，则需要将深度信息输出到另一张纹理中（就如在阴影中使用的方式），供渲染时采样使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 延迟着色法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> 延迟着色法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>QCon2019广州</title>
      <link href="/2019/06/02/QCon2019%E5%B9%BF%E5%B7%9E/"/>
      <url>/2019/06/02/QCon2019%E5%B9%BF%E5%B7%9E/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Service Mesh、小游戏质量测试、基于C++的跨平台开发框架</p></blockquote><a id="more"></a><p><a href="/2019/06/02/QCon2019广州/QCon收获.pptx">QCon收获.pptx</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> QCon </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HDR和泛光</title>
      <link href="/2019/05/19/HDR%E5%92%8C%E6%B3%9B%E5%85%89/"/>
      <url>/2019/05/19/HDR%E5%92%8C%E6%B3%9B%E5%85%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> HDR和泛光学习笔记</p><p>HDR 和 泛光。</p><p><img src="/2019/05/19/HDR和泛光/result.png" alt=""></p></blockquote><a id="more"></a><h2 id="HDR"><a href="#HDR" class="headerlink" title="HDR"></a>HDR</h2><ul><li>一般的，存储在帧缓冲中的亮度和颜色是以8bits存储，大小被限制在0.0到1.0之间。</li><li>亮度被限制在1.0以下，导致超过1.0的亮度都被截断为1.0，在亮度普遍较大的场景中，容易导致场景亮度混乱，难以分辨。</li><li><img src="/2019/05/19/HDR和泛光/overlight.png" alt="暴亮"></li><li>显示器被限制为只能显示值为0.0到1.0间的颜色，但是在光照方程中却没有这个限制。可以修改帧缓冲的格式，让片段的颜色超过1.0，从而获得一个更大的颜色范围，这也被称作HDR(High Dynamic Range, 高动态范围)。</li></ul><h3 id="浮点帧缓冲"><a href="#浮点帧缓冲" class="headerlink" title="浮点帧缓冲"></a>浮点帧缓冲</h3><ul><li>为了让帧缓冲中存储的亮度突破1.0的限制，需要使用专门用来存储被拓展范围的浮点格式。如：<em>GL_RGB16F</em>, <em>GL_RGBA16F</em>, <em>GL_RGB32F</em> 和 <em>GL_RGBA32F</em>，这些缓冲被称为浮点帧缓冲。</li><li>使用浮点只需要改下帧缓冲类型即可，其他使用与使用GL_RGB没什么不同。</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glBindTexture(GL_TEXTURE_2D, colorBuffer);<br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number">0</span>, GL_RGB, GL_FLOAT, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h3 id="色调映射"><a href="#色调映射" class="headerlink" title="色调映射"></a>色调映射</h3><ul><li>使用浮点帧缓冲后，亮度突破了1.0的限制，但显示器依旧会将亮度限制在1.0以内，这时候就需要一个将突破1.0颜色/亮度映射回[0.0, 1.0]之中的方法，色调映射便是这种方法的名称。</li></ul><h4 id="Reinhard色调映射"><a href="#Reinhard色调映射" class="headerlink" title="Reinhard色调映射"></a>Reinhard色调映射</h4><ul><li>Reinhard色调映射算法平均得将所有亮度值分散到LDR上，使用Reinhard后，明亮场景的细节损失减少，但暗区域的精细程都也下降。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> gamma = <span class="hljs-number">2.2</span>;<br>    <span class="hljs-type">vec3</span> hdrColor = <span class="hljs-built_in">texture</span>(hdrBuffer, TexCoords).rgb;<br><br>    <span class="hljs-comment">// Reinhard色调映射</span><br>    <span class="hljs-type">vec3</span> mapped = hdrColor / (hdrColor + <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>));<br>    <span class="hljs-comment">// Gamma校正</span><br>    mapped = <span class="hljs-built_in">pow</span>(mapped, <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span> / gamma));<br><br>    color = <span class="hljs-type">vec4</span>(mapped, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><img src="/2019/05/19/HDR和泛光/reinhard.png" alt="Reinhard色调映射"></li></ul><h4 id="Exposure色调映射"><a href="#Exposure色调映射" class="headerlink" title="Exposure色调映射"></a>Exposure色调映射</h4><ul><li>平时拍照的时候，在过亮场景（如正对太阳），我们会降低曝光度，在幽暗的场景（如夜间江水），我们会提高曝光度。通过对曝光度的调整，我们能更进一步拍到辨识度更好的照片。这在HDR的色调映射也同样适用。</li><li>一个简单的曝光色调映射如下：</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> exposure;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> gamma = <span class="hljs-number">2.2</span>;<br>    <span class="hljs-type">vec3</span> hdrColor = <span class="hljs-built_in">texture</span>(hdrBuffer, TexCoords).rgb;<br><br>    <span class="hljs-comment">// 曝光色调映射</span><br>    <span class="hljs-type">vec3</span> mapped = <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>) - <span class="hljs-built_in">exp</span>(-hdrColor * exposure);<br>    <span class="hljs-comment">// Gamma校正</span><br>    mapped = <span class="hljs-built_in">pow</span>(mapped, <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span> / gamma));<br><br>    color = <span class="hljs-type">vec4</span>(mapped, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><img src="/2019/05/19/HDR和泛光/exposure.png" alt="不同曝光度下的Exposure色调映射"></li></ul><hr><h2 id="泛光"><a href="#泛光" class="headerlink" title="泛光"></a>泛光</h2><ul><li><img src="/2019/05/19/HDR和泛光/sunrise.jpg" alt="日出"></li><li>光源的明亮很难表达出来，但日常生活给我们的经验是，明亮的光源伴有光晕，如上图日出照片一般，我们看到的不是一个白色的圆圈，而是一个有很大光晕的光源，有大光晕能让我们观察出该物体的亮度很大。</li><li>泛光可以使所有明亮区域产生光晕效果，通过泛光，便能使得光源的亮度在观察上看起来很亮。</li></ul><h3 id="泛光与HDR间的关系"><a href="#泛光与HDR间的关系" class="headerlink" title="泛光与HDR间的关系"></a>泛光与HDR间的关系</h3><ul><li>泛光与HDR是两个相互独立的技术，但是泛光常与HDR结合使用，因为亮度不被限制在1.0以内能有更好的表现。</li></ul><h3 id="泛光的实现方式"><a href="#泛光的实现方式" class="headerlink" title="泛光的实现方式"></a>泛光的实现方式</h3><ul><li>从泛光的目的出发，泛光是为了给亮度高的地方添加光晕效果，那么泛光的过程便是一个直白的沿着目的走的方式。</li></ul><ol><li>首先我们绘制出场景：<ul><li><img src="/2019/05/19/HDR和泛光/scene.png" alt="具有不同光源的场景"></li></ul></li><li>提取出所有亮度高的颜色区域：<ul><li><img src="/2019/05/19/HDR和泛光/light.png" alt="高亮度区域"></li></ul></li><li>给高亮度区域添加模糊效果：<ul><li><img src="/2019/05/19/HDR和泛光/bloom_light.png" alt="具有不同光源的场景"></li></ul></li><li>将高亮度区域叠加回原场景：<ul><li><img src="/2019/05/19/HDR和泛光/result.png" alt="具有不同光源的场景"></li></ul></li></ol><h3 id="提取高亮度区域"><a href="#提取高亮度区域" class="headerlink" title="提取高亮度区域"></a>提取高亮度区域</h3><ul><li>为了提取高亮度区域，我们需要将相同场景绘制两次，分别用不同的片段着色器渲染至不同的帧缓冲中。但OpenGL中允许多渲染目标MRT（Multiple Render Targets），可以在一个单独的渲染处理中提取两张纹理。</li><li>提取两张纹理需要一定的步骤：<ol><li>给帧缓冲附加两个颜色附件。</li><li>显式告知OpenGL我们正在通过glDrawBuffers渲染到多个颜色缓冲。</li><li>片段着色器中通过location标识符来声明多个颜色缓冲。</li><li>根据情况决定输出到多个颜色缓冲中的值。</li></ol></li><li>这也说明了为什么泛光在HDR基础上能够运行得很好。因为HDR中，我们可以将颜色值指定超过1.0这个默认的范围，我们能够得到对一个图像中的亮度的更好的控制权。没有HDR我们必须将阈限设置为小于1.0的数，虽然可行，但是亮部很容易变得很多，这就导致光晕效果过重。</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c">GLuint hdrFBO;<br>glGenFramebuffers(<span class="hljs-number">1</span>, &amp;hdrFBO);<br>glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO);<br><span class="hljs-comment">// 创建两个颜色纹理附件。</span><br>GLuint colorBuffers[<span class="hljs-number">2</span>];<br>glGenTextures(<span class="hljs-number">2</span>, colorBuffers);<br><span class="hljs-keyword">for</span> (GLuint i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>    glBindTexture(GL_TEXTURE_2D, colorBuffers[i]);<br>    glTexImage2D(<br>        GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number">0</span>, GL_RGB, GL_FLOAT, <span class="hljs-literal">NULL</span><br>    );<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br>    <span class="hljs-comment">// 通过GL_COLOR_ATTACHMENT0递增的方式将颜色纹理附加到帧缓冲上。</span><br>    glFramebufferTexture2D(<br>        GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0 + i, GL_TEXTURE_2D, colorBuffers[i], <span class="hljs-number">0</span><br>    );<br>&#125;<br><br><span class="hljs-comment">// 显式告知OpenGL我们正在通过glDrawBuffers渲染到多个颜色缓冲。</span><br>GLuint attachments[<span class="hljs-number">2</span>] = &#123; GL_COLOR_ATTACHMENT0, GL_COLOR_ATTACHMENT1 &#125;;<br>glDrawBuffers(<span class="hljs-number">2</span>, attachments);<br></code></pre></td></tr></table></figure><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-comment">// 片段着色器中通过location标识符来声明多个颜色缓冲。</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> BrightColor;<br><br>[...]<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>[...]<br><span class="hljs-type">float</span> brightness = <span class="hljs-built_in">dot</span>(result, <span class="hljs-type">vec3</span>(<span class="hljs-number">0.2126</span>, <span class="hljs-number">0.7152</span>, <span class="hljs-number">0.0722</span>));<br><span class="hljs-comment">// 根据情况决定输出到多个颜色缓冲中的值。</span><br><span class="hljs-keyword">if</span>(brightness &gt; <span class="hljs-number">1.0</span>)<br>BrightColor = <span class="hljs-type">vec4</span>(result, <span class="hljs-number">1.0</span>);<br><span class="hljs-keyword">else</span><br>BrightColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>FragColor = <span class="hljs-type">vec4</span>(result, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="给高亮度区域添加模糊效果"><a href="#给高亮度区域添加模糊效果" class="headerlink" title="给高亮度区域添加模糊效果"></a>给高亮度区域添加模糊效果</h3><ul><li>添加模糊效果，最容易想到的便是高斯模糊。仅需给片段着色器提供一个高斯模糊核，便可以给高亮区域添加模糊效果。但由于想要得到较大的光晕，核数组将会是一个较大的二维数组，数组越大，每个片段的计算量也就越大。如使用一个32x32的二维数组进行采样，每个片段的计算量是1024，计算量较大，可行性较低。</li><li>高斯方程有个非常巧妙的特性，它允许我们把二维方程分解为两个更小的方程：一个描述水平权重，另一个描述垂直权重。我们首先用水平权重在整个纹理上进行水平模糊，然后在经改变的纹理上进行垂直模糊。利用这个特性，结果是一样的，但是可以节省难以置信的性能，因为我们现在只需做32+32次采样，不再是1024了！这叫做两步高斯模糊。</li><li><img src="/2019/05/19/HDR和泛光/bloom_gaussian.png" alt="高斯曲线"></li><li><img src="/2019/05/19/HDR和泛光/bloom_gaussian_two_pass.png" alt="两步高斯模糊"></li><li>采用两步高斯模糊将会对图像进行两步处理，因此，需要使用两个帧缓冲对象来轮流交替保存上一次的图像处理结果及本次图像处理结果。每次循环根据打算渲染的是水平还是垂直来绑定两个缓冲其中之一，而将另一个绑定为纹理进行模糊。</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c">GLuint blurFBO[<span class="hljs-number">2</span>];<br>GLuint blurColorBuffers[<span class="hljs-number">2</span>];<br>glGenFramebuffers(<span class="hljs-number">2</span>, blurFBO);<br>glGenTextures(<span class="hljs-number">2</span>, blurColorBuffers);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; ++i) &#123;<br>glBindFramebuffer(GL_FRAMEBUFFER, blurFBO[i]);<br>glBindTexture(GL_TEXTURE_2D, blurColorBuffers[i]);<br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number">0</span>, GL_RGBA, GL_FLOAT, <span class="hljs-literal">NULL</span>);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, blurColorBuffers[i], <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Framebuffer not complete!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><br>[...]<br><span class="hljs-keyword">while</span> (!glfwWindowShouldClose(window))<br>&#123;<br><span class="hljs-keyword">bool</span> horizontal = <span class="hljs-literal">true</span>, first_iteration = <span class="hljs-literal">true</span>;<br>blurShader.use();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) &#123;<br>glBindFramebuffer(GL_FRAMEBUFFER, blurFBO[horizontal]);<br>blurShader.setBool(<span class="hljs-string">"horizontal"</span>, horizontal);<br>glBindTexture(GL_TEXTURE_2D, first_iteration ? colorBuffer[<span class="hljs-number">1</span>] : blurColorBuffers[!horizontal]);<br>renderQuad();<br>horizontal = !horizontal;<br>first_iteration = <span class="hljs-literal">false</span>;<br>&#125;<br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> TexCoords;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> <span class="hljs-type">imageBuffer</span>;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">bool</span> horizontal;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> weight[<span class="hljs-number">5</span>] = <span class="hljs-type">float</span>[] (<span class="hljs-number">0.2270270270</span>, <span class="hljs-number">0.1945945946</span>, <span class="hljs-number">0.1216216216</span>, <span class="hljs-number">0.0540540541</span>, <span class="hljs-number">0.0162162162</span>);<br><br><span class="hljs-type">void</span> main()<br>&#123;<br><span class="hljs-type">vec2</span> tex_offset = <span class="hljs-number">1.0</span> / <span class="hljs-built_in">textureSize</span>(<span class="hljs-type">imageBuffer</span>, <span class="hljs-number">0</span>);<br><span class="hljs-type">vec3</span> result = <span class="hljs-built_in">texture</span>(<span class="hljs-type">imageBuffer</span>, TexCoords).rgb * weight[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (horizontal) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>result += <span class="hljs-built_in">texture</span>(<span class="hljs-type">imageBuffer</span>, TexCoords + <span class="hljs-type">vec2</span>(tex_offset.x * i, <span class="hljs-number">0.0</span>)).rgb * weight[i];<br>result += <span class="hljs-built_in">texture</span>(<span class="hljs-type">imageBuffer</span>, TexCoords - <span class="hljs-type">vec2</span>(tex_offset.x * i, <span class="hljs-number">0.0</span>)).rgb * weight[i];<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>result += <span class="hljs-built_in">texture</span>(<span class="hljs-type">imageBuffer</span>, TexCoords + <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>, tex_offset.y * i)).rgb * weight[i];<br>result += <span class="hljs-built_in">texture</span>(<span class="hljs-type">imageBuffer</span>, TexCoords - <span class="hljs-type">vec2</span>(<span class="hljs-number">0.0</span>, tex_offset.y * i)).rgb * weight[i];<br>&#125;<br>&#125;<br>FragColor = <span class="hljs-type">vec4</span>(result, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="将高亮度区域叠加回原场景"><a href="#将高亮度区域叠加回原场景" class="headerlink" title="将高亮度区域叠加回原场景"></a>将高亮度区域叠加回原场景</h3><ul><li>将模糊后的高亮区域作为纹理输入，和原场景的纹理输入进行简单叠加，即可获得较好的泛光效果。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> TexCoords;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> scene;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> bloomBlur;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">bool</span> bloom;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> exposure;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> gamma = <span class="hljs-number">2.2</span>;<br><span class="hljs-type">vec3</span> hdrColor = <span class="hljs-built_in">texture</span>(scene, TexCoords).rgb;<br><span class="hljs-comment">// vec3 hdrColor = vec3(0);</span><br><span class="hljs-keyword">if</span> (bloom) &#123;<br>hdrColor += <span class="hljs-built_in">texture</span>(bloomBlur, TexCoords).rgb;<br>&#125;<br><span class="hljs-comment">// reinhard</span><br><span class="hljs-comment">// vec3 result = hdrColor / (hdrColor + vec3(1.0));</span><br><span class="hljs-comment">// exposure</span><br><span class="hljs-type">vec3</span> result = <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>) - <span class="hljs-built_in">exp</span>(-hdrColor * exposure);<br>result = <span class="hljs-built_in">pow</span>(result, <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span> / gamma));<br>FragColor = <span class="hljs-type">vec4</span>(result, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> HDR和泛光 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> HDR </tag>
            
            <tag> 泛光 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python笔记</title>
      <link href="/2019/05/07/python%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/05/07/python%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一些python知识点。</p><p>测试环境：python2.5</p></blockquote><a id="more"></a><h3 id="测试效率的方法"><a href="#测试效率的方法" class="headerlink" title="测试效率的方法"></a><strong>测试效率的方法</strong></h3><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> timeit<br><span class="hljs-keyword">import</span> dis<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CA</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        self.m_A = <span class="hljs-number">1</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func1</span><span class="hljs-params">(oA)</span>:</span><br>    <span class="hljs-keyword">return</span> getattr(oA, <span class="hljs-string">"m_A"</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func2</span><span class="hljs-params">(oA)</span>:</span><br>    <span class="hljs-keyword">return</span> oA.m_A<br><br>n = <span class="hljs-number">66666</span><br><span class="hljs-keyword">print</span> timeit.Timer(<span class="hljs-string">'oA=CA();func1(oA)'</span>, <span class="hljs-string">'from __main__ import func1, CA'</span>).timeit(n)<br><span class="hljs-keyword">print</span> timeit.Timer(<span class="hljs-string">'oA=CA();func2(oA)'</span>, <span class="hljs-string">'from __main__ import func2, CA'</span>).timeit(n)<br><br>dis.dis(func1)<br>dis.dis(func2)<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">0.0283215137093<br>0.0246033190248<br>  9           0 LOAD_GLOBAL              0 (getattr)<br>              3 LOAD_FAST                0 (oA)<br>              6 LOAD_CONST               1 (&apos;m_A&apos;)<br>              9 CALL_FUNCTION            2<br>             12 RETURN_VALUE        <br> 12           0 LOAD_FAST                0 (oA)<br>              3 LOAD_ATTR                0 (m_A)<br>              6 RETURN_VALUE<br></code></pre></td></tr></table></figure><ul><li>timeit模块能较方便的测试函数执行多次的耗时。</li><li>dis能看到看到虚拟机指令，能从底层中了解耗时的去向。</li></ul><hr><h3 id="写操作对命名空间的影响"><a href="#写操作对命名空间的影响" class="headerlink" title="写操作对命名空间的影响"></a><strong>写操作对命名空间的影响</strong></h3><blockquote><p>python遵循按照LGB命名空间顺序寻找变量的定义，即变量会先在local中寻找，再到global中寻找，再到built-in中寻找。</p><p>如果对变量进行写操作，且没有进行global等关键字的声明，该变量会被认为是在local命名空间中。</p><p>下面由于写操作导致命名空间变换而导致报错的例子。</p></blockquote><h4 id="缺乏global声明"><a href="#缺乏global声明" class="headerlink" title="缺乏global声明"></a>缺乏global声明</h4><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">value = <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0</span>:<br>        value = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">print</span> value<br>func()<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Traceback (most recent call last):<br>  File &quot;a.py&quot;, line 6, in &lt;module&gt;<br>    func()<br>  File &quot;a.py&quot;, line 3, in func<br>    if value &gt; 0:<br>UnboundLocalError: local variable &apos;value&apos; referenced before assignment<br></code></pre></td></tr></table></figure><ul><li>value = 1进行了赋值操作，也就是写操作，在该函数块的局部空间中，没有对value变量进行全局global声明，故在编译检查阶段会认为value是局部变量，局部变量不能在声明之前使用，所以if value &gt; 0的判断语句报错了。</li><li>建议在局部空间中，访问到全局变量，无论是否会有写操作，先用global进行声明。</li></ul><hr><h4 id="重复import"><a href="#重复import" class="headerlink" title="重复import"></a>重复import</h4><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">()</span>:</span><br>    a = math.pi<br><br>    <span class="hljs-keyword">import</span> math<br>    b = math.sqrt(<span class="hljs-number">2</span>)<br><br>func()<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Traceback (most recent call last):<br>  File &quot;a.py&quot;, line 8, in &lt;module&gt;<br>    func()<br>  File &quot;a.py&quot;, line 3, in func<br>    a = math.pi<br>UnboundLocalError: local variable &apos;math&apos; referenced before assignment<br></code></pre></td></tr></table></figure><ul><li>在项目中常见的全局import后局部再次import的情况。由于import实际上是一个赋值操作，那么该情况就跟例子1中情况相似了。</li><li>项目中加强代码静态检查，使用静态检查工具自动检查。</li></ul><hr><h3 id="环引用"><a href="#环引用" class="headerlink" title="环引用"></a>环引用</h3><ul><li>python中的垃圾回收机制使用了引用计数，当对象引用计数为0的时候，将对象删除。</li><li>在项目代码的编写中，容易不注意存在两个对象相互引用，导致对象不能单独释放，需要两个对象都释放的情况下才能完全释放。</li></ul><h4 id="对象属性引用了对象本身"><a href="#对象属性引用了对象本身" class="headerlink" title="对象属性引用了对象本身"></a>对象属性引用了对象本身</h4><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> weakref<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CA</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, p)</span>:</span><br>        self.m_P = p<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CB</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        self.m_A = CA(self)<br><br>b = CB()<br>print(<span class="hljs-string">"step1 b refcount:"</span>, sys.getrefcount(b))<br><br>weakb = weakref.ref(b)<br><br>b = <span class="hljs-keyword">None</span><br>print(<span class="hljs-string">"step2 :"</span>, weakb())<br>print(<span class="hljs-string">"step3 b refcount:"</span>, sys.getrefcount(weakb()))<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">(&apos;step1 b refcount:&apos;, 3)<br>(&apos;step2 :&apos;, &lt;__main__.CB object at 0x02B0F150&gt;)<br>(&apos;step3 b refcount:&apos;, 2)<br></code></pre></td></tr></table></figure><ul><li>尽量避免对象属性引用对象自身的情况，可以用弱引用替代。</li></ul><hr><h4 id="对象属性引用了对象方法"><a href="#对象属性引用了对象方法" class="headerlink" title="对象属性引用了对象方法"></a>对象属性引用了对象方法</h4><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> weakref<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CA</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, callback)</span>:</span><br>        self.m_Callback = callback<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CB</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        self.m_A = CA(self.OnCallback)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">OnCallback</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">pass</span><br><br>b = CB()<br>print(<span class="hljs-string">"step1 b refcount:"</span>, sys.getrefcount(b))<br><br>weakb = weakref.ref(b)<br><br>b = <span class="hljs-keyword">None</span><br>print(<span class="hljs-string">"step2 :"</span>, weakb())<br>print(<span class="hljs-string">"step3 b refcount:"</span>, sys.getrefcount(weakb()))<br>print(<span class="hljs-string">"step4 m_Callback.im_self:"</span>, weakb().m_A.m_Callback.im_self)<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">(&apos;step1 b refcount:&apos;, 3)<br>(&apos;step2 :&apos;, &lt;__main__.CB object at 0x029310B0&gt;)<br>(&apos;step3 b refcount:&apos;, 2)<br>(&apos;step4 m_Callback.im_self:&apos;, &lt;__main__.CB object at 0x029310B0&gt;)<br></code></pre></td></tr></table></figure><ul><li>对象方法中通过im_self引用了对象自身，从而造成环引用。</li><li>建议也是通过弱引用的方式来存储回调函数。</li></ul><hr><h3 id="热更新相关"><a href="#热更新相关" class="headerlink" title="热更新相关"></a>热更新相关</h3><ul><li>这是常用的热更方式，动态替换全局函数或某个类的成员函数。</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CA</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func1</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"func1"</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func2</span><span class="hljs-params">(self)</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"func2"</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func3</span><span class="hljs-params">(self)</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"func3"</span><br><br>print(<span class="hljs-string">"func2: "</span>, func2)<br>print(<span class="hljs-string">"func3: "</span>, func3)<br>print(<span class="hljs-string">"func3 = func2"</span>)<br>func3 = func2<br>print(<span class="hljs-string">"func2: "</span>, func2)<br>print(<span class="hljs-string">"func3: "</span>, func3)<br>print(<span class="hljs-string">"======================="</span>)<br>a = CA()<br>print(<span class="hljs-string">"CA.func1: "</span>, CA.func1)<br>print(<span class="hljs-string">"a.func1: "</span>, a.func1)<br>print(<span class="hljs-string">"CA.func1 = fun2"</span>)<br>CA.func1 = func2<br>print(<span class="hljs-string">"CA.func1: "</span>, CA.func1)<br>print(<span class="hljs-string">"a.func1: "</span>, a.func1)<br>print(<span class="hljs-string">"======================="</span>)<br>print(CA.func1.im_func, CA.func1.im_class, CA.func1.im_self)<br>print(a.func1.im_func, a.func1.im_class, a.func1.im_self)<br>print(<span class="hljs-string">"======================="</span>)<br>print(a.__dict__)<br>a.func1 = func2<br>print(a.__dict__)<br>print(CA.func1.im_func, CA.func1.im_class, CA.func1.im_self)<br>print(a.func1)<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs undefined">(&apos;func2: &apos;, &lt;function func2 at 0x02786930&gt;)<br>(&apos;func3: &apos;, &lt;function func3 at 0x02786F70&gt;)<br>func3 = func2<br>(&apos;func2: &apos;, &lt;function func2 at 0x02786930&gt;)<br>(&apos;func3: &apos;, &lt;function func2 at 0x02786930&gt;)<br>=======================<br>(&apos;CA.func1: &apos;, &lt;unbound method CA.func1&gt;)<br>(&apos;a.func1: &apos;, &lt;bound method CA.func1 of &lt;__main__.CA object at 0x0278B170&gt;&gt;)<br>CA.func1 = fun2<br>(&apos;CA.func1: &apos;, &lt;unbound method CA.func2&gt;)<br>(&apos;a.func1: &apos;, &lt;bound method CA.func2 of &lt;__main__.CA object at 0x0278B170&gt;&gt;)<br>=======================<br>(&lt;function func2 at 0x02786930&gt;, &lt;class &apos;__main__.CA&apos;&gt;, None)<br>(&lt;function func2 at 0x02786930&gt;, &lt;class &apos;__main__.CA&apos;&gt;, &lt;__main__.CA object at 0x0278B170&gt;)<br>=======================<br>&#123;&#125;<br>&#123;&apos;func1&apos;: &lt;function func2 at 0x02786930&gt;&#125;<br>(&lt;function func2 at 0x02786930&gt;, &lt;class &apos;__main__.CA&apos;&gt;, None)<br>&lt;function func2 at 0x02786930&gt;<br></code></pre></td></tr></table></figure><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><ul><li>全局函数的替换方式简单直白，从打印中可以看出其将func3的指针改为指向func2，从而完成函数替换。</li><li>成员函数的替换就有点不同，可以看出CA.func1和a.func1分别是unbound method和bound method两种类型，在执行函数替换后，它们没有变成function类型，但指向的函数确实从func1指向func2了。</li><li>通过打印im_func，可以发现，对成员函数的替换实质上是对im_func的替换，这里im_func被替换成了func2。</li><li>通过对im_func的替换，使得在函数调用时，查找im_func不再指向原来的func1，而是指向替换后的func2，从而完成动态替换，达到热更的目的。</li><li>最后这里通过对对象的实例进行函数替换，发现这里就真的把该函数给替换成function了，其被放进了该具体对象的<strong>dict</strong>中，所以此种做法并不能达到热更的目的。</li></ul><h4 id="Bound-Method-和-Unbound-Method"><a href="#Bound-Method-和-Unbound-Method" class="headerlink" title="Bound Method 和 Unbound Method"></a>Bound Method 和 Unbound Method</h4><ul><li>在上面的例子中，我们看到些有趣的东西，CA.fun1和a.func1指向的并不是同一个类型。</li><li>从上面的打印可以看出，Bound Method的im_self不为None，而Unbound Mehtod的im_self为None。这能够解释为什么通过a.func1调用函数不需要传self参数。</li><li>好吧，其实有无im_self并不有趣，下面才是有趣的地方。</li></ul><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CA</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func1</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">"func1"</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func2</span><span class="hljs-params">(self)</span>:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"func2"</span><br><br>a = CA()<br>print(<span class="hljs-string">"CA.func1: "</span>, CA.func1, id(CA.func1))<br>print(<span class="hljs-string">"a.func1: "</span>, a.func1, id(a.func1))<br><br>print(<span class="hljs-string">"\n======================="</span>)<br>CA.func1 = func2<br>print(<span class="hljs-string">"CA.func1: "</span>, CA.func1, id(CA.func1))<br>print(<span class="hljs-string">"a.func1: "</span>, a.func1, id(a.func1))<br><br>print(<span class="hljs-string">"\n======================="</span>)<br>a_f = a.func1<br>A_f = CA.func1<br>print(<span class="hljs-string">"A_f: "</span>, A_f, id(A_f))<br>print(<span class="hljs-string">"a_f: "</span>, a_f, id(a_f))<br>print(<span class="hljs-string">"CA.func1: "</span>, CA.func1, id(CA.func1))<br>print(<span class="hljs-string">"a.func1: "</span>, a.func1, id(a.func1))<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs undefined">(&apos;CA.func1: &apos;, &lt;unbound method CA.func1&gt;, 43953528)<br>(&apos;a.func1: &apos;, &lt;bound method CA.func1 of &lt;__main__.CA object at 0x02A3B170&gt;&gt;, 43953528)<br><br>=======================<br>(&apos;CA.func1: &apos;, &lt;unbound method CA.func2&gt;, 43953528)<br>(&apos;a.func1: &apos;, &lt;bound method CA.func2 of &lt;__main__.CA object at 0x02A3B170&gt;&gt;, 43953528)<br><br>=======================<br>(&apos;A_f: &apos;, &lt;unbound method CA.func2&gt;, 43953528)<br>(&apos;a_f: &apos;, &lt;bound method CA.func2 of &lt;__main__.CA object at 0x02A3B170&gt;&gt;, 43953448)<br>(&apos;CA.func1: &apos;, &lt;unbound method CA.func2&gt;, 44258768)<br>(&apos;a.func1: &apos;, &lt;bound method CA.func2 of &lt;__main__.CA object at 0x02A3B170&gt;&gt;, 44258768)<br></code></pre></td></tr></table></figure><ul><li>在函数替换前后，打印a.func1和CA.func1发现它们的id都一样，即它们都指向了一个相同的空间。</li><li>当用临时变量将两个函数存起来的时候，通过打印发现，它们的id变得奇怪了起来。</li><li>原因是，无论是bound method还是unbound methond，它们都是临时的实例对象，想起了一切皆对象。而一开始它们的id相同，是由于python内部的对象池优化导致的。</li></ul><hr><h3 id="新式类与旧式类"><a href="#新式类与旧式类" class="headerlink" title="新式类与旧式类"></a>新式类与旧式类</h3><blockquote><p>从python2.2开始，python引入了新式类概念。一切继承自超类object的class称为新式类。</p><p>新式类和旧类的最大区别，我认为是在多继承之后方法的寻找方式。</p></blockquote><h4 id="旧式类的函数寻找方式"><a href="#旧式类的函数寻找方式" class="headerlink" title="旧式类的函数寻找方式"></a>旧式类的函数寻找方式</h4><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">COldA</span><span class="hljs-params">()</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"Old A"</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">COldB</span><span class="hljs-params">(COldA)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"Old B"</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">COldSonA</span><span class="hljs-params">(COldA)</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">COldSonB</span><span class="hljs-params">(COldB)</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"Old SonB"</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">COldC</span><span class="hljs-params">(COldSonA, COldSonB)</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br>c = COldC()<br>c.func()<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Old A<br></code></pre></td></tr></table></figure><ul><li>从上面的代码例子中可以看出，旧类寻找函数的方式是深搜。</li></ul><h4 id="新式类的函数寻找方式"><a href="#新式类的函数寻找方式" class="headerlink" title="新式类的函数寻找方式"></a>新式类的函数寻找方式</h4><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNewA</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"New A"</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNewB</span><span class="hljs-params">(CNewA)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"New B"</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNewSonA</span><span class="hljs-params">(CNewA)</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNewSonB</span><span class="hljs-params">(CNewB)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"New SonB"</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNewC</span><span class="hljs-params">(CNewSonA, CNewSonB)</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br>c = CNewC()<br>c.func()<br>print(<span class="hljs-string">"\n"</span>.join([str(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> CNewC.__mro__]))<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs undefined">New SonB<br>&lt;class &apos;__main__.CNewC&apos;&gt;<br>&lt;class &apos;__main__.CNewSonA&apos;&gt;<br>&lt;class &apos;__main__.CNewSonB&apos;&gt;<br>&lt;class &apos;__main__.CNewB&apos;&gt;<br>&lt;class &apos;__main__.CNewA&apos;&gt;<br>&lt;type &apos;object&apos;&gt;<br></code></pre></td></tr></table></figure><ul><li>新式类提供了mro供查看其函数的寻找顺序，从打印中可以看出，其并不是深搜。其采用的方式是C3算法。</li><li>C3算法详细解析在文尾，此处不作深入探讨。</li></ul><h4 id="混合使用新旧类的函数寻找方式"><a href="#混合使用新旧类的函数寻找方式" class="headerlink" title="混合使用新旧类的函数寻找方式"></a>混合使用新旧类的函数寻找方式</h4><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNewA2</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"New A2"</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNewB2</span><span class="hljs-params">(CNewA2)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"New B2"</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNewSonA2</span><span class="hljs-params">(CNewA2)</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNewSonB2</span><span class="hljs-params">(CNewB2)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"New SonB2"</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CNewC2</span><span class="hljs-params">(CNewSonA2, CNewSonB2)</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CCombine</span><span class="hljs-params">(COldC, CNewC)</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CCombine2</span><span class="hljs-params">(CNewC, COldC, CNewC2)</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br>c = CCombine()<br>c.func()<br>print(<span class="hljs-string">"\n"</span>.join([str(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> CCombine.__mro__]))<br>print(<span class="hljs-string">"==================================="</span>)<br><br>c = CCombine2()<br>c.func()<br>print(<span class="hljs-string">"\n"</span>.join([str(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> CCombine2.__mro__]))<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs undefined">Old A<br>&lt;class &apos;__main__.CCombine&apos;&gt;<br>__main__.COldC<br>__main__.COldSonA<br>__main__.COldA<br>__main__.COldSonB<br>__main__.COldB<br>&lt;class &apos;__main__.CNewC&apos;&gt;<br>&lt;class &apos;__main__.CNewSonA&apos;&gt;<br>&lt;class &apos;__main__.CNewSonB&apos;&gt;<br>&lt;class &apos;__main__.CNewB&apos;&gt;<br>&lt;class &apos;__main__.CNewA&apos;&gt;<br>&lt;type &apos;object&apos;&gt;<br>===================================<br>New SonB<br>&lt;class &apos;__main__.CCombine2&apos;&gt;<br>&lt;class &apos;__main__.CNewC&apos;&gt;<br>&lt;class &apos;__main__.CNewSonA&apos;&gt;<br>&lt;class &apos;__main__.CNewSonB&apos;&gt;<br>&lt;class &apos;__main__.CNewB&apos;&gt;<br>&lt;class &apos;__main__.CNewA&apos;&gt;<br>__main__.COldC<br>__main__.COldSonA<br>__main__.COldA<br>__main__.COldSonB<br>__main__.COldB<br>&lt;class &apos;__main__.CNewC2&apos;&gt;<br>&lt;class &apos;__main__.CNewSonA2&apos;&gt;<br>&lt;class &apos;__main__.CNewSonB2&apos;&gt;<br>&lt;class &apos;__main__.CNewB2&apos;&gt;<br>&lt;class &apos;__main__.CNewA2&apos;&gt;<br>&lt;type &apos;object&apos;&gt;<br></code></pre></td></tr></table></figure><ul><li>可以看出，若继承的类中含有旧式类，则会按照从左到右的继承顺序进行函数查找，在每个继承的父类中，则按照该父类对应的查找方式进行查找。</li><li>上面的例子中存在菱形继承和新旧类混用的情况，当这种情况出现的时候，只能说保重了。</li></ul><h4 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h4><blockquote><p>super不等价与父类。</p><p>super() 函数用于调用下一个父类(超类)并返回该父类实例的方法。</p></blockquote><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CA</span><span class="hljs-params">(object)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"In CA"</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CB</span><span class="hljs-params">(CA)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"In CB"</span>)<br>        super(CB, self).__init__()<br>        print(<span class="hljs-string">"Leave CB"</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CC</span><span class="hljs-params">(CA)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        print(<span class="hljs-string">"In CC"</span>)<br>        super(CC, self).__init__()<br>        print(<span class="hljs-string">"Leave CC"</span>)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CD</span><span class="hljs-params">(CB, CC)</span>:</span><br>    <span class="hljs-keyword">pass</span><br><br>d = CD()<br>print(CD.__mro__)<br></code></pre></td></tr></table></figure><figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs undefined">In CB<br>In CC<br>In CA<br>Leave CC<br>Leave CB<br>(&lt;class &apos;__main__.CD&apos;&gt;, &lt;class &apos;__main__.CB&apos;&gt;, &lt;class &apos;__main__.CC&apos;&gt;, &lt;class &apos;__main__.CA&apos;&gt;, &lt;type &apos;object&apos;&gt;)<br></code></pre></td></tr></table></figure><h3 id="附C3"><a href="#附C3" class="headerlink" title="附C3"></a>附C3</h3><h4 id="C3算法"><a href="#C3算法" class="headerlink" title="C3算法"></a>C3算法</h4><ul><li>判断mro要先确定一个线性序列，然后查找路径由由序列中类的顺序决定。所以C3算法就是生成一个线性序列。</li></ul><ol><li><p>如果继承至一个基类:</p><ul><li>class B(A)</li><li>这时B的mro序列为[B,A]</li></ul></li><li><p>如果继承至多个基类</p><ul><li>class B(A1,A2,A3 …)</li><li>这时B的mro序列 mro(B) = [B] + merge(mro(A1), mro(A2), mro(A3) …, [A1,A2,A3])</li></ul></li><li><p>merge操作就是C3算法的核心。</p><ul><li>遍历执行merge操作的序列，如果一个序列的第一个元素，是其他序列中的第一个元素，或不在其他序列出现，则从所有执行merge操作序列中删除这个元素，合并到当前的mro中。</li><li>merge操作后的序列，继续执行merge操作，直到merge操作的序列为空。</li><li>如果merge操作的序列无法为空，则说明不合法。</li></ul></li></ol><h4 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h4><figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span><span class="hljs-params">(O)</span>:</span><span class="hljs-keyword">pass</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span><span class="hljs-params">(O)</span>:</span><span class="hljs-keyword">pass</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span><span class="hljs-params">(O)</span>:</span><span class="hljs-keyword">pass</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span><span class="hljs-params">(A,B)</span>:</span><span class="hljs-keyword">pass</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">F</span><span class="hljs-params">(B,C)</span>:</span><span class="hljs-keyword">pass</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">G</span><span class="hljs-params">(E,F)</span>:</span><span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><ul><li>A、B、C都继承至一个基类，所以mro序列依次为[A,O]、[B,O]、[C,O]</li><li>mro(E) = [E] + merge(mro(A), mro(B), [A,B])</li><li><p>= [E] + merge([A,O], [B,O], [A,B])</p></li><li><p>执行merge操作的序列为[A,O]、[B,O]、[A,B]</p></li><li>A是序列[A,O]中的第一个元素，在序列[B,O]中不出现，在序列[A,B]中也是第一个元素，所以从执行merge操作的序列([A,O]、[B,O]、[A,B])中删除A，合并到当前mro，[E]中。</li><li>mro(E) = [E,A] + merge([O], [B,O], [B])</li><li>再执行merge操作，O是序列[O]中的第一个元素，但O在序列[B,O]中出现并且不是其中第一个元素。继续查看[B,O]的第一个元素B，B满足条件，所以从执行merge操作的序列中删除B，合并到[E, A]中。</li><li>mro(E) = [E,A,B] + merge([O], [O])</li><li>= [E,A,B,O]</li></ul><h4 id="PPT"><a href="#PPT" class="headerlink" title="PPT"></a>PPT</h4><p><a href="/2019/05/07/python笔记/python笔记.pptx">python笔记.pptx</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>视差贴图</title>
      <link href="/2019/04/21/%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/"/>
      <url>/2019/04/21/%E8%A7%86%E5%B7%AE%E8%B4%B4%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 视差学习笔记</p><p><img src="/2019/04/21/视差贴图/result.png" alt=""></p></blockquote><a id="more"></a><ul><li>法线贴图能改变每个像素点反射光线的方向，从而改变明暗光影效果，但法线贴图无法解决模型中的凹凸问题。如下图中所示，对于砖块的背光面，我们应该是不可视的，但法线贴图并不能让它们不可视，只能将它们变暗。<br><img src="/2019/04/21/视差贴图/normalmap.png" alt=""></li></ul><h2 id="视差贴图"><a href="#视差贴图" class="headerlink" title="视差贴图"></a>视差贴图</h2><ul><li>视差贴图背后的思想是修改纹理坐标使一个fragment的表面看起来比实际的更高或者更低，所有这些都根据观察方向和高度贴图。</li></ul><h3 id="高度贴图"><a href="#高度贴图" class="headerlink" title="高度贴图"></a>高度贴图</h3><ul><li><img src="/2019/04/21/视差贴图/parallax_mapping_plane_height.png" alt="高度贴图"></li><li>这里粗糙的红线代表高度贴图中的数值的立体表达，向量 $\vec V$ 代表观察方向。如果平面进行实际位移，观察者会在点B看到表面。然而我们的平面没有实际上进行位移，观察方向将在点A与平面接触。故，我们能观测到砖块的背光面。视差贴图的目的是，在A位置上的fragment不再使用点A的纹理坐标而是使用点B的。随后我们用点B的纹理坐标采样，观察者就像看到了点B一样。</li><li>通过B点没有好的方式能算到A点坐标，故采用一种近似的求法。求出视线向量 $\vec {viewDir}$ ，用A点的高度值对其进行缩放。由于视线与平面夹角约小，B点会越靠右，故对该近似值在处以viewDir.z。<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> ParallaxMapping(<span class="hljs-type">vec2</span> texCoords, <span class="hljs-type">vec3</span> viewDir) &#123;<br>    <span class="hljs-type">float</span> height =  <span class="hljs-built_in">texture</span>(depthMap, texCoords).r;<br>    <span class="hljs-keyword">return</span> texCoords + viewDir.xy / viewDir.z * height * heightScale;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="深度贴图"><a href="#深度贴图" class="headerlink" title="深度贴图"></a>深度贴图</h3><ul><li><img src="/2019/04/21/视差贴图/parallax_mapping_depth.png" alt="深度贴图"></li><li>当我们改用深度贴图时，若被观测物体在视线左边，通过A点求B点的方式大体上并没有改变，只是A点将减去 $\vec {BA}$ 间的距离。<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> ParallaxMapping(<span class="hljs-type">vec2</span> texCoords, <span class="hljs-type">vec3</span> viewDir) &#123;<br>    <span class="hljs-type">float</span> height =  <span class="hljs-built_in">texture</span>(depthMap, texCoords).r;<br>    <span class="hljs-keyword">return</span> texCoords - viewDir.xy / viewDir.z * height * heightScale;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="实际计算"><a href="#实际计算" class="headerlink" title="实际计算"></a>实际计算</h3><ul><li>无论是使用高度贴图还是深度贴图，这些计算都是在片段着色器中进行的，而上面的理论讨论是基于TBN空间，故我们需要像处理法线贴图一样，将一些必要的位置转换至TBN空间。这些必要的位置有光源坐标，摄像机坐标，片段（具体像素）坐标。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// vs</span><br><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aNormal;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoords;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aTangent;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aBitangent;<br><br><span class="hljs-keyword">out</span> VS_OUT &#123;<br>    <span class="hljs-type">vec3</span> FragPos;<br>    <span class="hljs-type">vec2</span> TexCoords;<br>    <span class="hljs-type">vec3</span> TangentLightPos;<br>    <span class="hljs-type">vec3</span> TangentViewPos;<br>    <span class="hljs-type">vec3</span> TangentFragPos;<br>&#125; vs_out;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> lightPos;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> viewPos;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    vs_out.FragPos = <span class="hljs-type">vec3</span>(model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>));   <br>    vs_out.TexCoords = aTexCoords;<br><br>    <span class="hljs-type">mat3</span> normalMatrix = <span class="hljs-built_in">transpose</span>(<span class="hljs-built_in">inverse</span>(<span class="hljs-type">mat3</span>(model)));<br>    <span class="hljs-type">vec3</span> T = <span class="hljs-built_in">normalize</span>(normalMatrix * aTangent);<br>    <span class="hljs-type">vec3</span> N = <span class="hljs-built_in">normalize</span>(normalMatrix * aNormal);<br>    T = <span class="hljs-built_in">normalize</span>(T - <span class="hljs-built_in">dot</span>(T, N) * N);<br>    <span class="hljs-type">vec3</span> B = <span class="hljs-built_in">cross</span>(N, T);<br><br>    <span class="hljs-type">mat3</span> TBN = <span class="hljs-built_in">transpose</span>(<span class="hljs-type">mat3</span>(T, B, N));    <br>    vs_out.TangentLightPos = TBN * lightPos;<br>    vs_out.TangentViewPos  = TBN * viewPos;<br>    vs_out.TangentFragPos  = TBN * vs_out.FragPos;<br><br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">//fs</span><br><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-keyword">in</span> VS_OUT &#123;<br>    <span class="hljs-type">vec3</span> FragPos;<br>    <span class="hljs-type">vec2</span> TexCoords;<br>    <span class="hljs-type">vec3</span> TangentLightPos;<br>    <span class="hljs-type">vec3</span> TangentViewPos;<br>    <span class="hljs-type">vec3</span> TangentFragPos;<br>&#125; fs_in;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> diffuseMap;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> normalMap;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> depthMap;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> heightScale;<br><br><span class="hljs-type">vec2</span> ParallaxMapping(<span class="hljs-type">vec2</span> texCoords, <span class="hljs-type">vec3</span> viewDir)<br>&#123;<br>    <span class="hljs-type">float</span> height =  <span class="hljs-built_in">texture</span>(depthMap, texCoords).r;<br>    <span class="hljs-comment">// 高度贴图情况</span><br>    <span class="hljs-comment">// return texCoords - viewDir.xy * (height * heightScale);</span><br>  <span class="hljs-comment">// 深度贴图情况</span><br>  <span class="hljs-keyword">return</span> texCoords - viewDir.xy * (height * heightScale);<br>&#125;<br><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-type">vec3</span> viewDir = <span class="hljs-built_in">normalize</span>(fs_in.TangentViewPos - fs_in.TangentFragPos);<br>    <span class="hljs-type">vec2</span> texCoords = fs_in.TexCoords;<br><br>    texCoords = ParallaxMapping(fs_in.TexCoords,  viewDir);       <br>    <span class="hljs-keyword">if</span>(texCoords.x &gt; <span class="hljs-number">1.0</span> || texCoords.y &gt; <span class="hljs-number">1.0</span> || texCoords.x &lt; <span class="hljs-number">0.0</span> || texCoords.y &lt; <span class="hljs-number">0.0</span>)<br>        <span class="hljs-keyword">discard</span>;<br><br>    <span class="hljs-comment">// 法线计算</span><br>    ...<br>    <span class="hljs-comment">// 光照计算</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><img src="/2019/04/21/视差贴图/height_map_vs_depth_map.png" alt="高度贴图与深度贴图效果对比"></li><li>在砖块上，使用深度贴图的表现效果要比使用高度贴图的更好。因为使用高度贴图会向靠近观测点的方向取样，而深度贴图则向远离观测点的方向取样，在砖块里沟壑较窄，容易出现上图中蓝圈中出现“倒影”的情况。</li></ul><h2 id="陡峭视差映射"><a href="#陡峭视差映射" class="headerlink" title="陡峭视差映射"></a>陡峭视差映射</h2><p><img src="/2019/04/21/视差贴图/parallax_mapping_steep_parallax_mapping_diagram.png" alt="陡峭视差映射原理"></p><ul><li>当我们把深度从0.0 - 1.0均分成多层，随着视线往下一层层增大，将该值记为currentLayerDepth。而随着视线往下一层层移动，视线与层的交点对应的纹理坐标currentTexCoords采样得到的深度值记为currentDepthMapValue。可以观察发现，在视线期望落点的左右两边（图中T2和T3），currentDepthMapValue和currentLayerDepth作差的结果的符号是相反的，即期望落点的下一个分层，其采样深度值currentDepthMapValue必然小于currentLayerDepth。</li><li><p>层数越多，我们获得的结果精度越高，消耗也越大。我们可以通过对视差贴图的一个属性的利用，对算法进行一点提升。当垂直看一个表面的时候纹理时位移比以一定角度看时的小。我们可以在垂直看时使用更少的样本，以一定角度看时增加样本数量。</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec2</span> ParallaxMapping2(<span class="hljs-type">vec2</span> texCoords, <span class="hljs-type">vec3</span> viewDir)<br>&#123;<br>    <span class="hljs-comment">// number of depth layers</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> minLayers = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-type">float</span> maxLayers = <span class="hljs-number">32</span>;<br>    <span class="hljs-type">float</span> numLayers = <span class="hljs-built_in">mix</span>(maxLayers, minLayers, <span class="hljs-built_in">abs</span>(<span class="hljs-built_in">dot</span>(<span class="hljs-type">vec3</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>), viewDir)));  <br>    <span class="hljs-comment">// calculate the size of each layer</span><br>    <span class="hljs-type">float</span> layerDepth = <span class="hljs-number">1.0</span> / numLayers;<br>    <span class="hljs-comment">// depth of current layer</span><br>    <span class="hljs-type">float</span> currentLayerDepth = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-comment">// the amount to shift the texture coordinates per layer (from vector P)</span><br>    <span class="hljs-type">vec2</span> P = viewDir.xy / viewDir.z * heightScale;<br>    <span class="hljs-type">vec2</span> deltaTexCoords = P / numLayers;<br><br>    <span class="hljs-comment">// get initial values</span><br>    <span class="hljs-type">vec2</span>  currentTexCoords     = texCoords;<br>    <span class="hljs-type">float</span> currentDepthMapValue = <span class="hljs-built_in">texture</span>(depthMap, currentTexCoords).r;<br><br>    <span class="hljs-keyword">while</span>(currentLayerDepth &lt; currentDepthMapValue)<br>    &#123;<br>        <span class="hljs-comment">// shift texture coordinates along direction of P</span><br>        currentTexCoords -= deltaTexCoords;<br>        <span class="hljs-comment">// get depthmap value at current texture coordinates</span><br>        currentDepthMapValue = <span class="hljs-built_in">texture</span>(depthMap, currentTexCoords).r;  <br>        <span class="hljs-comment">// get depth of next layer</span><br>        currentLayerDepth += layerDepth;  <br>    &#125;<br><br>    <span class="hljs-keyword">return</span> currentTexCoords;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/04/21/视差贴图/parallax_mapping_steep_artifact.png" alt="陡峭视差映射缺陷"></p></li><li>层数不可能无限增加，当观测视角比较小时，断层现象会比较严重，这是由于分多少层实际就是将高度细分为多少离散高度值一样，相邻像素点的所归属的高度不连续导致。</li></ul><h2 id="视差遮蔽映射"><a href="#视差遮蔽映射" class="headerlink" title="视差遮蔽映射"></a>视差遮蔽映射</h2><ul><li>为了解决相邻像素点的所归属的高度不连续造成的高度断层问题，视差遮蔽映射采用了插值的方式来计算高度。</li><li>视差遮蔽映射(Parallax Occlusion Mapping)和陡峭视差映射的原则相同，但不是用触碰的第一个深度层的纹理坐标，而是在触碰之前和之后，在深度层之间进行线性插值。我们根据表面的高度距离啷个深度层的深度层值的距离来确定线性插值的大小。</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">vec2 <span class="hljs-title">ParallaxOcclusionMapping</span><span class="hljs-params">(vec2 texCoords, vec3 viewDir)</span><br></span>&#123;<br>    <span class="hljs-comment">// number of depth layers</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> minLayers = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> maxLayers = <span class="hljs-number">32</span>;<br>    <span class="hljs-keyword">float</span> numLayers = mix(maxLayers, minLayers, <span class="hljs-built_in">abs</span>(dot(vec3(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>), viewDir)));  <br>    <span class="hljs-comment">// calculate the size of each layer</span><br>    <span class="hljs-keyword">float</span> layerDepth = <span class="hljs-number">1.0</span> / numLayers;<br>    <span class="hljs-comment">// depth of current layer</span><br>    <span class="hljs-keyword">float</span> currentLayerDepth = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-comment">// the amount to shift the texture coordinates per layer (from vector P)</span><br>    vec2 P = viewDir.xy / viewDir.z * heightScale;<br>    vec2 deltaTexCoords = P / numLayers;<br><br>    <span class="hljs-comment">// get initial values</span><br>    vec2  currentTexCoords     = texCoords;<br>    <span class="hljs-keyword">float</span> currentDepthMapValue = texture(depthMap, currentTexCoords).r;<br><br>    <span class="hljs-keyword">while</span>(currentLayerDepth &lt; currentDepthMapValue)<br>    &#123;<br>        <span class="hljs-comment">// shift texture coordinates along direction of P</span><br>        currentTexCoords -= deltaTexCoords;<br>        <span class="hljs-comment">// get depthmap value at current texture coordinates</span><br>        currentDepthMapValue = texture(depthMap, currentTexCoords).r;  <br>        <span class="hljs-comment">// get depth of next layer</span><br>        currentLayerDepth += layerDepth;  <br>    &#125;<br><br>    <span class="hljs-comment">// get texture coordinates before collision (reverse operations)</span><br>    vec2 prevTexCoords = currentTexCoords + deltaTexCoords;<br><br>    <span class="hljs-comment">// get depth after and before collision for linear interpolation</span><br>    <span class="hljs-keyword">float</span> afterDepth  = currentDepthMapValue - currentLayerDepth;<br>    <span class="hljs-keyword">float</span> beforeDepth = texture(depthMap, prevTexCoords).r - currentLayerDepth + layerDepth;<br><br>    <span class="hljs-comment">// interpolation of texture coordinates</span><br>    <span class="hljs-comment">// afterDepth - beforeDepth 的值不会是0，因为两者符号相反。</span><br>    <span class="hljs-comment">// 越靠近prevTexCoords，afterDepth越大，故使用它作prevTexCoords的权重。</span><br>    <span class="hljs-keyword">float</span> weight = afterDepth / (afterDepth - beforeDepth);<br>    vec2 finalTexCoords = prevTexCoords * weight + currentTexCoords * (<span class="hljs-number">1.0</span> - weight);<br><br>    <span class="hljs-keyword">return</span> finalTexCoords;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><img src="/2019/04/21/视差贴图/parallax_mapping_parallax_occlusion_mapping.png" alt="视差遮蔽映射"></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 视差贴图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> 位移贴图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>法线贴图</title>
      <link href="/2019/04/20/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/"/>
      <url>/2019/04/20/%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 法线学习笔记</p><p><img src="/2019/04/20/法线贴图/result.png" alt=""></p></blockquote><a id="more"></a><h2 id="凹凸细节"><a href="#凹凸细节" class="headerlink" title="凹凸细节"></a>凹凸细节</h2><ul><li>一面墙由2个三角形所组成。我们通过附上纹理贴图的方式来增加其细节，提升真实感，让其看上去确实像是一面墙。但靠近墙观察的时候，我们很容易发现墙的表面十分平坦，没有任何凹凸细节，缺乏凹凸细节使得这面墙缺乏真实感。</li><li><p><img src="/2019/04/20/法线贴图/without_normal_map.png" alt=""></p></li><li><p>以光的视角来看这个问题：是什么使表面被视为完全平坦的表面来照亮？答案会是表面的法线向量。以光照算法的视角考虑的话，只有一件事决定物体的形状，这就是垂直于它的法线向量。砖块表面只有一个法线向量，表面完全根据这个法线向量被以一致的方式照亮。如果每个fragment都是用自己的不同的法线会怎样？这样我们就可以根据表面细微的细节对法线向量进行改变；这样就会获得一种表面看起来要复杂得多的幻觉：</p></li><li>每个fragment使用了自己的法线，我们就可以让光照相信一个表面由很多微小的（垂直于法线向量的）平面所组成，物体表面的细节将会得到极大提升。这种每个fragment使用各自的法线，替代一个面上所有fragment使用同一个法线的技术叫做法线贴图（normal mapping）或凹凸贴图（bump mapping）。</li><li><img src="/2019/04/20/法线贴图/normal_mapping_surfaces.png" alt=""></li></ul><h2 id="法线贴图"><a href="#法线贴图" class="headerlink" title="法线贴图"></a>法线贴图</h2><h3 id="法线贴图存储及使用"><a href="#法线贴图存储及使用" class="headerlink" title="法线贴图存储及使用"></a>法线贴图存储及使用</h3><ul><li>为使法线贴图工作，我们需要为每个fragment提供一个法线。像diffuse贴图和specular贴图一样，我们可以使用一个2D纹理来储存法线数据。2D纹理不仅可以储存颜色和光照数据，还可以储存法线向量。这样我们可以从2D纹理中采样得到特定纹理的法线向量。</li><li>纹理信息的r，g，b值取值范围是[0, 1]，而法线取值范围是[-1, 1]，故将法线以纹理贴图的方式存储时，需要将其转换至[0, 1]的取值范围。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec3</span> rgb_normal = normal * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>; <span class="hljs-comment">// 从 [-1,1] 转换至 [0,1]</span><br></code></pre></td></tr></table></figure><ul><li>同样，使用法线贴图时，我们需要将[0, 1]转换回[-1, 1]。<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> normalMap;  <br><br><span class="hljs-type">void</span> main()<br>&#123;           <br>    <span class="hljs-comment">// 从法线贴图范围[0,1]获取法线</span><br>    normal = <span class="hljs-built_in">texture</span>(normalMap, fs_in.TexCoords).rgb;<br>    <span class="hljs-comment">// 将法线向量转换为范围[-1,1]</span><br>    normal = <span class="hljs-built_in">normalize</span>(normal * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>);   <br><br>    [...]<br>    <span class="hljs-comment">// 像往常那样处理光照</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="法线贴图的使用限制"><a href="#法线贴图的使用限制" class="headerlink" title="法线贴图的使用限制"></a>法线贴图的使用限制</h3><ul><li>一般法线贴图存储着物体正朝着Z轴方向时的法线值。当被渲染物体的朝上面不再是Z轴方向时，其表现便会出现异常：</li><li><img src="/2019/04/20/法线贴图/without_TBN.png" alt=""></li><li>光照看起来完全不对！发生这种情况是平面的表面法线现在指向了y，而采样得到的法线仍然指向的是z。结果就是光照仍然认为表面法线和之前朝向正z方向时一样；这样光照就不对了。下面的图片展示了这个表面上采样的法线的近似情况：</li><li><img src="/2019/04/20/法线贴图/normal_mapping_ground_normals.png" alt=""></li></ul><h2 id="切线空间"><a href="#切线空间" class="headerlink" title="切线空间"></a>切线空间</h2><ul><li><p>在一个不同的坐标空间中进行光照，这个坐标空间里，法线贴图向量总是指向这个坐标空间的正z方向；所有的光照向量都相对与这个正z方向进行变换。这样我们就能始终使用同样的法线贴图，不管朝向问题。这个坐标空间叫做切线空间（tangent space）。</p></li><li><p>法线贴图中的法线向量在切线空间中，法线永远指着正z方向。切线空间是位于三角形表面之上的空间：法线相对于单个三角形的本地参考框架。它就像法线贴图向量的本地空间；它们都被定义为指向正z方向，无论最终变换到什么方向。使用一个特定的矩阵我们就能将本地/切线空间中的法线向量转成世界或视图坐标，使它们转向到最终的贴图表面的方向。</p></li></ul><h3 id="TBN向量"><a href="#TBN向量" class="headerlink" title="TBN向量"></a>TBN向量</h3><ul><li>这种矩阵叫做TBN矩阵这三个字母分别代表tangent、bitangent和normal向量。这是建构这个矩阵所需的向量。要建构这样一个把切线空间转变为不同空间的变换矩阵，我们需要三个相互垂直的向量，它们沿一个表面的法线贴图对齐于：上、右、前。</li><li>已知上向量是表面的法线向量。右和前向量是切线(Tagent)和副切线(Bitangent)向量。</li><li><img src="/2019/04/20/法线贴图/normal_mapping_tbn_vectors.png" style="width: 22em;"></li></ul><h3 id="TBN向量的计算"><a href="#TBN向量的计算" class="headerlink" title="TBN向量的计算"></a>TBN向量的计算</h3><ul><li>计算出切线和副切线并不像法线向量那么容易。从图中可以看到法线贴图的切线和副切线与纹理坐标的两个方向对齐。我们就是用到这个特性计算每个表面的切线和副切线的。</li><li><p><img src="/2019/04/20/法线贴图/normal_mapping_surface_edges.png" style="width: 22em;"></p></li><li><p>注意上图中边 $E_2$ 与纹理坐标的差 $\Delta U_2$、$\Delta V_2$ 构成一个三角形。 $\Delta U_2$ 与切线向量T方向相同，而 $\Delta V_2$ 与副切线向量B方向相同。这也就是说，所以我们可以将三角形的边 $E_1$ 与  $E_2$写成切线向量T和副切线向量B的线性组合：</p><script type="math/tex; mode=display">\Delta U_1 = U_1 - U_2</script><script type="math/tex; mode=display">\Delta V_1 = V_1 - V_2</script><script type="math/tex; mode=display">E_1 = \Delta U_1 T + \Delta V_1 B</script></li></ul><script type="math/tex; mode=display">\Delta U_2 = U_3 - U_2</script><script type="math/tex; mode=display">\Delta V_2 = V_3 - V_2</script><script type="math/tex; mode=display">E_2 = \Delta U_2 T + \Delta V_2 B</script><ul><li>将上面的式子改用x, y, z的表示方式：<script type="math/tex; mode=display">(E_1x, E_1y, E_1z) = \Delta U_1 (T_x, T_y, T_z) + \Delta V_1 (B_x, B_y, B_z)</script><script type="math/tex; mode=display">(E_2x, E_2y, E_2z) = \Delta U_2 (T_x, T_y, T_z) + \Delta V_2 (B_x, B_y, B_z)</script><script type="math/tex; mode=display">改用矩阵乘法表示=></script><script type="math/tex; mode=display">\begin{bmatrix} E_1x & E_1y & E_1z \\ E_2x & E_2y & E_2z \end{bmatrix} = \begin{bmatrix} \Delta U_1 & \Delta V_1 \\ \Delta U_2 & \Delta V_2 \end{bmatrix} \begin{bmatrix} T_x & T_y & T_z \\ B_x & B_y & B_z \end{bmatrix}</script><script type="math/tex; mode=display">=></script><script type="math/tex; mode=display">\begin{bmatrix} T_x & T_y & T_z \\ B_x & B_y & B_z \end{bmatrix} = \begin{bmatrix} \Delta U_1 & \Delta V_1 \\ \Delta U_2 & \Delta V_2 \end{bmatrix}^{-1} \begin{bmatrix} E_1x & E_1y & E_1z \\ E_2x & E_2y & E_2z \end{bmatrix}</script><script type="math/tex; mode=display">1除以矩阵的行列式，再乘以它的伴随矩阵便能求得逆矩阵=></script><script type="math/tex; mode=display">\begin{bmatrix} T_x & T_y & T_z \\ B_x & B_y & B_z \end{bmatrix} = \frac{1}{\Delta U_1 \Delta V_2 - \Delta U_2 \Delta V_1} \begin{bmatrix} \Delta V_2 & -\Delta V_1 \\ -\Delta U_2 & \Delta U_1 \end{bmatrix} \begin{bmatrix} E_1x & E_1y & E_1z \\ E_2x & E_2y & E_2z \end{bmatrix}</script></li></ul><h2 id="切线空间法线贴图"><a href="#切线空间法线贴图" class="headerlink" title="切线空间法线贴图"></a>切线空间法线贴图</h2><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> position;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> normal;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> texCoords;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> tangent;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">4</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> bitangent;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>   [...]<br>   <span class="hljs-type">vec3</span> T = <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(model * <span class="hljs-type">vec4</span>(tangent,   <span class="hljs-number">0.0</span>)));<br>   <span class="hljs-type">vec3</span> B = <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(model * <span class="hljs-type">vec4</span>(bitangent, <span class="hljs-number">0.0</span>)));<br>   <span class="hljs-type">vec3</span> N = <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(model * <span class="hljs-type">vec4</span>(normal,    <span class="hljs-number">0.0</span>)));<br>   <span class="hljs-type">mat3</span> TBN = <span class="hljs-type">mat3</span>(T, B, N)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>通过上面的顶点着色器代码，我们可以求出TBN矩阵，对于TBN的使用，有两种方式。</li></ul><h3 id="切线空间转世界空间"><a href="#切线空间转世界空间" class="headerlink" title="切线空间转世界空间"></a>切线空间转世界空间</h3><ul><li>在片段着色器中进行TBN空间转换和使用。</li><li>我们直接使用TBN矩阵，这个矩阵可以把切线坐标空间的向量转换到世界坐标空间。因此我们把它传给片段着色器中，把通过采样得到的法线坐标左乘上TBN矩阵，转换到世界坐标空间中，这样所有法线和其他光照变量就在同一个坐标系中了。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// fs</span><br>normal = <span class="hljs-built_in">texture</span>(normalMap, fs_in.TexCoords).rgb;<br>normal = <span class="hljs-built_in">normalize</span>(normal * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>);   <br>normal = <span class="hljs-built_in">normalize</span>(fs_in.TBN * normal);<br></code></pre></td></tr></table></figure><h3 id="世界空间转切线空间"><a href="#世界空间转切线空间" class="headerlink" title="世界空间转切线空间"></a>世界空间转切线空间</h3><ul><li>在顶点着色器中进行光照变量的转换，及那个它们转换至切线空间。</li><li>使用TBN矩阵的逆矩阵，这个矩阵可以把世界坐标空间的向量转换到切线坐标空间。因此我们使用这个矩阵左乘其他光照变量，把他们转换到切线空间，这样法线和其他光照变量再一次在一个坐标系中了。</li><li>相较于将TBN传给片段着色器，再在片段着色器中进行法线的空间转换，在顶点着色器中对光照变量转换至切线空间，能不用在像素着色器里进行矩阵乘法。顶点着色器通常比像素着色器运行的少，因此这一优化的效果是极佳的。</li><li>在求逆矩阵的时候，利用正交矩阵（每个轴既是单位向量同时相互垂直）的置换矩阵与它的逆矩阵相等的属性，能以很少的消耗算出其逆矩阵。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// vs</span><br><span class="hljs-keyword">out</span> VS_OUT &#123;<br>    <span class="hljs-type">vec3</span> FragPos;<br>    <span class="hljs-type">vec2</span> TexCoords;<br>    <span class="hljs-type">vec3</span> TangentLightPos;<br>    <span class="hljs-type">vec3</span> TangentViewPos;<br>    <span class="hljs-type">vec3</span> TangentFragPos;<br>&#125; vs_out;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> lightPos;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> viewPos;<br><br>[...]<br><br><span class="hljs-type">void</span> main()<br>&#123;    <br>    [...]<br>    <span class="hljs-type">mat3</span> TBN = <span class="hljs-built_in">transpose</span>(<span class="hljs-type">mat3</span>(T, B, N));<br>    vs_out.TangentLightPos = TBN * lightPos;<br>    vs_out.TangentViewPos  = TBN * viewPos;<br>    vs_out.TangentFragPos  = TBN * <span class="hljs-type">vec3</span>(model * <span class="hljs-type">vec4</span>(position, <span class="hljs-number">0.0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="复杂物体"><a href="#复杂物体" class="headerlink" title="复杂物体"></a>复杂物体</h2><ul><li>Assimp有个很有用的配置，在我们加载模型的时候调用aiProcess_CalcTangentSpace。当aiProcess_CalcTangentSpace应用到Assimp的ReadFile函数时，Assimp会为每个加载的顶点计算出柔和的切线和副切线向量。</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">const</span> aiScene* scene = importer.ReadFile(<br>    path, aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace<br>);<br><br><span class="hljs-built_in">vector</span>.x = mesh-&gt;mTangents[i].x;<br><span class="hljs-built_in">vector</span>.y = mesh-&gt;mTangents[i].y;<br><span class="hljs-built_in">vector</span>.z = mesh-&gt;mTangents[i].z;<br>vertex.Tangent = <span class="hljs-built_in">vector</span>;<br></code></pre></td></tr></table></figure><ul><li>另外，还必须更新模型加载器，用以从带纹理模型中加载法线贴图。wavefront的模型格式（.obj）导出的法线贴图有点不一样，Assimp的aiTextureType_NORMAL并不会加载它的法线贴图，而aiTextureType_HEIGHT却能，所以我们经常这样加载它们：</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;Texture&gt; specularMaps = <span class="hljs-keyword">this</span>-&gt;loadMaterialTextures(<br>    material, aiTextureType_HEIGHT, <span class="hljs-string">"texture_normal"</span><br>);<br></code></pre></td></tr></table></figure><ul><li>使用法线贴图也是一种提升你的场景的表现的重要方式。在使用法线贴图之前你不得不使用相当多的顶点才能表现出一个更精细的网格，但使用了法线贴图我们可以使用更少的顶点表现出同样丰富的细节。下图来自Paolo Cignoni，图中对比了两种方式：</li><li><p><img src="/2019/04/20/法线贴图/normal_mapping_comparison.png" alt=""></p></li><li><p>当在更大的网格上计算切线向量的时候，它们往往有很大数量的共享顶点，当法向贴图应用到这些表面时将切线向量平均化通常能获得更好更平滑的结果。这样做有个问题，就是TBN向量可能会不能互相垂直，这意味着TBN矩阵不再是正交矩阵了。法线贴图可能会稍稍偏移，但这仍然可以改进。</p></li><li><p>使用叫做格拉姆-施密特正交化过程（Gram-Schmidt process）的数学技巧，我们可以对TBN向量进行重正交化，这样每个向量就又会重新垂直了。在顶点着色器中我们这样做：</p></li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec3</span> T = <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(model * <span class="hljs-type">vec4</span>(tangent, <span class="hljs-number">0.0</span>)));<br><span class="hljs-type">vec3</span> N = <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(model * <span class="hljs-type">vec4</span>(normal, <span class="hljs-number">0.0</span>)));<br><span class="hljs-comment">// re-orthogonalize T with respect to N</span><br>T = <span class="hljs-built_in">normalize</span>(T - <span class="hljs-built_in">dot</span>(T, N) * N);<br><span class="hljs-comment">// then retrieve perpendicular vector B with the cross product of T and N</span><br><span class="hljs-type">vec3</span> B = <span class="hljs-built_in">cross</span>(T, N);<br><br><span class="hljs-type">mat3</span> TBN = <span class="hljs-type">mat3</span>(T, B, N)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 法线贴图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>点阴影</title>
      <link href="/2019/04/20/%E7%82%B9%E9%98%B4%E5%BD%B1/"/>
      <url>/2019/04/20/%E7%82%B9%E9%98%B4%E5%BD%B1/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 点阴影学习笔记</p><p><img src="/2019/04/20/点阴影/result.png" alt=""></p></blockquote><a id="more"></a><ul><li>在阴影映射中的光是定向光，而点阴影中的光将是点光源。其通过动态生成深度立方体贴图的方式来获得各个方向的深度值。这个技术叫做点光阴影，过去的名字是万向阴影贴图（omnidirectional shadow maps）技术。</li></ul><h2 id="生成深度立方体贴图"><a href="#生成深度立方体贴图" class="headerlink" title="生成深度立方体贴图"></a>生成深度立方体贴图</h2><ul><li><img src="/2019/04/20/点阴影/point_shadows_diagram.png" alt=""></li></ul><h3 id="朴素的生成方式"><a href="#朴素的生成方式" class="headerlink" title="朴素的生成方式"></a>朴素的生成方式</h3><ul><li>为创建一个光周围的深度值的立方体贴图，我们必须渲染场景6次：每次一个面。显然渲染场景6次需要6个不同的视图矩阵，每次把一个不同的立方体贴图面附加到帧缓冲对象上。</li><li>在朴素的生成方式下，由于需要一个深度贴图下需要进行很多渲染调用，其性能会有一定的消耗。</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">GLuint depthCubemap;<br>glGenTextures(<span class="hljs-number">1</span>, &amp;depthCubemap);<br><br><span class="hljs-keyword">const</span> GLuint SHADOW_WIDTH = <span class="hljs-number">1024</span>, SHADOW_HEIGHT = <span class="hljs-number">1024</span>;<br>glBindTexture(GL_TEXTURE_CUBE_MAP, depthCubemap);<br><span class="hljs-keyword">for</span> (GLuint i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; ++i)<br>        glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, <span class="hljs-number">0</span>, GL_DEPTH_COMPONENT,<br>                     SHADOW_WIDTH, SHADOW_HEIGHT, <span class="hljs-number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="hljs-literal">NULL</span>);<br><br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)<br>&#123;<br>    GLuint face = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i;<br>    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, face, depthCubemap, <span class="hljs-number">0</span>);<br>    BindViewMatrix(lightViewMatrices[i]);<br>    RenderScene();  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="利用几何着色器生成"><a href="#利用几何着色器生成" class="headerlink" title="利用几何着色器生成"></a>利用几何着色器生成</h3><ul><li>几何着色器允许我们使用一次渲染过程来建立深度立方体贴图，可以使用glFramebufferTexture直接把立方体贴图附加成帧缓冲的深度附件。</li><li>后文采用此种方式。</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);<br>glFramebufferTexture(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, depthCubemap, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 显式告诉OpenGL这个帧缓冲对象不会渲染到一个颜色缓冲里</span><br>glDrawBuffer(GL_NONE);<br>glReadBuffer(GL_NONE);<br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><br>glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);<br>glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);<br>glClear(GL_DEPTH_BUFFER_BIT);<br>ConfigureShaderAndMatrices();<br>RenderScene();<br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h3 id="光空间的变换"><a href="#光空间的变换" class="headerlink" title="光空间的变换"></a>光空间的变换</h3><ul><li>在选择使用几何着色器的方式来生产深度立方体贴图的方式下，我们需要将场景中的几何物体转换到光的视角下进行深度贴图的生成。</li><li>立方体贴图具有6个面，故光的视角也有6个方向。由于是点光源，空间变换矩阵使用透视投影矩阵更加合理。</li><li>每个方向的透视投影矩阵相同：</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">GLfloat aspect = (GLfloat)SHADOW_WIDTH/(GLfloat)SHADOW_HEIGHT;<br>GLfloat near = <span class="hljs-number">1.0f</span>;<br>GLfloat far = <span class="hljs-number">25.0f</span>;<br><span class="hljs-comment">// 90度我们才能保证视野足够大到可以合适地填满立方体贴图的一个面，立方体贴图的所有面都能与其他面在边缘对齐。</span><br>glm::mat4 shadowProj = glm::perspective(glm::radians(<span class="hljs-number">90.0f</span>), aspect, near, far);<br></code></pre></td></tr></table></figure><ul><li>由于观察方向不同，视图矩阵需要根据不同观察方向做调整，方向依次为右、左、上、下、近、远，直接保存PV矩阵相乘的结果供几何着色器后续使用：</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;glm::mat4&gt; shadowTransforms;<br>shadowTransforms.push_back(shadowProj *<br>                 glm::lookAt(lightPos, lightPos + glm::vec3(<span class="hljs-number">1.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>), glm::vec3(<span class="hljs-number">0.0</span>,<span class="hljs-number">-1.0</span>,<span class="hljs-number">0.0</span>));<br>shadowTransforms.push_back(shadowProj *<br>                 glm::lookAt(lightPos, lightPos + glm::vec3(<span class="hljs-number">-1.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>), glm::vec3(<span class="hljs-number">0.0</span>,<span class="hljs-number">-1.0</span>,<span class="hljs-number">0.0</span>));<br>shadowTransforms.push_back(shadowProj *<br>                 glm::lookAt(lightPos, lightPos + glm::vec3(<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>,<span class="hljs-number">0.0</span>), glm::vec3(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>));<br>shadowTransforms.push_back(shadowProj *<br>                 glm::lookAt(lightPos, lightPos + glm::vec3(<span class="hljs-number">0.0</span>,<span class="hljs-number">-1.0</span>,<span class="hljs-number">0.0</span>), glm::vec3(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">-1.0</span>));<br>shadowTransforms.push_back(shadowProj *<br>                 glm::lookAt(lightPos, lightPos + glm::vec3(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">1.0</span>), glm::vec3(<span class="hljs-number">0.0</span>,<span class="hljs-number">-1.0</span>,<span class="hljs-number">0.0</span>));<br>shadowTransforms.push_back(shadowProj *<br>                 glm::lookAt(lightPos, lightPos + glm::vec3(<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>,<span class="hljs-number">-1.0</span>), glm::vec3(<span class="hljs-number">0.0</span>,<span class="hljs-number">-1.0</span>,<span class="hljs-number">0.0</span>));<br></code></pre></td></tr></table></figure><h3 id="在着色器中将深度贴图生成"><a href="#在着色器中将深度贴图生成" class="headerlink" title="在着色器中将深度贴图生成"></a>在着色器中将深度贴图生成</h3><h4 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h4><ul><li>简单地将顶点变换到世界空间，然后直接发送到几何着色器。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> position;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = model * <span class="hljs-type">vec4</span>(position, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="几何着色器"><a href="#几何着色器" class="headerlink" title="几何着色器"></a>几何着色器</h4><ul><li>几何着色器以3个三角形的顶点作为输入，它还有一个光空间变换矩阵的uniform数组。几何着色器接下来会负责将顶点变换到光空间。</li><li>当有一个附加到激活的帧缓冲的立方体贴图纹理时，在几何着色器中能通过gl_Layer指定将基本图形发送在立方体贴图的哪一个面。当不管它时，几何着色器就会像往常一样把它的基本图形发送到输送管道的下一阶段。</li><li>通过把面的光空间变换矩阵乘以FragPos，将每个世界空间顶点变换到相关的光空间，生成每个三角形。注意，我们还要将最后的FragPos变量发送给片段着色器，我们需要计算一个深度值。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">triangles</span>) <span class="hljs-keyword">in</span>;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">triangle_strip</span>, <span class="hljs-keyword">max_vertices</span>=<span class="hljs-number">18</span>) <span class="hljs-keyword">out</span>;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> shadowMatrices[<span class="hljs-number">6</span>];<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragPos; <span class="hljs-comment">// FragPos from GS (output per emitvertex)</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> face = <span class="hljs-number">0</span>; face &lt; <span class="hljs-number">6</span>; ++face)<br>    &#123;<br>        <span class="hljs-built_in">gl_Layer</span> = face; <span class="hljs-comment">// built-in variable that specifies to which face we render.</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) <span class="hljs-comment">// for each triangle's vertices</span><br>        &#123;<br>            FragPos = <span class="hljs-built_in">gl_in</span>[i].<span class="hljs-built_in">gl_Position</span>;<br>            <span class="hljs-built_in">gl_Position</span> = shadowMatrices[face] * FragPos;<br>            <span class="hljs-built_in">EmitVertex</span>();<br>        &#125;    <br>        <span class="hljs-built_in">EndPrimitive</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h4><ul><li>将来自几何着色器的FragPos、光的位置向量和视锥的远平面值作为输入。这里我们把fragment和光源之间的距离，映射到0到1的范围，把它写入为fragment的深度值。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> FragPos;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> lightPos;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> far_plane;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// get distance between fragment and light source</span><br>    <span class="hljs-type">float</span> lightDistance = <span class="hljs-built_in">length</span>(FragPos.xyz - lightPos);<br><br>    <span class="hljs-comment">// map to [0;1] range by dividing by far_plane</span><br>    lightDistance = lightDistance / far_plane;<br><br>    <span class="hljs-comment">// write this as modified depth</span><br>    <span class="hljs-built_in">gl_FragDepth</span> = lightDistance;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="渲染出阴影"><a href="#渲染出阴影" class="headerlink" title="渲染出阴影"></a>渲染出阴影</h2><ul><li><img src="/2019/04/20/点阴影/point_shadows.png" alt=""></li><li>由于使用片段与光源位置的向量即可用于与深度值比大小来确定是否生成阴影，又能用来在立方体贴图上进行深度值采样，所以这里我们不再需要将片段位置转换至光空间就能完成比较和采样。</li><li>closestDepth值现在在0到1的范围内了，所以我们先将其转换会0到far_plane的范围，这需要把它乘以far_plane。</li><li>片段着色器部分截取：</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-keyword">in</span> VS_OUT &#123;<br>    <span class="hljs-type">vec3</span> FragPos;<br>    <span class="hljs-type">vec3</span> Normal;<br>    <span class="hljs-type">vec2</span> TexCoords;<br>&#125; fs_in;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> diffuseTexture;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">samplerCube</span> depthMap;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> lightPos;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> viewPos;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">float</span> far_plane;<br><br><span class="hljs-type">float</span> ShadowCalculation(<span class="hljs-type">vec3</span> fragPos)<br>&#123;<br>    <span class="hljs-comment">// Get vector between fragment position and light position</span><br>    <span class="hljs-type">vec3</span> fragToLight = fragPos - lightPos;<br>    <span class="hljs-comment">// Use the light to fragment vector to sample from the depth map    </span><br>    <span class="hljs-type">float</span> closestDepth = <span class="hljs-built_in">texture</span>(depthMap, fragToLight).r;<br>    <span class="hljs-comment">// It is currently in linear range between [0,1]. Re-transform back to original value</span><br>    closestDepth *= far_plane;<br>    <span class="hljs-comment">// Now get current linear depth as the length between the fragment and light position</span><br>    <span class="hljs-type">float</span> currentDepth = <span class="hljs-built_in">length</span>(fragToLight);<br>    <span class="hljs-comment">// Now test for shadows</span><br>    <span class="hljs-type">float</span> bias = <span class="hljs-number">0.05</span>;<br>    <span class="hljs-type">float</span> shadow = currentDepth -  bias &gt; closestDepth ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<br><br>    <span class="hljs-keyword">return</span> shadow;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h2><h3 id="向所有邻近方向取样平滑"><a href="#向所有邻近方向取样平滑" class="headerlink" title="向所有邻近方向取样平滑"></a>向所有邻近方向取样平滑</h3><ul><li>由于万向阴影贴图基于传统阴影映射的原则，它便也继承了由解析度产生的非真实感，主要表现为锯齿严重，边缘锐利。如果你放大就会看到锯齿边了。PCF或称Percentage-closer filtering允许我们通过对fragment位置周围过滤多个样本，并对结果平均化。</li><li>可以向邻近取样，获取平均值来使得影子边缘平滑。</li><li><img src="/2019/04/20/点阴影/point_shadows_soft.png" alt=""></li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> shadow = <span class="hljs-number">0.0</span>;<br><span class="hljs-type">float</span> bias = <span class="hljs-number">0.05</span>;<br><span class="hljs-type">float</span> samples = <span class="hljs-number">4.0</span>;<br><span class="hljs-type">float</span> <span class="hljs-keyword">offset</span> = <span class="hljs-number">0.1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> x = -<span class="hljs-keyword">offset</span>; x &lt; <span class="hljs-keyword">offset</span>; x += <span class="hljs-keyword">offset</span> / (samples * <span class="hljs-number">0.5</span>))<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> y = -<span class="hljs-keyword">offset</span>; y &lt; <span class="hljs-keyword">offset</span>; y += <span class="hljs-keyword">offset</span> / (samples * <span class="hljs-number">0.5</span>))<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> z = -<span class="hljs-keyword">offset</span>; z &lt; <span class="hljs-keyword">offset</span>; z += <span class="hljs-keyword">offset</span> / (samples * <span class="hljs-number">0.5</span>))<br>        &#123;<br>            <span class="hljs-type">float</span> closestDepth = <span class="hljs-built_in">texture</span>(depthMap, fragToLight + <span class="hljs-type">vec3</span>(x, y, z)).r;<br>            closestDepth *= far_plane;   <span class="hljs-comment">// Undo mapping [0;1]</span><br>            <span class="hljs-keyword">if</span>(currentDepth - bias &gt; closestDepth)<br>                shadow += <span class="hljs-number">1.0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br>shadow /= (samples * samples * samples);<br></code></pre></td></tr></table></figure><h3 id="从偏移方向数组中取样平滑"><a href="#从偏移方向数组中取样平滑" class="headerlink" title="从偏移方向数组中取样平滑"></a>从偏移方向数组中取样平滑</h3><ul><li>向所有邻近方向取样进行平滑的效果很好，但取样次数较多，上面的例子中，每个像素需要取样64次。</li><li>大多数这些样本都是多余的，它们在原始方向向量近处采样，不如在采样方向向量的垂直方向进行采样更有意义。可是，没有（简单的）方式能够指出哪一个子方向是多余的，这就难了。有个技巧可以使用，用一个偏移量方向数组，它们差不多都是分开的，每一个指向完全不同的方向，剔除彼此接近的那些子方向。下面就是一个有着20个偏移方向的数组：</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec3</span> sampleOffsetDirections[<span class="hljs-number">20</span>] = <span class="hljs-type">vec3</span>[]<br>(<br>   <span class="hljs-type">vec3</span>( <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>), <span class="hljs-type">vec3</span>( <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>), <span class="hljs-type">vec3</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>), <span class="hljs-type">vec3</span>(<span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>),<br>   <span class="hljs-type">vec3</span>( <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>), <span class="hljs-type">vec3</span>( <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>), <span class="hljs-type">vec3</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>), <span class="hljs-type">vec3</span>(<span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>),<br>   <span class="hljs-type">vec3</span>( <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">0</span>), <span class="hljs-type">vec3</span>( <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">0</span>), <span class="hljs-type">vec3</span>(<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">0</span>), <span class="hljs-type">vec3</span>(<span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">0</span>),<br>   <span class="hljs-type">vec3</span>( <span class="hljs-number">1</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>), <span class="hljs-type">vec3</span>(<span class="hljs-number">-1</span>,  <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>), <span class="hljs-type">vec3</span>( <span class="hljs-number">1</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>), <span class="hljs-type">vec3</span>(<span class="hljs-number">-1</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>),<br>   <span class="hljs-type">vec3</span>( <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>,  <span class="hljs-number">1</span>), <span class="hljs-type">vec3</span>( <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">1</span>), <span class="hljs-type">vec3</span>( <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>), <span class="hljs-type">vec3</span>( <span class="hljs-number">0</span>,  <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)<br>);<br></code></pre></td></tr></table></figure><ul><li>然后我们把PCF算法与从sampleOffsetDirections得到的样本数量进行适配，使用它们从立方体贴图里采样。这么做的好处是与之前的PCF算法相比，我们需要的样本数量变少了。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> shadow = <span class="hljs-number">0.0</span>;<br><span class="hljs-type">float</span> bias = <span class="hljs-number">0.15</span>;<br><span class="hljs-type">int</span> samples = <span class="hljs-number">20</span>;<br><span class="hljs-type">float</span> viewDistance = <span class="hljs-built_in">length</span>(viewPos - fragPos);<br><span class="hljs-type">float</span> diskRadius = <span class="hljs-number">0.05</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; samples; ++i)<br>&#123;<br>    <span class="hljs-type">float</span> closestDepth = <span class="hljs-built_in">texture</span>(depthMap, fragToLight + sampleOffsetDirections[i] * diskRadius).r;<br>    closestDepth *= far_plane;   <span class="hljs-comment">// Undo mapping [0;1]</span><br>    <span class="hljs-keyword">if</span>(currentDepth - bias &gt; closestDepth)<br>        shadow += <span class="hljs-number">1.0</span>;<br>&#125;<br>shadow /= <span class="hljs-type">float</span>(samples);<br></code></pre></td></tr></table></figure><ul><li>另外，我们可以基于观察者里一个fragment的距离来改变diskRadius；这样我们就能根据观察者的距离来增加偏移半径了，当距离更远的时候阴影更柔和，更近了就更锐利。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> diskRadius = (<span class="hljs-number">1.0</span> + (viewDistance / far_plane)) / <span class="hljs-number">25.0</span>;<br></code></pre></td></tr></table></figure><ul><li><img src="/2019/04/20/点阴影/result.png" alt=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 点阴影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> 点阴影 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阴影映射</title>
      <link href="/2019/03/10/%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84/"/>
      <url>/2019/03/10/%E9%98%B4%E5%BD%B1%E6%98%A0%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 阴影映射学习笔记</p><p><img src="/2019/03/10/阴影映射/result.png" alt=""></p></blockquote><a id="more"></a><ul><li>阴影是光线被阻挡的结果；当一个光源的光线由于其他物体的阻挡不能够达到一个物体的表面的时候，那么这个物体就在阴影中了。阴影能够使场景看起来真实得多，并且可以让观察者获得物体之间的空间位置关系。场景和物体的深度感因此能够得到极大提升。</li></ul><h2 id="阴影映射-Shadow-Mapping"><a href="#阴影映射-Shadow-Mapping" class="headerlink" title="阴影映射(Shadow Mapping)"></a>阴影映射(Shadow Mapping)</h2><ul><li><p>在物理上，产生阴影的原因是由于发射至阴影处的光中途被其他物体截断了导致。从这种想法触发，对阴影映射的计算思路便顺势出来了。从光的位置及方向观测物体，所有看不见的部分都将被置于阴影中。</p></li><li><p><img src="/2019/03/10/阴影映射/shadow_mapping_theory.png" alt="阴影原理"></p></li><li><p>上图用来展示阴影映射的思路，蓝线部分表示会被光照射到，不会产生阴影，黑线部分光由于被挡住而无法到达，从而形成阴影。</p></li><li><p><img src="/2019/03/10/阴影映射/shadow_mapping_theory_spaces.png" alt=""></p></li><li>在绘制物体的时候，想要知道其上某一像素点是否在阴影当中，我们需要知道其是否有被什么东西遮挡住，是否是与光源连线中离光源最近的点。因此，我们较容易想到的方式便是，在判断某点A是否处于阴影中时，将观测点转移至光源所在点处来观测该点A，若从该视角下看不到点A，则表示点A在阴影之中。而要判断在某视角下某点是否能被看到，即为判断是否能被渲染，即为判断其能否通过深度测试。</li><li>因此，我们只需要生成一张存储着从光源视角所获得的各个点的最大深度值的纹理，便能判断一个点是否能在该视角下通过深度测试，从而获知其是否在阴影之中。</li><li>如上图，观测点P，在经过视角变换（乘以变换矩阵T）之后，获得其z值为0.9，而在光源视角下对应点的最大深度值为0.4，故点P不能通过深度测试，故其在阴影之中。</li></ul><h2 id="深度贴图-Depth-Map"><a href="#深度贴图-Depth-Map" class="headerlink" title="深度贴图(Depth Map)"></a>深度贴图(Depth Map)</h2><ul><li>我们管储存在纹理中的所有这些深度值，叫做深度贴图（depth map）或阴影贴图。深度贴图是从光的透视图里渲染的深度纹理，用它计算阴影。因为我们需要将场景的渲染结果储存到一个纹理中，我们将再次需要帧缓冲。</li></ul><h3 id="生成深度贴图"><a href="#生成深度贴图" class="headerlink" title="生成深度贴图"></a>生成深度贴图</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c">GLuint depthMapFBO;<br>glGenFramebuffers(<span class="hljs-number">1</span>, &amp;depthMapFBO);<br><br><span class="hljs-comment">// 深度贴图的解析度</span><br><span class="hljs-keyword">const</span> GLuint SHADOW_WIDTH = <span class="hljs-number">1024</span>, SHADOW_HEIGHT = <span class="hljs-number">1024</span>;<br><br>GLuint depthMap;<br>glGenTextures(<span class="hljs-number">1</span>, &amp;depthMap);<br>glBindTexture(GL_TEXTURE_2D, depthMap);<br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_DEPTH_COMPONENT,<br>             SHADOW_WIDTH, SHADOW_HEIGHT, <span class="hljs-number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="hljs-literal">NULL</span>);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br><br>glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);<br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthMap, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 我们需要的只是在从光的透视图下渲染场景的时候深度信息，所以颜色缓冲没有用。</span><br><span class="hljs-comment">// 我们通过将调用glDrawBuffer和glReadBuffer把读和绘制缓冲设置为GL_NONE,</span><br><span class="hljs-comment">// 来显式告诉OpenGL我们不适用任何颜色数据进行渲染。</span><br>glDrawBuffer(GL_NONE);<br>glReadBuffer(GL_NONE);<br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><br>...<br><span class="hljs-comment">// 1. 首选渲染深度贴图</span><br><span class="hljs-comment">// 因为阴影贴图经常和我们原来渲染的场景（通常是窗口解析度）有着不同的解析度，</span><br><span class="hljs-comment">// 我们需要改变视口（viewport）的参数以适应阴影贴图的尺寸。</span><br><span class="hljs-comment">// 如果我们忘了更新视口参数，最后的深度贴图要么太小要么就不完整。</span><br>glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SHADOW_WIDTH, SHADOW_HEIGHT);<br>glBindFramebuffer(GL_FRAMEBUFFER, depthMapFBO);<br>    glClear(GL_DEPTH_BUFFER_BIT);<br>    ConfigureShaderAndMatrices();<br>    RenderScene();<br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 2. 像往常一样渲染场景，但这次使用深度贴图</span><br>glViewport(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCR_WIDTH, SCR_HEIGHT);<br>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>ConfigureShaderAndMatrices();<br>glBindTexture(GL_TEXTURE_2D, depthMap);<br>RenderScene();<br></code></pre></td></tr></table></figure><h3 id="光源空间的变换"><a href="#光源空间的变换" class="headerlink" title="光源空间的变换"></a>光源空间的变换</h3><ul><li>如之前所说，我们需要对观测点变换至从光源视角下来观测，这种变换叫做光源空间的变换。</li><li>想进行光源空间变换，我们需要知道光源空间的投影和视图矩阵，然后通过变换矩阵乘以观测点，将观测点转换至光源空间。</li><li>这里使用平行光为光源，所以投影矩阵是正交投影矩阵。</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">GLfloat near_plane = <span class="hljs-number">1.0f</span>, far_plane = <span class="hljs-number">7.5f</span>;<br>glm::mat4 lightProjection = glm::ortho(<span class="hljs-number">-10.0f</span>, <span class="hljs-number">10.0f</span>, <span class="hljs-number">-10.0f</span>, <span class="hljs-number">10.0f</span>, near_plane, far_plane);<br>glm::mat4 lightView = glm::lookAt(glm::vec(<span class="hljs-number">-2.0f</span>, <span class="hljs-number">4.0f</span>, <span class="hljs-number">-1.0f</span>), glm::vec3(<span class="hljs-number">0.0f</span>), glm::vec3(<span class="hljs-number">1.0</span>));<br>glm::mat4 lightSpaceMatrix = lightProjection * lightView;<br></code></pre></td></tr></table></figure><ul><li>这个lightSpaceMatrix正是前面我们称为T的那个变换矩阵。有了lightSpaceMatrix只要给shader提供光空间的投影和视图矩阵，我们就能像往常那样渲染场景了。</li></ul><h3 id="渲染至深度贴图"><a href="#渲染至深度贴图" class="headerlink" title="渲染至深度贴图"></a>渲染至深度贴图</h3><ul><li><img src="/2019/03/10/阴影映射/shadow_mapping_depth_map.png" alt="深度贴图"></li><li>对于深度贴图，只需要把顶点变换到光空间即可，故顶点着色器只需做空间变换即可。由于底层无论如何都会默认去设置深度缓冲，所以片段着色器不需要做什么额外操作。<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// vertex.vs</span><br><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> position;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> lightSpaceMatrix;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = lightSpaceMatrix * model * <span class="hljs-type">vec4</span>(position, <span class="hljs-number">1.0</span>f);<br>&#125;<br><br><span class="hljs-comment">// fragment.fs</span><br><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-type">void</span> main()<br>&#123;             <br>    <span class="hljs-comment">// gl_FragDepth = gl_FragCoord.z;</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="渲染阴影"><a href="#渲染阴影" class="headerlink" title="渲染阴影"></a>渲染阴影</h2><ul><li><p>有了深度贴图后，我们就能在片段着色器中判断一个点是否在阴影之中了。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">ShadowCalculation</span><span class="hljs-params">(vec4 fragPosLightSpace)</span><br></span>&#123;<br>    <span class="hljs-comment">// 执行透视除法</span><br>    vec3 projCoords = fragPosLightSpace.xyz / fragPosLightSpace.w;<br>    <span class="hljs-comment">// 变换到[0,1]的范围</span><br>    projCoords = projCoords * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>;<br>    <span class="hljs-comment">// 取得最近点的深度(使用[0,1]范围下的fragPosLight当坐标)</span><br>    <span class="hljs-keyword">float</span> closestDepth = texture(shadowMap, projCoords.xy).r;<br>    <span class="hljs-comment">// 取得当前片元在光源视角下的深度</span><br>    <span class="hljs-keyword">float</span> currentDepth = projCoords.z;<br>    <span class="hljs-comment">// 检查当前片元是否在阴影中</span><br>    <span class="hljs-keyword">float</span> shadow = currentDepth &gt; closestDepth  ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<br><br>    <span class="hljs-keyword">return</span> shadow;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>由于fragPosLightSpace不是由gl_Position传过来的，所以其并未有执行透视除法，所以需要手动对其执行透视除法。（虽然我们的例子是平截头体，w必然为1，但为了与锥视体统一代码，这里保留透视除法。）</p></li><li>projCoords目前属于NDC坐标，其取值范围为[-1, 1]，为了能从纹理从采样以及与采样结果中的z值进行比较，需要将其转换至[0, 1]范围中。</li><li>最后，我们对处于阴影中的像素点只保留环境光，去掉漫反射光和镜面反射光，得到效果如下图：</li><li><img src="/2019/03/10/阴影映射/render_shadow.png" alt="渲染阴影"></li></ul><h2 id="改进阴影贴图"><a href="#改进阴影贴图" class="headerlink" title="改进阴影贴图"></a>改进阴影贴图</h2><ul><li>渲染阴影中存在着大量肉眼可见且不可接受的问题，我们需要对其进行一定改进。</li></ul><h3 id="阴影失真-Shadow-Acne"><a href="#阴影失真-Shadow-Acne" class="headerlink" title="阴影失真(Shadow Acne)"></a>阴影失真(Shadow Acne)</h3><ul><li><p>渲染阴影图中明显交替出现的黑色阴影便是阴影失真。</p></li><li><p><img src="/2019/03/10/阴影映射/shadow_mapping_acne_diagram.png" alt="阴影失真成因"></p></li><li><p>图中蓝色线段表示在阴影贴图中的一个像素，由于解析度的问题，存在多个像素从阴影贴图中同一个点采样的情况。如在生成阴影贴图时，由于光源视角较高，导致较低视角下的两个像素点（A和B）在光源视角下只能保留一个（A），又由于视角与平面形成一定的角度，导致平面上每个点的z值不完全一样，于是深度贴图便只保留下了A点的z值。A点的z值相比B点的z值较小，在判断B点是否在阴影中时，在深度贴图中采样到的是A点的结果，由于z值比A点的大，故认为其处于阴影中。</p></li><li><p><img src="/2019/03/10/阴影映射/shadow_mapping_acne_bias.png" alt="阴影偏移"></p></li><li>针对阴影失真，可以使用阴影偏移（shadow bias）的技巧来解决这个问题，我们简单的对表面的深度（或深度贴图）应用一个偏移量，这样片元就不会被错误地认为在表面之下了。</li><li>光照方向与表面法线夹角越大，偏移量越大。<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> bias = <span class="hljs-built_in">max</span>(<span class="hljs-number">0.05</span> * (<span class="hljs-number">1.0</span> - <span class="hljs-built_in">dot</span>(normal, lightDir)), <span class="hljs-number">0.005</span>);<br><span class="hljs-type">float</span> shadow = currentDepth - bias &gt; closestDepth  ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<br></code></pre></td></tr></table></figure></li></ul><h3 id="悬浮-Peter-Panning"><a href="#悬浮-Peter-Panning" class="headerlink" title="悬浮(Peter Panning)"></a>悬浮(Peter Panning)</h3><ul><li>不懂，尚不理解，以及在贴地物体如果用正面剔除，悬浮更严重。用正面剔除能消除彼得潘问题尚未理解，实验结果也未能看出能消除。</li><li>在不添加阴影偏移时，阴影紧贴着物体。</li><li><p><img src="/2019/03/10/阴影映射/without_bias.png" alt="不添加阴影偏移"></p></li><li><p>添加了阴影偏移后，阴影相对物体出现了一定的位移，这是因为减去bias后，使得较小的currentDepth不再大于closestDepth，从而其被判断为非阴影，从而出现悬浮。</p></li><li><p><img src="/2019/03/10/阴影映射/peter_panning.png" alt="悬浮"></p></li><li><p>使用正面剔除后再来生成阴影贴图，发现箱子边缘出现非阴影带，这是因为剔除正面后，改用背面来生成阴影贴图，底部贴图由于太靠近场景面板，在减去bias后，不再认为其处于阴影之中，而两个背对光源的面的底下部分，也由于减去bias后，不再大于cloestDepth，从而造成非阴影带。</p></li><li><img src="/2019/03/10/阴影映射/front_cull.png" alt="使用正面剔除"></li></ul><h3 id="采样过多"><a href="#采样过多" class="headerlink" title="采样过多"></a>采样过多</h3><ul><li>光的视锥不可见的区域一律被认为是处于阴影中，不管它真的处于阴影之中。出现这个状况是因为超出光的视锥的投影坐标比1.0大，这样采样的深度纹理就会超出他默认的0到1的范围。根据纹理环绕方式为GL_REPEAT，我们将会得到不正确的深度结果，它不是基于真实的来自光源的深度值。即，同一个阴影会由于设置了纹理环绕方式，而多次出现。</li><li><p>对此，让所有超出深度贴图的坐标的深度范围是1.0，这样超出的坐标将永远不在阴影之中。我们可以储存一个边框颜色，然后把深度贴图的纹理环绕选项设置为GL_CLAMP_TO_BORDER。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);<br>GLfloat borderColor[] = &#123; <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span> &#125;;<br>glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);<br></code></pre></td></tr></table></figure></li><li><p>当坐标超出了光的正交视锥的远平面。可以看到这片黑色区域总是出现在光源视锥的极远处。当一个点比光的远平面还要远时，它的投影坐标的z坐标大于1.0。这种情况下，GL_CLAMP_TO_BORDER环绕方式不起作用，因为我们把坐标的z元素和深度贴图的值进行了对比；它总是为大于1.0的z返回true。</p></li><li><p>如果投影向量的z坐标大于1.0，我们就把shadow的值强制设为0.0：</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> ShadowCalculation(<span class="hljs-type">vec4</span> fragPosLightSpace)<br>&#123;<br>    [...]<br>    <span class="hljs-keyword">if</span>(projCoords.z &gt; <span class="hljs-number">1.0</span>)<br>        shadow = <span class="hljs-number">0.0</span>;<br><br>    <span class="hljs-keyword">return</span> shadow;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/03/10/阴影映射/over_sampling_fixed.png" alt="修正过度采样"></p></li></ul><h2 id="PCF"><a href="#PCF" class="headerlink" title="PCF"></a>PCF</h2><ul><li>在上面的阴影结果中，我们都能很明显的看到锯齿边，这是因为深度贴图有一个固定的解析度，多个片元对应于一个纹理像素。结果就是多个片元会从深度贴图的同一个深度值进行采样，这几个片元便得到的是同一个阴影，这就会产生锯齿边。</li><li><p>采用类似于抗锯齿中多次采样的方式，一个简化版的PCF核心思想是从深度贴图中多次采样，每一次采样的纹理坐标都稍有不同。每个独立的样本可能在也可能不再阴影中。所有的次生结果接着结合在一起，进行平均化，我们就得到了柔和阴影。</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> shadow = <span class="hljs-number">0.0</span>;<br><span class="hljs-comment">// 这个textureSize返回一个给定采样器纹理的0级mipmap的vec2类型的宽和高。</span><br><span class="hljs-comment">// 用1除以它返回一个单独纹理像素的大小</span><br><span class="hljs-type">vec2</span> texelSize = <span class="hljs-number">1.0</span> / <span class="hljs-built_in">textureSize</span>(shadowMap, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">-1</span>; x &lt;= <span class="hljs-number">1</span>; ++x)<br>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">-1</span>; y &lt;= <span class="hljs-number">1</span>; ++y)<br>    &#123;<br>        <span class="hljs-type">float</span> pcfDepth = <span class="hljs-built_in">texture</span>(shadowMap, projCoords.xy + <span class="hljs-type">vec2</span>(x, y) * texelSize).r;<br>        shadow += currentDepth - bias &gt; pcfDepth ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;        <br>    &#125;    <br>&#125;<br>shadow /= <span class="hljs-number">9.0</span>;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/03/10/阴影映射/pcf.png" alt="PCF"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 阴影映射 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gamma校正</title>
      <link href="/2019/03/03/Gamma%E6%A0%A1%E6%AD%A3/"/>
      <url>/2019/03/03/Gamma%E6%A0%A1%E6%AD%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> Gamma校正学习笔记</p><p>Gamma校正</p></blockquote><a id="more"></a><h2 id="灰阶"><a href="#灰阶" class="headerlink" title="灰阶"></a>灰阶</h2><ul><li><img src="/2019/03/03/Gamma校正/gamma_correction_brightness.png" alt="灰阶图"></li><li>第一行是人眼所感知的正常灰阶图，第二行是根据如光子数量所展现出来的物理世界真实的灰阶图。</li><li>物理亮度和感知亮度的区别在于，物理亮度基于光子数量，感知亮度基于人的感觉，比如第二个灰阶里亮度0.1的光子数量是0.2的二分之一。</li><li><p>通过上图表明，人眼对亮度的感知并不是线性的。人眼对亮度的感知值约为真实亮度值的2次幂。</p></li><li><p><img src="/2019/03/03/Gamma校正/gamma_correction_gamma_curves.png" style="width: 400px;" alt="Gamma校正曲线"></p></li><li>CRT显示器亮度是电压的2.2次幂，与人眼的2次幂相当，因此物理亮度通过CRT显示器显示的效果与人眼相近，所以看起来效果是不错的。</li><li>需要注意的是，在物理线性空间或CRT校正后的曲线空间中，亮度的最小值都是0，最大值都为1，仅是中间部分的亮度被压低，但也因人眼对低亮度更敏感，所以压低亮度刚好符合人眼感知灰度图。</li><li>由于此映射关系不是线性映射，在线性空间（gamma=1）中对亮度做倍数处理，其展现效果值并不是相同倍数（指数值结果上不同倍数，实际人眼感知上提高的是相同倍数），如在gamma=1的线性空间中对亮度0.5提高至1.0，其在gamma=2.2空间中的亮度变化则为0.218提高至1.0，约为4.5倍。</li></ul><h2 id="Gamma校正"><a href="#Gamma校正" class="headerlink" title="Gamma校正"></a>Gamma校正</h2><ul><li>上面提到，gamma=2.2刚好是符合人眼感知的，为何我们仍需要进行gamma校正？因为我们在程序中设置颜色、光照等都是基于线性空间（gammma=1）来设置的，我们希望最终颜色在显示器中输出的结果与线性空间中计算到的一致。</li><li>在将颜色显示到显示器之前，我们先对颜色应用Gamma校正曲线。线性的颜色显示在显示器上相当于降低了2.2次幂的亮度，所以Gamma校正便是对线性的颜色取1/2.2次幂。</li></ul><h3 id="OpenGL中使用Gamma校正"><a href="#OpenGL中使用Gamma校正" class="headerlink" title="OpenGL中使用Gamma校正"></a>OpenGL中使用Gamma校正</h3><h4 id="使用OpenGL内建的sRGB帧缓冲"><a href="#使用OpenGL内建的sRGB帧缓冲" class="headerlink" title="使用OpenGL内建的sRGB帧缓冲"></a>使用OpenGL内建的sRGB帧缓冲</h4><ul><li>开启GL_FRAMEBUFFER_SRGB，可以告诉OpenGL每个后续的绘制命令里，在颜色储存到颜色缓冲之前先校正sRGB颜色。sRGB这个颜色空间大致对应于gamma2.2，它也是家用设备的一个标准。开启GL_FRAMEBUFFER_SRGB以后，每次片段着色器运行后续帧缓冲，OpenGL将自动执行gamma校正，包括默认帧缓冲。</li><li><p>开启GL_FRAMEBUFFER_SRGB简单的调用glEnable就行：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glEnable(GL_FRAMEBUFFER_SRGB);<br></code></pre></td></tr></table></figure></li><li><p>我们只需要在最后一步进行gamma校正，如果在最后输出之前就进行gamma校正，所有的后续操作都是在操作不正确的颜色值。例如，如果你使用多个帧缓冲，你可能打算让两个帧缓冲之间传递的中间结果仍然保持线性空间颜色，只是给发送给显示器的最后的那个帧缓冲应用gamma校正。</p></li></ul><h4 id="在片段着色器最后应用gamma校正"><a href="#在片段着色器最后应用gamma校正" class="headerlink" title="在片段着色器最后应用gamma校正"></a>在片段着色器最后应用gamma校正</h4><ul><li><p>颜色在发送到帧缓冲前，其颜色就被校正了。</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// do super fancy lighting</span><br>    [...]<br>    <span class="hljs-comment">// apply gamma correction</span><br>    <span class="hljs-type">float</span> gamma = <span class="hljs-number">2.2</span>;<br>    fragColor.rgb = <span class="hljs-built_in">pow</span>(fragColor.rgb, <span class="hljs-type">vec3</span>(<span class="hljs-number">1.0</span>/gamma));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>此方法繁琐的地方在于需要在每个片段着色器的最后都应用gamma校正。一个更简单的方案是在你的渲染循环中引入后处理阶段，在后处理四边形上应用gamma校正，这样你只要做一次就好了。</p></li></ul><h3 id="sRGB纹理"><a href="#sRGB纹理" class="headerlink" title="sRGB纹理"></a>sRGB纹理</h3><ul><li>由于我们绘制及编辑图像的时候是在应用了gamma校正的显示器中进行了，因此，制作出来的图像可以理解为已经进行过一次gamma校正了。对于这种图像纹理，如果我们再使用gamma校正，就相当于对其进行了两次gamma校正，其颜色结果整体上会偏亮很多。</li><li><img src="/2019/03/03/Gamma校正/gamma_correction_srgbtextures.png" alt="对sRGB纹理进行gamma校正对比"></li><li><p>OpenGL提供了GL_SRGB和GL_SRGB_ALPHA内部纹理格式，如果我们在OpenGL中创建了一个纹理，把它指定为以上两种sRGB纹理格式其中之一，OpenGL将自动把颜色校正到线性空间中，这样我们所使用的所有颜色值都是在线性空间中的了。我们可以这样把一个纹理指定为一个sRGB纹理：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_SRGB, width, height, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, image);<br></code></pre></td></tr></table></figure></li><li><p>因为不是所有纹理都是在sRGB空间中的所以当你把纹理指定为sRGB纹理时要格外小心。比如diffuse纹理，这种为物体上色的纹理几乎都是在sRGB空间中的。而为了获取光照参数的纹理，像specular贴图和法线贴图几乎都在线性空间中，所以如果你把它们也配置为sRGB纹理的话，光照就坏掉了。指定sRGB纹理时要当心。</p></li><li><p>直接对sRGB空间的颜色进行混合，会出现1+1&gt;2的效果，如下图中明显的相交光圈。将sRGB颜色映射回线性空间再进行混合，能得到合理的效果。这是因为，我们想要的是对输出的颜色值进行混合，而直接操作sRGB值相当于对输出的颜色值的自变量进行操作，而从自变量到输出颜色的过程并不是线性的，从而造成明显的光圈。即 $f=x^{2.2}$ ，sRGB即为x值，我们想要的是对f进行线性改变，因此对x做线性改变是不行的。</p></li><li><p><img src="/2019/03/03/Gamma校正/linearspot.jpg" style="width: 400px;" alt="sRGB空间颜色混合"></p></li><li><img src="/2019/03/03/Gamma校正/gammaspot.jpg" style="width: 400px;" alt="线性空间颜色混合"></li></ul><h3 id="衰减"><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h3><ul><li>此前，我们使用的光照衰减方程为：<script type="math/tex; mode=display">F_{att} = \frac{1.0}{K_{c} + K_{l} * d + K_{q} * d^2}</script></li><li>该方程给予我们调整距离常数与距离的平方的常数，给了我们很大的自由性。</li><li><p>真实的物理世界中，光照的衰减和光源的距离的平方成反比。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">float</span> attenuation = <span class="hljs-number">1.0</span> / (distance * distance);<br></code></pre></td></tr></table></figure></li><li><p>然而，当我们使用这个衰减公式的时候，衰减效果总是过于强烈，光只能照亮一小圈，看起来并不真实。改用双曲线函数却能取到较好的效果：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">float</span> attenuation = <span class="hljs-number">1.0</span> / distance;<br></code></pre></td></tr></table></figure></li><li><p>双曲线比使用二次函数变体在不用gamma校正的时候看起来更真实，不过但我们开启gamma校正以后双曲线衰减看起来太弱了，符合物理的二次函数突然出现了更好的效果。下图显示了其中的不同：</p></li><li><img src="/2019/03/03/Gamma校正/gamma_correction_attenuation.png" alt="衰减对比"></li><li><p>这种差异产生的原因是，光的衰减方程改变了亮度值，而且屏幕上显示出来的也不是线性空间，在显示器上效果最好的衰减方程，并不是符合物理的。想想平方衰减方程，如果我们使用这个方程，而且不进行gamma校正，显示在监视器上的衰减方程实际上将变成 $(1.0 / distance^2)^{2.2}$ 。若不进行gamma校正，将产生更强烈的衰减。这也解释了为什么双曲线不用gamma校正时看起来更真实，因为它实际变成了 $(1.0 / distance)^{2.2} = 1.0 / distance^{2.2}$ 。这和物理公式是很相似的。</p></li><li><p>gamma校正使你可以在线性空间中进行操作。因为线性空间更符合物理世界，大多数物理公式现在都可以获得较好效果，比如真实的光的衰减。你的光照越真实，使用gamma校正获得漂亮的效果就越容易。这也正是为什么当引进gamma校正时，建议只去调整光照参数的原因。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> Gamma校正 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DXT压缩纹理格式</title>
      <link href="/2019/02/24/DXT%E5%8E%8B%E7%BC%A9%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/02/24/DXT%E5%8E%8B%E7%BC%A9%E7%BA%B9%E7%90%86%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>DXT1，DXT3和DXT5三种压缩纹理的内存格式及其计算RGB及alpha值的方式。<br><a id="more"></a></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>DXT1，DXT3和DXT5三种压缩纹理格式均是将图片切割成4X4的小块(Block)做独立的压缩处理，这就要求图片的长和宽都必须是4的整数倍。这种压缩方式与传统基于图片整体信息进行压缩的方式（如jpg的哈夫曼压缩）相比，其压缩率会较低，但由于每个4X4的小块(Block)的压缩是独立进行的，其十分适合应用于显卡的并行运算。</li></ul><h2 id="DXT1"><a href="#DXT1" class="headerlink" title="DXT1"></a>DXT1</h2><ul><li><img src="/2019/02/24/DXT压缩纹理格式/dxt1_format.jpg" alt="DXT1纹理格式"></li><li>DXT1的每个4X4小块大小为64bits，其内存结构如上图所示。块的前32bits用来存储两个565格式的颜色，这里记为<font color="#D2691E" size="4"> <em>color_0</em> </font>和<font color="#D2691E" size="4"> <em>color_1</em> </font>，剩余32bits分成4X4个格子，每个格子占2bits，每个格子各自对应一个像素。</li><li><p>每个格子占2bits，可以表示4种状态，分别用RGB0，RGB1，RGB2，RGB3表示，每种状态下的颜色取值情况如下：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span> color_0 &gt; color_1:<br>    <span class="hljs-number">1.</span> RGB0 = Color565toRGB(color_0)<br>    <span class="hljs-number">1.</span> RGB1 = Color565toRGB(color_1)<br>    <span class="hljs-number">1.</span> RGB2 = (<span class="hljs-number">2</span>*RGB0 + RGB1) / <span class="hljs-number">3</span><br>    <span class="hljs-number">1.</span> RGB3 = (RGB0 + <span class="hljs-number">2</span>*RGB1) / <span class="hljs-number">3</span><br><span class="hljs-number">2.</span> color_0 &lt;= color_1:<br>    <span class="hljs-number">1.</span> RGB0 = Color565toRGB(color_0)<br>    <span class="hljs-number">1.</span> RGB1 = Color565toRGB(color_1)<br>    <span class="hljs-number">1.</span> RGB2 = (RGB0 + RGB1) / <span class="hljs-number">2</span><br>    <span class="hljs-number">1.</span> RGB3 = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></li><li><p>除了RGB3 = (0, 0, 0, 0)的情况，其余情况的alpha值均为0xFF，即DXT1纹理格式对alpha通道的支持为要么全透，要么全不透，一个4X4的块中其最多表示4种不同颜色，存储2个565格式的颜色及通过线性插值获得另外2个颜色。</p></li><li><p>关于color_0和color_1的颜色是如何确定的，我没有细看生成的代码，做过一些简单测试，对于一个4X4仅含有(0,0,0,255), (1,0,0,255), (2,0,0,255), (3,0,0,255)四种颜色的bmp图，用Nvidia提供的Nvdxt工具转成的DXT1格式，发现里面只剩下三种颜色了。</p></li><li><p>DXT1块具体解析的代码如下：</p></li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// DXT1 block.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BlockDXT1</span><br>&#123;</span><br>    Color16 col0;<br>    Color16 col1;<br>    <span class="hljs-keyword">union</span> &#123;<br>        uint8 row[<span class="hljs-number">4</span>];<br>        uint indices;<br>    &#125;;<br>&#125;;<br><br>uint BlockDXT1::evaluatePalette(Color32 color_array[<span class="hljs-number">4</span>], <span class="hljs-keyword">bool</span> d3d9<span class="hljs-comment">/*= false*/</span>) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-comment">// Does bit expansion before interpolation.</span><br>    color_array[<span class="hljs-number">0</span>].b = (col0.b &lt;&lt; <span class="hljs-number">3</span>) | (col0.b &gt;&gt; <span class="hljs-number">2</span>);<br>    color_array[<span class="hljs-number">0</span>].g = (col0.g &lt;&lt; <span class="hljs-number">2</span>) | (col0.g &gt;&gt; <span class="hljs-number">4</span>);<br>    color_array[<span class="hljs-number">0</span>].r = (col0.r &lt;&lt; <span class="hljs-number">3</span>) | (col0.r &gt;&gt; <span class="hljs-number">2</span>);<br>    color_array[<span class="hljs-number">0</span>].a = <span class="hljs-number">0xFF</span>;<br><br>    color_array[<span class="hljs-number">1</span>].r = (col1.r &lt;&lt; <span class="hljs-number">3</span>) | (col1.r &gt;&gt; <span class="hljs-number">2</span>);<br>    color_array[<span class="hljs-number">1</span>].g = (col1.g &lt;&lt; <span class="hljs-number">2</span>) | (col1.g &gt;&gt; <span class="hljs-number">4</span>);<br>    color_array[<span class="hljs-number">1</span>].b = (col1.b &lt;&lt; <span class="hljs-number">3</span>) | (col1.b &gt;&gt; <span class="hljs-number">2</span>);<br>    color_array[<span class="hljs-number">1</span>].a = <span class="hljs-number">0xFF</span>;<br><br>    <span class="hljs-keyword">if</span>( col0.u &gt; col1.u ) &#123;<br>        <span class="hljs-keyword">int</span> bias = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (d3d9) bias = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// Four-color block: derive the other two colors.</span><br>        color_array[<span class="hljs-number">2</span>].r = (<span class="hljs-number">2</span> * color_array[<span class="hljs-number">0</span>].r + color_array[<span class="hljs-number">1</span>].r + bias) / <span class="hljs-number">3</span>;<br>        color_array[<span class="hljs-number">2</span>].g = (<span class="hljs-number">2</span> * color_array[<span class="hljs-number">0</span>].g + color_array[<span class="hljs-number">1</span>].g + bias) / <span class="hljs-number">3</span>;<br>        color_array[<span class="hljs-number">2</span>].b = (<span class="hljs-number">2</span> * color_array[<span class="hljs-number">0</span>].b + color_array[<span class="hljs-number">1</span>].b + bias) / <span class="hljs-number">3</span>;<br>        color_array[<span class="hljs-number">2</span>].a = <span class="hljs-number">0xFF</span>;<br><br>        color_array[<span class="hljs-number">3</span>].r = (<span class="hljs-number">2</span> * color_array[<span class="hljs-number">1</span>].r + color_array[<span class="hljs-number">0</span>].r + bias) / <span class="hljs-number">3</span>;<br>        color_array[<span class="hljs-number">3</span>].g = (<span class="hljs-number">2</span> * color_array[<span class="hljs-number">1</span>].g + color_array[<span class="hljs-number">0</span>].g + bias) / <span class="hljs-number">3</span>;<br>        color_array[<span class="hljs-number">3</span>].b = (<span class="hljs-number">2</span> * color_array[<span class="hljs-number">1</span>].b + color_array[<span class="hljs-number">0</span>].b + bias) / <span class="hljs-number">3</span>;<br>        color_array[<span class="hljs-number">3</span>].a = <span class="hljs-number">0xFF</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Three-color block: derive the other color.</span><br>        color_array[<span class="hljs-number">2</span>].r = (color_array[<span class="hljs-number">0</span>].r + color_array[<span class="hljs-number">1</span>].r) / <span class="hljs-number">2</span>;<br>        color_array[<span class="hljs-number">2</span>].g = (color_array[<span class="hljs-number">0</span>].g + color_array[<span class="hljs-number">1</span>].g) / <span class="hljs-number">2</span>;<br>        color_array[<span class="hljs-number">2</span>].b = (color_array[<span class="hljs-number">0</span>].b + color_array[<span class="hljs-number">1</span>].b) / <span class="hljs-number">2</span>;<br>        color_array[<span class="hljs-number">2</span>].a = <span class="hljs-number">0xFF</span>;<br><br>        <span class="hljs-comment">// Set all components to 0 to match DXT specs.</span><br>        color_array[<span class="hljs-number">3</span>].r = <span class="hljs-number">0x00</span>; <span class="hljs-comment">// color_array[2].r;</span><br>        color_array[<span class="hljs-number">3</span>].g = <span class="hljs-number">0x00</span>; <span class="hljs-comment">// color_array[2].g;</span><br>        color_array[<span class="hljs-number">3</span>].b = <span class="hljs-number">0x00</span>; <span class="hljs-comment">// color_array[2].b;</span><br>        color_array[<span class="hljs-number">3</span>].a = <span class="hljs-number">0x00</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">void</span> BlockDXT1::decodeBlock(ColorBlock * block, <span class="hljs-keyword">bool</span> d3d9<span class="hljs-comment">/*= false*/</span>) <span class="hljs-keyword">const</span><br>&#123;<br>    nvDebugCheck(block != <span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-comment">// Decode color block.</span><br>    Color32 color_array[<span class="hljs-number">4</span>];<br>    evaluatePalette(color_array, d3d9);<br><br>    <span class="hljs-comment">// Write color block.</span><br>    <span class="hljs-keyword">for</span>( uint j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++ ) &#123;<br>        <span class="hljs-keyword">for</span>( uint i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ ) &#123;<br>            uint idx = (row[j] &gt;&gt; (<span class="hljs-number">2</span> * i)) &amp; <span class="hljs-number">3</span>;<br>            block-&gt;color(i, j) = color_array[idx];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="DXT3"><a href="#DXT3" class="headerlink" title="DXT3"></a>DXT3</h2><ul><li><img src="/2019/02/24/DXT压缩纹理格式/dxt3_alphablock_format.jpg" alt="DXT3Alpha块格式"></li><li>DXT3的每个4X4小块大小为128bits，前64bits用来存储alpha信息的Alpha块，其内存结构如上图所示。后64bits用来存储颜色信息，其内存结构及解析方式与DXT1完全一致。</li><li>DXT3的Alpha块大小为64bits，均等分成16个小格子，每个格子占4bits，各自对应一个像素的alpha数据。</li><li><p>每个格子占4bits，可以表示16种状态，因此，DXT3可以表示16种不同的硬编码alpha值，每种状态对应的alpha值计算方式如下：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span> 设v为某个格子的具体状态值。<br><span class="hljs-number">2.</span> 该格子对应的alpha值则为：(v &lt;&lt; <span class="hljs-number">4</span>) | v 。<br><span class="hljs-number">3.</span> 例如格子(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)的二进制数据为<span class="hljs-number">0110</span>，则其状态值为<span class="hljs-number">6</span>。<br><span class="hljs-number">4.</span> 状态值对应的alpha值二进制格式为<span class="hljs-number">01100110</span>，转为十进制即为<span class="hljs-number">102</span>，即格子(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)的alpha值为<span class="hljs-number">102</span>。<br></code></pre></td></tr></table></figure></li><li><p>DXT3块具体解析的代码如下：</p></li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AlphaBlockDXT3</span><br>&#123;</span><br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            uint alpha0 : <span class="hljs-number">4</span>;<br>            uint alpha1 : <span class="hljs-number">4</span>;<br>            uint alpha2 : <span class="hljs-number">4</span>;<br>            uint alpha3 : <span class="hljs-number">4</span>;<br>            uint alpha4 : <span class="hljs-number">4</span>;<br>            uint alpha5 : <span class="hljs-number">4</span>;<br>            uint alpha6 : <span class="hljs-number">4</span>;<br>            uint alpha7 : <span class="hljs-number">4</span>;<br>            uint alpha8 : <span class="hljs-number">4</span>;<br>            uint alpha9 : <span class="hljs-number">4</span>;<br>            uint alphaA : <span class="hljs-number">4</span>;<br>            uint alphaB : <span class="hljs-number">4</span>;<br>            uint alphaC : <span class="hljs-number">4</span>;<br>            uint alphaD : <span class="hljs-number">4</span>;<br>            uint alphaE : <span class="hljs-number">4</span>;<br>            uint alphaF : <span class="hljs-number">4</span>;<br>        &#125;;<br>        uint16 row[<span class="hljs-number">4</span>];<br>    &#125;;<br>&#125;;<br><br><span class="hljs-keyword">void</span> AlphaBlockDXT3::decodeBlock(ColorBlock * block, <span class="hljs-keyword">bool</span> d3d9<span class="hljs-comment">/*= false*/</span>) <span class="hljs-keyword">const</span><br>&#123;<br>    block-&gt;color(<span class="hljs-number">0x0</span>).a = (alpha0 &lt;&lt; <span class="hljs-number">4</span>) | alpha0;<br>    block-&gt;color(<span class="hljs-number">0x1</span>).a = (alpha1 &lt;&lt; <span class="hljs-number">4</span>) | alpha1;<br>    block-&gt;color(<span class="hljs-number">0x2</span>).a = (alpha2 &lt;&lt; <span class="hljs-number">4</span>) | alpha2;<br>    block-&gt;color(<span class="hljs-number">0x3</span>).a = (alpha3 &lt;&lt; <span class="hljs-number">4</span>) | alpha3;<br>    block-&gt;color(<span class="hljs-number">0x4</span>).a = (alpha4 &lt;&lt; <span class="hljs-number">4</span>) | alpha4;<br>    block-&gt;color(<span class="hljs-number">0x5</span>).a = (alpha5 &lt;&lt; <span class="hljs-number">4</span>) | alpha5;<br>    block-&gt;color(<span class="hljs-number">0x6</span>).a = (alpha6 &lt;&lt; <span class="hljs-number">4</span>) | alpha6;<br>    block-&gt;color(<span class="hljs-number">0x7</span>).a = (alpha7 &lt;&lt; <span class="hljs-number">4</span>) | alpha7;<br>    block-&gt;color(<span class="hljs-number">0x8</span>).a = (alpha8 &lt;&lt; <span class="hljs-number">4</span>) | alpha8;<br>    block-&gt;color(<span class="hljs-number">0x9</span>).a = (alpha9 &lt;&lt; <span class="hljs-number">4</span>) | alpha9;<br>    block-&gt;color(<span class="hljs-number">0xA</span>).a = (alphaA &lt;&lt; <span class="hljs-number">4</span>) | alphaA;<br>    block-&gt;color(<span class="hljs-number">0xB</span>).a = (alphaB &lt;&lt; <span class="hljs-number">4</span>) | alphaB;<br>    block-&gt;color(<span class="hljs-number">0xC</span>).a = (alphaC &lt;&lt; <span class="hljs-number">4</span>) | alphaC;<br>    block-&gt;color(<span class="hljs-number">0xD</span>).a = (alphaD &lt;&lt; <span class="hljs-number">4</span>) | alphaD;<br>    block-&gt;color(<span class="hljs-number">0xE</span>).a = (alphaE &lt;&lt; <span class="hljs-number">4</span>) | alphaE;<br>    block-&gt;color(<span class="hljs-number">0xF</span>).a = (alphaF &lt;&lt; <span class="hljs-number">4</span>) | alphaF;<br>&#125;<br><br><span class="hljs-comment">/// DXT3 block.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BlockDXT3</span><br>&#123;</span><br>    AlphaBlockDXT3 alpha;<br>    BlockDXT1 color;<br>&#125;;<br><br><span class="hljs-keyword">void</span> BlockDXT3::decodeBlock(ColorBlock * block, <span class="hljs-keyword">bool</span> d3d9<span class="hljs-comment">/*= false*/</span>) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-comment">// Decode color.</span><br>    color.decodeBlock(block, d3d9);<br><br>    <span class="hljs-comment">// Decode alpha.</span><br>    alpha.decodeBlock(block, d3d9);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="DXT5"><a href="#DXT5" class="headerlink" title="DXT5"></a>DXT5</h2><ul><li><img src="/2019/02/24/DXT压缩纹理格式/dxt5_alphablock_format.jpg" alt="DXT5Alpha块格式"></li><li>DXT5的每个4X4小块大小为128bits，前64bits用来存储alpha信息的Alpha块，其内存结构如上图所示。后64bits用来存储颜色信息，其内存结构及解析方式与DXT1完全一致。</li><li>DXT5的Alpha块大小为64bits，块的前16bits用来存储两个alpha值，这里记为<font color="#D2691E" size="4"> <em>alpha_0</em> </font>和<font color="#D2691E" size="4"> <em>alpha_1</em> </font>，剩余48bits分成4X4个格子，每个格子占3bits，每个格子各自对应一个像素。</li><li><p>每个格子占3bits，可以表示8种状态，分别用Alpha0 - Alpha7表示，每种状态下的alpha取值情况如下：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">1.</span> alpha_0 &gt; alpha_1:<br>    <span class="hljs-number">0.</span> Alpha0 = alpha_0<br>    <span class="hljs-number">1.</span> Alpha1 = alpha_1<br>    <span class="hljs-number">2.</span> Alpha2 = (<span class="hljs-number">6</span> * Alpha0 + <span class="hljs-number">1</span> * Alpha1) / <span class="hljs-number">7</span><br>    <span class="hljs-number">3.</span> Alpha3 = (<span class="hljs-number">5</span> * Alpha0 + <span class="hljs-number">2</span> * Alpha1) / <span class="hljs-number">7</span><br>    <span class="hljs-number">4.</span> Alpha4 = (<span class="hljs-number">4</span> * Alpha0 + <span class="hljs-number">3</span> * Alpha1) / <span class="hljs-number">7</span><br>    <span class="hljs-number">5.</span> Alpha5 = (<span class="hljs-number">3</span> * Alpha0 + <span class="hljs-number">4</span> * Alpha1) / <span class="hljs-number">7</span><br>    <span class="hljs-number">6.</span> Alpha6 = (<span class="hljs-number">2</span> * Alpha0 + <span class="hljs-number">5</span> * Alpha1) / <span class="hljs-number">7</span><br>    <span class="hljs-number">7.</span> Alpha7 = (<span class="hljs-number">1</span> * Alpha0 + <span class="hljs-number">6</span> * Alpha1) / <span class="hljs-number">7</span><br><span class="hljs-number">2.</span> alpha_0 &lt;= alpha_1:<br>    <span class="hljs-number">0.</span> Alpha0 = alpha_0<br>    <span class="hljs-number">1.</span> Alpha1 = alpha_1<br>    <span class="hljs-number">2.</span> Alpha2 = (<span class="hljs-number">4</span> * Alpha0 + <span class="hljs-number">1</span> * Alpha1) / <span class="hljs-number">5</span><br>    <span class="hljs-number">3.</span> Alpha3 = (<span class="hljs-number">3</span> * Alpha0 + <span class="hljs-number">2</span> * Alpha1) / <span class="hljs-number">5</span><br>    <span class="hljs-number">4.</span> Alpha4 = (<span class="hljs-number">2</span> * Alpha0 + <span class="hljs-number">3</span> * Alpha1) / <span class="hljs-number">5</span><br>    <span class="hljs-number">5.</span> Alpha5 = (<span class="hljs-number">1</span> * Alpha0 + <span class="hljs-number">4</span> * Alpha1) / <span class="hljs-number">5</span><br>    <span class="hljs-number">6.</span> Alpha6 = <span class="hljs-number">0x00</span><br>    <span class="hljs-number">7.</span> Alpha7 = <span class="hljs-number">0xFF</span><br></code></pre></td></tr></table></figure></li><li><p>上面情况简言之，便是：</p><ul><li>对于<font color="#D2691E" size="4"> <em>alpha_0</em> &gt; <em>alpha_1</em> </font>的情况，Alpha0 = <font color="#D2691E" size="4"> <em>alpha_0</em> </font>，Alpha1 = <font color="#D2691E" size="4"> <em>alpha_1</em> </font>，余下6种颜色为Alpha0和Alpha1的线性插值结果。</li><li>对于<font color="#D2691E" size="4"> <em>alpha_0</em> &lt;= <em>alpha_1</em> </font>的情况，Alpha0 = <font color="#D2691E" size="4"> <em>alpha_0</em> </font>，Alpha1 = <font color="#D2691E" size="4"> <em>alpha_1</em> </font>，Alpha6=0x00，Alpha7=0xFF，余下4种颜色为Alpha0和Alpha1的线性插值结果。</li></ul></li><li><p>DXT5块具体解析的代码如下：</p></li></ul><figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/// DXT5 alpha block.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AlphaBlockDXT5</span><br>&#123;</span><br>    <span class="hljs-keyword">union</span> &#123;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            uint64 alpha0 : <span class="hljs-number">8</span>;<span class="hljs-comment">// 8</span><br>            uint64 alpha1 : <span class="hljs-number">8</span>;<span class="hljs-comment">// 16</span><br>            uint64 bits0 : <span class="hljs-number">3</span>;<span class="hljs-comment">// 3 - 19</span><br>            uint64 bits1 : <span class="hljs-number">3</span>; <span class="hljs-comment">// 6 - 22</span><br>            uint64 bits2 : <span class="hljs-number">3</span>; <span class="hljs-comment">// 9 - 25</span><br>            uint64 bits3 : <span class="hljs-number">3</span>;<span class="hljs-comment">// 12 - 28</span><br>            uint64 bits4 : <span class="hljs-number">3</span>;<span class="hljs-comment">// 15 - 31</span><br>            uint64 bits5 : <span class="hljs-number">3</span>;<span class="hljs-comment">// 18 - 34</span><br>            uint64 bits6 : <span class="hljs-number">3</span>;<span class="hljs-comment">// 21 - 37</span><br>            uint64 bits7 : <span class="hljs-number">3</span>;<span class="hljs-comment">// 24 - 40</span><br>            uint64 bits8 : <span class="hljs-number">3</span>;<span class="hljs-comment">// 27 - 43</span><br>            uint64 bits9 : <span class="hljs-number">3</span>; <span class="hljs-comment">// 30 - 46</span><br>            uint64 bitsA : <span class="hljs-number">3</span>; <span class="hljs-comment">// 33 - 49</span><br>            uint64 bitsB : <span class="hljs-number">3</span>;<span class="hljs-comment">// 36 - 52</span><br>            uint64 bitsC : <span class="hljs-number">3</span>;<span class="hljs-comment">// 39 - 55</span><br>            uint64 bitsD : <span class="hljs-number">3</span>;<span class="hljs-comment">// 42 - 58</span><br>            uint64 bitsE : <span class="hljs-number">3</span>;<span class="hljs-comment">// 45 - 61</span><br>            uint64 bitsF : <span class="hljs-number">3</span>;<span class="hljs-comment">// 48 - 64</span><br>        &#125;;<br>        uint64 u;<br>    &#125;;<br>&#125;;<br>``<br><span class="hljs-comment">/// DXT5 block.</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BlockDXT5</span><br>&#123;</span><br>    AlphaBlockDXT5 alpha;<br>    BlockDXT1 color;<br>&#125;;<br>``<br><br><span class="hljs-comment">/*----------------------------------------------------------------------------<br>BlockDXT5<br>----------------------------------------------------------------------------*/</span><br><br><span class="hljs-keyword">void</span> AlphaBlockDXT5::evaluatePalette(uint8 alpha[<span class="hljs-number">8</span>], <span class="hljs-keyword">bool</span> d3d9) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (alpha0 &gt; alpha1) &#123;<br>        evaluatePalette8(alpha, d3d9);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        evaluatePalette6(alpha, d3d9);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> AlphaBlockDXT5::evaluatePalette8(uint8 alpha[<span class="hljs-number">8</span>], <span class="hljs-keyword">bool</span> d3d9) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">int</span> bias = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (d3d9) bias = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">// 8-alpha block:  derive the other six alphas.</span><br>    <span class="hljs-comment">// Bit code 000 = alpha0, 001 = alpha1, others are interpolated.</span><br>    alpha[<span class="hljs-number">0</span>] = alpha0;<br>    alpha[<span class="hljs-number">1</span>] = alpha1;<br>    alpha[<span class="hljs-number">2</span>] = (<span class="hljs-number">6</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">7</span>;    <span class="hljs-comment">// bit code 010</span><br>    alpha[<span class="hljs-number">3</span>] = (<span class="hljs-number">5</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">2</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">7</span>;    <span class="hljs-comment">// bit code 011</span><br>    alpha[<span class="hljs-number">4</span>] = (<span class="hljs-number">4</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">3</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">7</span>;    <span class="hljs-comment">// bit code 100</span><br>    alpha[<span class="hljs-number">5</span>] = (<span class="hljs-number">3</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">4</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">7</span>;    <span class="hljs-comment">// bit code 101</span><br>    alpha[<span class="hljs-number">6</span>] = (<span class="hljs-number">2</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">5</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">7</span>;    <span class="hljs-comment">// bit code 110</span><br>    alpha[<span class="hljs-number">7</span>] = (<span class="hljs-number">1</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">6</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">7</span>;    <span class="hljs-comment">// bit code 111</span><br>&#125;<br><br><span class="hljs-keyword">void</span> AlphaBlockDXT5::evaluatePalette6(uint8 alpha[<span class="hljs-number">8</span>], <span class="hljs-keyword">bool</span> d3d9) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">int</span> bias = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (d3d9) bias = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 6-alpha block.</span><br>    <span class="hljs-comment">// Bit code 000 = alpha0, 001 = alpha1, others are interpolated.</span><br>    alpha[<span class="hljs-number">0</span>] = alpha0;<br>    alpha[<span class="hljs-number">1</span>] = alpha1;<br>    alpha[<span class="hljs-number">2</span>] = (<span class="hljs-number">4</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">5</span>;    <span class="hljs-comment">// Bit code 010</span><br>    alpha[<span class="hljs-number">3</span>] = (<span class="hljs-number">3</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">2</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">5</span>;    <span class="hljs-comment">// Bit code 011</span><br>    alpha[<span class="hljs-number">4</span>] = (<span class="hljs-number">2</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">3</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">5</span>;    <span class="hljs-comment">// Bit code 100</span><br>    alpha[<span class="hljs-number">5</span>] = (<span class="hljs-number">1</span> * alpha[<span class="hljs-number">0</span>] + <span class="hljs-number">4</span> * alpha[<span class="hljs-number">1</span>] + bias) / <span class="hljs-number">5</span>;    <span class="hljs-comment">// Bit code 101</span><br>    alpha[<span class="hljs-number">6</span>] = <span class="hljs-number">0x00</span>;                                        <span class="hljs-comment">// Bit code 110</span><br>    alpha[<span class="hljs-number">7</span>] = <span class="hljs-number">0xFF</span>;                                        <span class="hljs-comment">// Bit code 111</span><br>&#125;<br><br><span class="hljs-keyword">void</span> AlphaBlockDXT5::indices(uint8 index_array[<span class="hljs-number">16</span>]) <span class="hljs-keyword">const</span><br>&#123;<br>    index_array[<span class="hljs-number">0x0</span>] = bits0;<br>    index_array[<span class="hljs-number">0x1</span>] = bits1;<br>    index_array[<span class="hljs-number">0x2</span>] = bits2;<br>    index_array[<span class="hljs-number">0x3</span>] = bits3;<br>    index_array[<span class="hljs-number">0x4</span>] = bits4;<br>    index_array[<span class="hljs-number">0x5</span>] = bits5;<br>    index_array[<span class="hljs-number">0x6</span>] = bits6;<br>    index_array[<span class="hljs-number">0x7</span>] = bits7;<br>    index_array[<span class="hljs-number">0x8</span>] = bits8;<br>    index_array[<span class="hljs-number">0x9</span>] = bits9;<br>    index_array[<span class="hljs-number">0xA</span>] = bitsA;<br>    index_array[<span class="hljs-number">0xB</span>] = bitsB;<br>    index_array[<span class="hljs-number">0xC</span>] = bitsC;<br>    index_array[<span class="hljs-number">0xD</span>] = bitsD;<br>    index_array[<span class="hljs-number">0xE</span>] = bitsE;<br>    index_array[<span class="hljs-number">0xF</span>] = bitsF;<br>&#125;<br><br>uint AlphaBlockDXT5::index(uint index) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-keyword">int</span> offset = (<span class="hljs-number">3</span> * index + <span class="hljs-number">16</span>);<br>    <span class="hljs-keyword">return</span> uint((<span class="hljs-keyword">this</span>-&gt;u &gt;&gt; offset) &amp; <span class="hljs-number">0x7</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> AlphaBlockDXT5::setIndex(uint index, uint value)<br>&#123;<br>    <span class="hljs-keyword">int</span> offset = (<span class="hljs-number">3</span> * index + <span class="hljs-number">16</span>);<br>    uint64 mask = uint64(<span class="hljs-number">0x7</span>) &lt;&lt; offset;<br>    <span class="hljs-keyword">this</span>-&gt;u = (<span class="hljs-keyword">this</span>-&gt;u &amp; ~mask) | (uint64(value) &lt;&lt; offset);<br>&#125;<br><br><span class="hljs-keyword">void</span> AlphaBlockDXT5::decodeBlock(ColorBlock * block, <span class="hljs-keyword">bool</span> d3d9<span class="hljs-comment">/*= false*/</span>) <span class="hljs-keyword">const</span><br>&#123;<br>    uint8 alpha_array[<span class="hljs-number">8</span>];<br>    evaluatePalette(alpha_array, d3d9);<br><br>    uint8 index_array[<span class="hljs-number">16</span>];<br>    indices(index_array);<br><br>    <span class="hljs-keyword">for</span>(uint i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++) &#123;<br>        block-&gt;color(i).a = alpha_array[index_array[i]];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">void</span> BlockDXT5::decodeBlock(ColorBlock * block, <span class="hljs-keyword">bool</span> d3d9<span class="hljs-comment">/*= false*/</span>) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-comment">// Decode color.</span><br>    color.decodeBlock(block, d3d9);<br><br>    <span class="hljs-comment">// Decode alpha.</span><br>    alpha.decodeBlock(block, d3d9);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>转载请注明出处：<a href="http://morimiya.me/">morimiya.me</a></p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> DXT压缩纹理格式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DXT </tag>
            
            <tag> 压缩纹理 </tag>
            
            <tag> S3TC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Blinn-Phong光照</title>
      <link href="/2019/02/24/Blinn-Phong%E5%85%89%E7%85%A7/"/>
      <url>/2019/02/24/Blinn-Phong%E5%85%89%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 高级光照学习笔记</p><p>Blinn-Phong光照</p></blockquote><a id="more"></a><h2 id="复习冯氏光照模型"><a href="#复习冯氏光照模型" class="headerlink" title="复习冯氏光照模型"></a>复习冯氏光照模型</h2><ul><li>在冯氏光照模型中，物体的光由环境光(Ambient)、漫反射光(Diffuse)和镜面光(Specular)组成。</li><li>环境光(Ambient)一般是一个给定的很小的值。</li><li>漫反射光(Diffuse)强弱由入射光的反向向量与法向量的夹角大小所决定，夹角越大，强度越弱，一般用夹角余弦值替代计算。</li><li>镜面光(Specular)强弱由入射光的反射向量与视线方向的夹角大小所决定，同样夹角越大，强度越弱，一般也使用余弦值替代计算，另还有取它的反光度(Shininess)次幂来作为最终镜面强弱结果。</li></ul><h2 id="冯氏光照模型的不足"><a href="#冯氏光照模型的不足" class="headerlink" title="冯氏光照模型的不足"></a>冯氏光照模型的不足</h2><ul><li>在镜面光分量上，当视线与反射光向量夹角大于90°时，镜面光值将会变为0，在反光度非常小的情况下，会产生较明显的边界情况。</li><li><img src="/2019/02/24/Blinn-Phong光照/advanced_lighting_over_90.png" alt="镜面光临界情况"></li><li><img src="/2019/02/24/Blinn-Phong光照/low_shininess.png" alt="镜面光临界情况"></li></ul><h2 id="Blinn-Phong光照"><a href="#Blinn-Phong光照" class="headerlink" title="Blinn-Phong光照"></a>Blinn-Phong光照</h2><ul><li>Blinn-Phong光照模型是建立在冯氏光照模型的基础上对镜面光计算进行修改的算法，Blinn-Phong模型不再依赖于反射向量，而是采用了半程向量(Halfway Vector)，即光线与视线夹角<br>low_shininess.png一半方向上的一个单位向量。当半程向量与法线向量越接近时，镜面光分量就越大。</li><li><img src="/2019/02/24/Blinn-Phong光照/advanced_lighting_halfway_vector.png" alt="镜面光临界情况"></li><li>当视线正好与反射向量对齐时，半程向量就会与法线完美契合。所以当观察者视线越接近于原本反射光线的方向时，镜面高光就会越强。</li><li>现在，不论观察者向哪个方向看，半程向量与表面法线之间的夹角都不会超过90度（除非光源在表面以下）。它产生的效果会与冯氏光照有些许不同，但是大部分情况下看起来会更自然一点，特别是低高光的区域。Blinn-Phong着色模型正是早期固定渲染管线时代时OpenGL所采用的光照模型。</li><li>获取半程向量的方法很简单，只需要将光线的方向向量和观察向量加到一起，并将结果正规化(Normalize)就可以了：<script type="math/tex; mode=display">\vec H = \frac{\vec L + \vec V}{||\vec L + \vec V||}</script></li><li><p>除此之外，冯氏模型与Blinn-Phong模型也有一些细微的差别：半程向量与表面法线的夹角通常会小于观察与反射向量的夹角。所以，如果你想获得和冯氏着色类似的效果，就必须在使用Blinn-Phong模型时将镜面反光度设置更高一点。通常我们会选择冯氏着色时反光度分量的2到4倍。</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec3</span> lightDir   = <span class="hljs-built_in">normalize</span>(lightPos - FragPos);<br><span class="hljs-type">vec3</span> viewDir    = <span class="hljs-built_in">normalize</span>(viewPos - FragPos);<br><span class="hljs-type">vec3</span> halfwayDir = <span class="hljs-built_in">normalize</span>(lightDir + viewDir);<br><br><span class="hljs-type">float</span> spec = <span class="hljs-built_in">pow</span>(<span class="hljs-built_in">max</span>(<span class="hljs-built_in">dot</span>(normal, halfwayDir), <span class="hljs-number">0.0</span>), shininess);<br><span class="hljs-type">vec3</span> specular = lightColor * spec;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/02/24/Blinn-Phong光照/compare.png" alt="光照结果对比"></p></li><li><img src="/2019/02/24/Blinn-Phong光照/compare2.png" alt="镜面光对比"></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 光照 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常用OpenGL函数</title>
      <link href="/2019/02/23/%E5%B8%B8%E7%94%A8OpenGL%E5%87%BD%E6%95%B0/"/>
      <url>/2019/02/23/%E5%B8%B8%E7%94%A8OpenGL%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 常用OpenGL函数 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>游戏角色染色实现</title>
      <link href="/2019/02/19/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%9F%93%E8%89%B2%E5%AE%9E%E7%8E%B0/"/>
      <url>/2019/02/19/%E6%B8%B8%E6%88%8F%E8%A7%92%E8%89%B2%E6%9F%93%E8%89%B2%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>游戏常用的染色方式。<br><a id="more"></a></p></blockquote><h2 id="什么是游戏角色染色"><a href="#什么是游戏角色染色" class="headerlink" title="什么是游戏角色染色"></a>什么是游戏角色染色</h2><ul><li>我所理解的染色是通过改变游戏角色衣着、饰品、头发、皮肤的颜色来达到不同的视觉效果。</li><li><p>以下分别为DNF、楚留香和奇迹暖暖的染色功能。</p></li><li><p><img src="/2019/02/19/游戏角色染色实现/DNF染色.png" alt="DNF效果"></p></li><li><img src="/2019/02/19/游戏角色染色实现/楚留香染色.png" alt="楚留香效果"></li><li><img src="/2019/02/19/游戏角色染色实现/奇迹暖暖染色.png" alt="奇迹暖暖效果"></li></ul><h2 id="常用的染色方式"><a href="#常用的染色方式" class="headerlink" title="常用的染色方式"></a>常用的染色方式</h2><ul><li>染色，在程序角度而言，其本质为一个颜色映射关系，即给予源色和一定参数，输出目标颜色的过程。</li><li>用式子来表达便是：DestColor = func(BaseColor, Params)</li></ul><h3 id="LookupTable查表染色"><a href="#LookupTable查表染色" class="headerlink" title="LookupTable查表染色"></a>LookupTable查表染色</h3><ul><li><img src="/2019/02/19/游戏角色染色实现/LookupTable.png" alt="LookupTable"></li><li>DyeColor = LookupTable(BaseColor.r, BaseColor.g, BaseColor.b)</li><li>简单而言，就是根据颜色值进行查表，得到目标颜色值。由于显存限制等原因，LookupTable的大小一般会比256<em>256</em>256小，如64<em>64</em>64的大小，此时，在计算颜色时，会做一定的线性插值。以一维的情况为例，用数组a[64]来缓存256种颜色的映射结果。假设某点取值为123，那么有123/4=30.75，映射结果为a[30] <em> 0.25+a[31] </em> 0.75。</li><li><p>优点：</p><ul><li>颜色之间的映射关系可以随意调整，对颜色的控制可以做到非常细致。</li><li>无需指定染色分块，不需要要求一个染色分块的颜色需要相近。</li><li>GPU计算量少，只有采样计算。</li></ul></li><li><p>缺点：</p><ul><li>LoopupTable较耗显存，精度不好把控。</li><li>不好直接开放给玩家自行设计染色。</li></ul></li></ul><h3 id="TColor染色"><a href="#TColor染色" class="headerlink" title="TColor染色"></a>TColor染色</h3><ul><li>DyeColor = BaseColor * TColor</li><li>优点：<ul><li>计算简单</li></ul></li><li>该染色明显的缺陷有两个：<ol><li>它对原图颜色依赖较大，若原图中没有某个通道（如R）的颜色分量，无论TColor设什么值，都不能染成红色。</li><li>与TColor相乘后，颜色值会比原值小，使得亮度降低。</li></ol></li><li>针对第一个缺陷，可以将图像变成灰白图，只保留明暗信息，从而能染到更多种颜色。</li><li>针对第二个缺陷，可以用类似HDR的方式，在计算中允许超过1.0的值，后续使用时再进行约束。</li></ul><h3 id="HSV染色方式"><a href="#HSV染色方式" class="headerlink" title="HSV染色方式"></a>HSV染色方式</h3><ul><li><img src="/2019/02/19/游戏角色染色实现/HSV.png" alt="HSV"></li><li><img src="/2019/02/19/游戏角色染色实现/HSV_cone.png" alt="HSV"></li><li>HSV，即色相（Hue），饱和度（Saturation），亮度（Value）。</li><li>HSV表示颜色的方式与人直观感受更为接近，我们在形容一个物体颜色的时候，经常会不知不觉的说出类似这样的话：“这个苹果好红，红得很深”，“这个黄色很亮眼”等。HSV形容颜色的方式与这种口头描述很相似，色相表示了物体的总体颜色，饱和度则为颜色的深浅，亮度则表示物体的明暗程度。</li><li>楚留香中给出的染色方式便是HSV染色，其能通过调整色相，饱和度和亮度来决定染色结果。</li><li>从上面楚留香染色界面截图可以猜测出，其HSV染色算法的大致过程为：<script type="math/tex; mode=display">BaseHSV = RGB2HSV(BaseColor)</script><script type="math/tex; mode=display">DestHSV = BaseHSV + ChangedHSV</script><script type="math/tex; mode=display">DestColor = HSV2RGB(DestHSV)</script></li><li>关于RGB和HSV的相互转化方式，网上有较多资料，这里不再给出。</li></ul><h3 id="通道混合染色方式"><a href="#通道混合染色方式" class="headerlink" title="通道混合染色方式"></a>通道混合染色方式</h3><ul><li>通道混合的染色方式是以基础颜色作为基准，通过基础颜色和给定的参数混合出新的RGB值。</li><li><p>其数学式子表达如下：</p><script type="math/tex; mode=display">\begin{bmatrix} rr & rg & rb \\ gr & gg & gb \\ br & bg & bb \end{bmatrix}*\begin{bmatrix} R_{source} & G_{source} & B_{source} \end{bmatrix}+\begin{bmatrix} R_{const} & G_{const} & B_{const} \end{bmatrix}=\begin{bmatrix} R & G & B \end{bmatrix}</script></li><li><p>其较为明显的问题是不够HSV直观。</p></li><li>如何开放给玩家直观的进行染色：<figure class="hljs highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 不考虑加上颜色const值的情况。</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetChannelParam</span><span class="hljs-params">(lColor, iTargetValue, iChannel)</span>:</span><br>    lRet = [<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>]<br>    lRet[iChannel] = <span class="hljs-number">1.0</span><br>    <span class="hljs-keyword">if</span> sum(lColor) * <span class="hljs-number">2</span> &lt; iTargetValue:<br>        <span class="hljs-keyword">return</span> [<span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">2.0</span>]<br><br>    lSortColor = sorted(lColor, reverse=<span class="hljs-keyword">True</span>)<br>    iCurValue = lColor[iChannel]<br>    <span class="hljs-keyword">if</span> iCurValue &lt; iTargetValue:<br>        <span class="hljs-comment"># 从大到小逐个去填充目标值。</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(lSortColor)):<br>            iDiff = iTargetValue - iCurValue<br>            <span class="hljs-keyword">if</span> i == iChannel:<br>                fRate = <span class="hljs-number">1.0</span><br>            <span class="hljs-keyword">else</span>:<br>                fRate = <span class="hljs-number">2.0</span><br>            fCurRate = float(iDiff) / lSortColor[i]<br>            <span class="hljs-keyword">if</span> fCurRate &gt;= fRate:<br>                iCurValue += fRate * lSortColor[i]<br>                lRet[i] = <span class="hljs-number">2.0</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 填充完成。</span><br>                lRet[i] = fCurRate<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        lRet[iChannel] = float(iTargetValue) / iCurValue<br>    <span class="hljs-keyword">return</span> lRet<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetMixChannelMatrix</span><span class="hljs-params">(lSrcColor, lDstColor)</span>:</span><br>    lRet = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):<br>        lTemp = GetChannelParam(lSrcColor, lDstColor[i], i)<br>        lRet.append(lTemp)<br>    <span class="hljs-keyword">return</span> lRet<br></code></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
          <category> 染色 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发 </tag>
            
            <tag> 染色 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高级OpenGL（下）</title>
      <link href="/2019/02/09/%E9%AB%98%E7%BA%A7OpenGL%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2019/02/09/%E9%AB%98%E7%BA%A7OpenGL%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 高级OpenGL学习笔记</p><p>高级数据、高级GLSL，几何着色器，实例化，抗锯齿。</p></blockquote><a id="more"></a><h2 id="高级数据-Advanced-Data"><a href="#高级数据-Advanced-Data" class="headerlink" title="高级数据(Advanced Data)"></a>高级数据(Advanced Data)</h2><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><ul><li>OpenGL中的缓冲只是一个管理特定内存块的对象，没有其它更多的功能了。在我们将它绑定到一个缓冲目标(Buffer Target)时，我们才赋予了其意义。当我们绑定一个缓冲到GL_ARRAY_BUFFER时，它就是一个顶点数组缓冲，但我们也可以很容易地将其绑定到GL_ELEMENT_ARRAY_BUFFER。OpenGL内部会为每个目标储存一个缓冲，并且会根据目标的不同，以不同的方式处理缓冲。</li></ul><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>glBufferData</td><td>填充缓冲对象所管理的内存，这个函数会分配一块内存，并将数据添加到这块内存中。如果我们将它的data参数设置为NULL，那么这个函数将只会分配内存，但不进行填充。这在我们需要预留(Reserve)特定大小的内存，之后回到这个缓冲一点一点填充的时候会很有用。</td></tr><tr><td>glBufferSubData</td><td>填充缓冲的特定区域。这个函数需要一个缓冲目标、一个偏移量、数据的大小和数据本身作为它的参数。这个函数不同的地方在于，我们可以提供一个偏移量，指定从何处开始填充这个缓冲。这能够让我们插入或者更新缓冲内存的某一部分。要注意的是，缓冲需要有足够的已分配内存，所以对一个缓冲调用glBufferSubData之前必须要先调用glBufferData。</td></tr><tr><td>glMapBuffer</td><td>请求缓冲内存的指针，直接将数据复制到缓冲当中。调用glMapBuffer函数，OpenGL会返回当前绑定缓冲的内存指针。</td></tr><tr><td>glUnmapBuffer</td><td>使用glUnmapBuffer函数，告诉OpenGL我们已经完成指针操作之后，OpenGL就会知道你已经完成了。在解除映射(Unmapping)之后，指针将会不再可用，并且如果OpenGL能够成功将您的数据映射到缓冲中，这个函数将会返回GL_TRUE。</td></tr></tbody></table></div><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// glBufferSubData使用例子</span><br>glBufferSubData(GL_ARRAY_BUFFER, <span class="hljs-number">24</span>, <span class="hljs-keyword">sizeof</span>(data), &amp;data); <span class="hljs-comment">// 范围： [24, 24 + sizeof(data)]</span><br></code></pre></td></tr></table></figure><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// glMapBuffer、glUnmapBuffer使用例子</span><br><span class="hljs-keyword">float</span> data[] = &#123;<br>  <span class="hljs-number">0.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">-0.35f</span><br>  ...<br>&#125;;<br>glBindBuffer(GL_ARRAY_BUFFER, buffer);<br><span class="hljs-comment">// 获取指针</span><br><span class="hljs-keyword">void</span> *ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);<br><span class="hljs-comment">// 复制数据到内存</span><br><span class="hljs-built_in">memcpy</span>(ptr, data, <span class="hljs-keyword">sizeof</span>(data));<br><span class="hljs-comment">// 记得告诉OpenGL我们不再需要这个指针了</span><br>glUnmapBuffer(GL_ARRAY_BUFFER);<br></code></pre></td></tr></table></figure><h3 id="分批顶点属性"><a href="#分批顶点属性" class="headerlink" title="分批顶点属性"></a>分批顶点属性</h3><ul><li>通过使用glVertexAttribPointer，我们能够指定顶点数组缓冲内容的属性布局。</li><li>之前，我们将顶点的位置、法线、纹理坐标连续且交错的放在一起，即形如123123123123布局。而从文件中加载顶点数据的时候，你通常获取到的是一个位置数组、一个法线数组和/或一个纹理坐标数组。我们需要花点力气才能将这些数组转化为一个大的交错数据数组。</li><li>使用glVertexAttribPointer能将每一种属性类型的向量数据打包(Batch)为一个大的区块，而不是对它们进行交错储存，即形如111122223333。</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">float</span> positions[] = &#123; ... &#125;;<br><span class="hljs-keyword">float</span> normals[] = &#123; ... &#125;;<br><span class="hljs-keyword">float</span> tex[] = &#123; ... &#125;;<br><span class="hljs-comment">// 填充缓冲</span><br>glBufferSubData(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(positions), &amp;positions);<br>glBufferSubData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(positions), <span class="hljs-keyword">sizeof</span>(normals), &amp;normals);<br>glBufferSubData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(positions) + <span class="hljs-keyword">sizeof</span>(normals), <span class="hljs-keyword">sizeof</span>(tex), &amp;tex);<br><br><span class="hljs-comment">// 更新顶点属性指针</span><br>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), <span class="hljs-number">0</span>);  <br>glVertexAttribPointer(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)(<span class="hljs-keyword">sizeof</span>(positions)));  <br>glVertexAttribPointer(<br>  <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)(<span class="hljs-keyword">sizeof</span>(positions) + <span class="hljs-keyword">sizeof</span>(normals)));<br></code></pre></td></tr></table></figure><h3 id="复制缓冲"><a href="#复制缓冲" class="headerlink" title="复制缓冲"></a>复制缓冲</h3><ul><li><p>glCopyBufferSubData能够让我们相对容易地从一个缓冲中复制数据到另一个缓冲中。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数原型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">glCopyBufferSubData</span><span class="hljs-params">(<br>  GLenum readtarget, <span class="hljs-comment">// 复制源</span><br>  GLenum writetarget, <span class="hljs-comment">// 复制目标的缓冲目标</span><br>  GLintptr readoffset, <span class="hljs-comment">// 读偏移</span><br>  GLintptr writeoffset, <span class="hljs-comment">// 写偏移</span><br>  GLsizeiptr size  <span class="hljs-comment">// 读取数据的大小</span><br>)</span></span>;<br></code></pre></td></tr></table></figure></li><li><p>我们可以将VERTEX_ARRAY_BUFFER缓冲复制到VERTEX_ELEMENT_ARRAY_BUFFER缓冲，分别将这些缓冲目标设置为读和写的目标。当前绑定到这些缓冲目标的缓冲将会被影响到。</p></li><li>如果读写的两个缓冲均为同类型的缓冲（如，均为顶点数组缓冲），由于不能将两个缓冲绑定至同一个缓冲目标上，故OpenGL提供了GL_COPY_READ_BUFFER和GL_COPY_WRITE_BUFFER这两个缓冲目标。</li><li>使用方式如下：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">float</span> vertexData[] = &#123; ... &#125;;<br>glBindBuffer(GL_COPY_READ_BUFFER, vbo1);<br>glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);<br>glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vertexData));<br><br><span class="hljs-comment">// 只将writetarget缓冲绑定为新的缓冲目标类型之一</span><br><span class="hljs-keyword">float</span> vertexData[] = &#123; ... &#125;;<br>glBindBuffer(GL_ARRAY_BUFFER, vbo1);<br>glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);<br>glCopyBufferSubData(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vertexData));<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="高级GLSL-Advanced-GLSL"><a href="#高级GLSL-Advanced-GLSL" class="headerlink" title="高级GLSL(Advanced GLSL)"></a>高级GLSL(Advanced GLSL)</h2><h3 id="GLSL的内建变量"><a href="#GLSL的内建变量" class="headerlink" title="GLSL的内建变量"></a>GLSL的内建变量</h3><h4 id="顶点着色器变量"><a href="#顶点着色器变量" class="headerlink" title="顶点着色器变量"></a>顶点着色器变量</h4><h5 id="gl-PointSize（输出变量）"><a href="#gl-PointSize（输出变量）" class="headerlink" title="gl_PointSize（输出变量）"></a>gl_PointSize（输出变量）</h5><ul><li>当图元选择为GL_POINTS时，我们可以通过glPointSize函数来设置渲染出来的点的大小，也可以在顶点着色器中修改这个值。</li><li>GLSL定义了一个叫做gl_PointSize输出变量，它是一个float变量，你可以使用它来设置点的宽高（像素）。在顶点着色器中修改点的大小的话，你就能对每个顶点设置不同的值了。</li><li>在顶点着色器中修改点大小的功能默认是禁用的，如果你需要启用它的话，你需要启用OpenGL的GL_PROGRAM_POINT_SIZE。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glEnable(GL_PROGRAM_POINT_SIZE);<br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// 顶点着色器</span><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-built_in">gl_PointSize</span> = <span class="hljs-built_in">gl_Position</span>.z;  <span class="hljs-comment">// 点的大小会随着观察者距顶点距离变远而增大。</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="gl-VertexID（输入变量）"><a href="#gl-VertexID（输入变量）" class="headerlink" title="gl_VertexID（输入变量）"></a>gl_VertexID（输入变量）</h5><ul><li>gl_Position和gl_PointSize都是输出变量，因为它们的值是作为顶点着色器的输出被读取的。我们可以对它们进行写入，来改变结果。顶点着色器提供了一个输入变量gl_VertexID，该只能对它进行读取。</li><li>整型变量gl_VertexID储存了正在绘制顶点的当前ID。当（使用glDrawElements）进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引。当（使用glDrawArrays）不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。</li></ul><h4 id="片段着色器变量"><a href="#片段着色器变量" class="headerlink" title="片段着色器变量"></a>片段着色器变量</h4><h5 id="gl-FragCoord（输入变量）"><a href="#gl-FragCoord（输入变量）" class="headerlink" title="gl_FragCoord（输入变量）"></a>gl_FragCoord（输入变量）</h5><ul><li>gl_FragCoord的z分量等于对应片段的深度值。也能使用它的x和y分量来实现一些有趣的效果。</li><li>gl_FragCoord的x和y分量是片段的窗口空间(Window-space)坐标，其原点为窗口的左下角。我们已经使用glViewport设定了一个800x600的窗口了，所以片段窗口空间坐标的x分量将在0到800之间，y分量在0到600之间。</li><li>通过利用片段着色器，我们可以根据片段的窗口坐标，计算出不同的颜色。gl_FragCoord的一个常见用处是用于对比不同片段计算的视觉输出效果，这在技术演示中可以经常看到。比如说，我们能够将屏幕分成两部分，在窗口的左侧渲染一种输出，在窗口的右侧渲染另一种输出。下面这个例子片段着色器会根据窗口坐标输出不同的颜色：<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> main()<br>&#123;             <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gl_FragCoord</span>.x &lt; <span class="hljs-number">400</span>)<br>        FragColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-keyword">else</span><br>        FragColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);        <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="gl-FrontFacing（输入变量）"><a href="#gl-FrontFacing（输入变量）" class="headerlink" title="gl_FrontFacing（输入变量）"></a>gl_FrontFacing（输入变量）</h5><ul><li>如果我们不（启用GL_FACE_CULL来）使用面剔除，那么gl_FrontFacing将会告诉我们当前片段是属于正向面的一部分还是背向面的一部分。</li><li><p>gl_FrontFacing变量是一个bool，如果当前片段是正向面的一部分那么就是true，否则就是false。</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> TexCoords;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> frontTexture;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> backTexture;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// 立方体内部和外部使用不同的纹理</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gl_FrontFacing</span>)<br>        FragColor = <span class="hljs-built_in">texture</span>(frontTexture, TexCoords);<br>    <span class="hljs-keyword">else</span><br>        FragColor = <span class="hljs-built_in">texture</span>(backTexture, TexCoords);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/02/09/高级OpenGL（下）/advanced_glsl_frontfacing.png" alt="立方体内部和外部使用不同的纹理"></p></li></ul><h5 id="gl-FragDepth（输出变量）"><a href="#gl-FragDepth（输出变量）" class="headerlink" title="gl_FragDepth（输出变量）"></a>gl_FragDepth（输出变量）</h5><ul><li>输入变量gl_FragCoord能让我们读取当前片段的窗口空间坐标，并获取它的深度值，但是它是一个只读(Read-only)变量。我们不能修改片段的窗口空间坐标，但OpenGL提供了名为gl_FragDepth的输出变量，我们可以通过他修改片段的深度值。</li><li><p>要想设置深度值，我们直接写入一个0.0到1.0之间的float值到输出变量就可以了，如果着色器没有写入值到gl_FragDepth，它会自动取用gl_FragCoord.z的值。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gl_FragDepth = <span class="hljs-number">0.0</span>; <span class="hljs-comment">// 这个片段现在的深度值为 0.0</span><br></code></pre></td></tr></table></figure></li><li><p>由自己设置深度值有一个很大的缺点，只要我们在片段着色器中对gl_FragDepth进行写入，OpenGL就会禁用所有的提前深度测试(Early Depth Testing)。</p></li><li>从OpenGL 4.2起，我们仍可以对两者进行一定的调和，在片段着色器的顶部使用深度条件(Depth Condition)重新声明gl_FragDepth变量：<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span> (depth_&lt;condition&gt;) <span class="hljs-keyword">out</span> <span class="hljs-type">float</span> <span class="hljs-built_in">gl_FragDepth</span>;<br></code></pre></td></tr></table></figure></li></ul><p>condition可以为下面的值：</p><div class="table-container"><table><thead><tr><th>条件</th><th>描述</th></tr></thead><tbody><tr><td>any</td><td>默认值。提前深度测试是禁用的，你会损失很多性能</td></tr><tr><td>greater</td><td>你只能让深度值比gl_FragCoord.z更大</td></tr><tr><td>less</td><td>你只能让深度值比gl_FragCoord.z更小</td></tr><tr><td>unchanged</td><td>如果你要写入gl_FragDepth，你将只能写入gl_FragCoord.z的值</td></tr></tbody></table></div><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 420 core // 注意GLSL的版本！</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><span class="hljs-comment">// 片段的深度值进行了递增，但仍然也保留了一些提前深度测试</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">depth_greater</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">float</span> <span class="hljs-built_in">gl_FragDepth</span>;<br><br><span class="hljs-type">void</span> main()<br>&#123;             <br>    FragColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>);<br>    <span class="hljs-built_in">gl_FragDepth</span> = <span class="hljs-built_in">gl_FragCoord</span>.z + <span class="hljs-number">0.1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口块"><a href="#接口块" class="headerlink" title="接口块"></a>接口块</h3><ul><li>GLSL提供了一个叫做接口块(Interface Block)的东西，来方便组合变量。接口块的声明和struct的声明有点相像，不同的是，现在根据它是一个输入还是输出块(Block)，使用in或out关键字来定义的。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoords;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><br><span class="hljs-comment">// 块名（VS_OUT），需要与片段着色器中保持一致</span><br><span class="hljs-comment">// 实例名（vs_out）可以随意修改。</span><br><span class="hljs-keyword">out</span> VS_OUT<br>&#123;<br>    <span class="hljs-type">vec2</span> TexCoords;<br>&#125; vs_out;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);    <br>    vs_out.TexCoords = aTexCoords;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-comment">// 块名（VS_OUT），需要与顶点着色器中保持一致</span><br><span class="hljs-comment">// 实例名（vs_out）可以随意修改。</span><br><span class="hljs-keyword">in</span> VS_OUT<br>&#123;<br>    <span class="hljs-type">vec2</span> TexCoords;<br>&#125; fs_in;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> <span class="hljs-built_in">texture</span>;<br><br><span class="hljs-type">void</span> main()<br>&#123;             <br>    FragColor = <span class="hljs-built_in">texture</span>(<span class="hljs-built_in">texture</span>, fs_in.TexCoords);   <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>接口块，打包了我们希望发送到下一个着色器中的所有输出变量。</li><li>只要两个接口块的名字一样，它们对应的输入和输出将会匹配起来。</li></ul><h3 id="Uniform缓冲对象"><a href="#Uniform缓冲对象" class="headerlink" title="Uniform缓冲对象"></a>Uniform缓冲对象</h3><ul><li>OpenGL为我们提供了一个叫做Uniform缓冲对象(Uniform Buffer Object)的工具，它允许我们定义一系列在多个着色器中相同的全局Uniform变量。当使用Uniform缓冲对象的时候，我们只需要设置相关的uniform一次。当然，我们仍需要手动设置每个着色器中不同的uniform。并且创建和配置Uniform缓冲对象会有一点繁琐。</li></ul><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>因为Uniform缓冲对象仍是一个缓冲，我们可以使用glGenBuffers来创建它，将它绑定到GL_UNIFORM_BUFFER缓冲目标，并将所有相关的uniform数据存入缓冲。<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><br><span class="hljs-comment">// 声明了一个叫做Matrices的Uniform块，它储存了两个4x4矩阵。</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std140</span>) <span class="hljs-keyword">uniform</span> Matrices<br>&#123;<br>    <span class="hljs-type">mat4</span> projection;<br>    <span class="hljs-type">mat4</span> view;<br>&#125;;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// Uniform块中的变量可以直接访问，不需要加块名作为前缀。</span><br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="Uniform块布局"><a href="#Uniform块布局" class="headerlink" title="Uniform块布局"></a>Uniform块布局</h4><ul><li>Uniform块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存。因为这块内存并不会保存它具体保存的是什么类型的数据，我们还需要告诉OpenGL内存的哪一部分对应着着色器中的哪一个uniform变量。</li><li>我们需要知道的是每个变量的大小（字节）和（从块起始位置的）偏移量，来让我们能够按顺序将它们放进缓冲中。每个元素的大小都是在OpenGL中有清楚地声明的，而且直接对应C++数据类型，其中向量和矩阵都是大的float数组。OpenGL没有声明的是这些变量间的间距(Spacing)。这允许硬件能够在它认为合适的位置放置变量。比如说，一些硬件可能会将一个vec3放置在float边上。不是所有的硬件都能这样处理，可能会在附加这个float之前，先将vec3填充(Pad)为一个4个float的数组。</li><li><p>以以下的Uniform块为例：</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std140</span>) <span class="hljs-keyword">uniform</span> ExampleBlock<br>&#123;<br>    <span class="hljs-type">float</span> value;<br>    <span class="hljs-type">vec3</span>  vector;<br>    <span class="hljs-type">mat4</span>  matrix;<br>    <span class="hljs-type">float</span> values[<span class="hljs-number">3</span>];<br>    <span class="hljs-type">bool</span>  boolean;<br>    <span class="hljs-type">int</span>   integer;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>Uniform的内存布局有三种，默认情况下的共享(Shared)布局，显式声明每个变量类型布局的std140布局，不能在每个程序中保持不变（非共享）的紧凑(Packed)布局。</p></li></ul><h5 id="共享-Shared-布局"><a href="#共享-Shared-布局" class="headerlink" title="共享(Shared)布局"></a>共享(Shared)布局</h5><ul><li>默认情况下，GLSL会使用一个叫做共享(Shared)布局的Uniform内存布局，共享是因为一旦硬件定义了偏移量，它们在多个程序中是共享并一致的。</li><li>使用共享布局时，GLSL是可以为了优化而对uniform变量的位置进行变动的，只要变量的顺序保持不变。</li><li>需要使用glGetUniformIndices来获得每个uniform变量的偏移量，从而才能准确地填充Uniform缓冲。</li></ul><h5 id="std140布局"><a href="#std140布局" class="headerlink" title="std140布局"></a>std140布局</h5><ul><li>虽然共享布局给了我们很多节省空间的优化，但是我们需要查询每个uniform变量的偏移量，这会产生非常多的工作量。通常的做法是，不使用共享布局，而是使用std140布局。std140布局声明了每个变量的偏移量都是由一系列规则所决定的，这显式地声明了每个变量类型的内存布局。由于这是显式提及的，我们可以手动计算出每个变量的偏移量。</li><li>每个变量都有一个基准对齐量(Base Alignment)，它等于一个变量在Uniform块中所占据的空间（包括填充量(Padding)），这个基准对齐量是使用std140布局的规则计算出来的。接下来，对每个变量，我们再计算它的对齐偏移量(Aligned Offset)，它是一个变量从块起始位置的字节偏移量。一个变量的对齐字节偏移量必须等于基准对齐量的倍数。</li><li>GLSL中的每个变量，比如说int、float和bool，都被定义为4字节量。每4个字节将会用一个N来表示。</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>布局规则</th></tr></thead><tbody><tr><td>标量，比如int和bool</td><td>每个标量的基准对齐量为N。</td></tr><tr><td>向量</td><td>2N或者4N。这意味着vec3的基准对齐量为4N。</td></tr><tr><td>标量或向量的数组</td><td>每个元素的基准对齐量与vec4的相同。</td></tr><tr><td>矩阵</td><td>储存为列向量的数组，每个向量的基准对齐量与vec4的相同。</td></tr><tr><td>结构体</td><td>等于所有元素根据规则计算后的大小，但会填充到vec4大小的倍数。</td></tr></tbody></table></div><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std140</span>) <span class="hljs-keyword">uniform</span> ExampleBlock<br>&#123;<br>                     <span class="hljs-comment">// 基准对齐量       // 对齐偏移量</span><br>    <span class="hljs-type">float</span> value;     <span class="hljs-comment">// 4               // 0</span><br>    <span class="hljs-type">vec3</span> vector;     <span class="hljs-comment">// 16              // 16  (必须是16的倍数，所以 4-&gt;16)</span><br>    <span class="hljs-type">mat4</span> matrix;     <span class="hljs-comment">// 16              // 32  (列 0)</span><br>                     <span class="hljs-comment">// 16              // 48  (列 1)</span><br>                     <span class="hljs-comment">// 16              // 64  (列 2)</span><br>                     <span class="hljs-comment">// 16              // 80  (列 3)</span><br>    <span class="hljs-type">float</span> values[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 16              // 96  (values[0])</span><br>                     <span class="hljs-comment">// 16              // 112 (values[1])</span><br>                     <span class="hljs-comment">// 16              // 128 (values[2])</span><br>    <span class="hljs-type">bool</span> boolean;    <span class="hljs-comment">// 4               // 144</span><br>    <span class="hljs-type">int</span> integer;     <span class="hljs-comment">// 4               // 148 (必须是4的倍数)</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>使用计算后的偏移量值，根据std140布局的规则，我们就能使用像是glBufferSubData的函数将变量数据按照偏移量填充进缓冲中了。虽然std140布局不是最高效的布局，但它保证了内存布局在每个声明了这个Uniform块的程序中是一致的。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 更新uniform变量boolean</span><br>glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);<br><span class="hljs-keyword">int</span> b = <span class="hljs-literal">true</span>; <span class="hljs-comment">// GLSL中的bool是4字节的，所以我们将它存为一个integer</span><br>glBufferSubData(GL_UNIFORM_BUFFER, <span class="hljs-number">144</span>, <span class="hljs-number">4</span>, &amp;b);<br>glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ul><h5 id="紧凑-Packed-布局"><a href="#紧凑-Packed-布局" class="headerlink" title="紧凑(Packed)布局"></a>紧凑(Packed)布局</h5><ul><li>不能保证这个布局在每个程序中保持不变的（即非共享），因为它允许编译器去将uniform变量从Uniform块中优化掉，这在每个着色器中都可能是不同的。</li></ul><h4 id="使用Uniform缓冲"><a href="#使用Uniform缓冲" class="headerlink" title="使用Uniform缓冲"></a>使用Uniform缓冲</h4><ul><li><p>调用glGenBuffers，创建一个Uniform缓冲对象。再将缓冲对象绑定到GL_UNIFORM_BUFFER目标，最后调用glBufferData，分配足够的内存。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uboExampleBlock;<br>glGenBuffers(<span class="hljs-number">1</span>, &amp;uboExampleBlock);<br>glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);<br>glBufferData(GL_UNIFORM_BUFFER, <span class="hljs-number">152</span>, <span class="hljs-literal">NULL</span>, GL_STATIC_DRAW); <span class="hljs-comment">// 分配152字节的内存</span><br>glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><p>在OpenGL上下文中，定义了一些绑定点(Binding Point)，我们可以将一个Uniform缓冲链接至它。在创建Uniform缓冲之后，我们将它绑定到其中一个绑定点上，并将着色器中的Uniform块绑定到相同的绑定点，把它们连接到一起。</p></li><li><img src="/2019/02/09/高级OpenGL（下）/advanced_glsl_binding_points.png" alt="绑定点"></li></ul><div class="table-container"><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td>glUniformBlockBinding</td><td>将Uniform块绑定到一个特定的绑定点中，它的第一个参数是一个 <em>程序对象</em> ，之后是一个 <em>Uniform块索引</em> 和 <em>链接到的绑定点</em> 。</td></tr><tr><td>glGetUniformBlockIndex</td><td>获取Uniform块索引(Uniform Block Index)使用，接受一个程序对象和Uniform块的名称。</td></tr><tr><td>glBindBufferBase</td><td>所需参数为 目标，绑定点索引，Uniform缓冲对象。</td></tr><tr><td>glBindBufferRange</td><td>所需参数为 目标，绑定点索引，Uniform缓冲对象，附加偏移量，大小。使用glBindBufferRange函数，你可以让多个不同的Uniform块绑定到同一个Uniform缓冲对象上。</td></tr></tbody></table></div><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取shaderA中名为Lights的Uniform块索引，将绑定到2号绑定点中。</span><br><span class="hljs-comment">// 需要注意对每个着色器重复这一步骤。</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lights_index = glGetUniformBlockIndex(shaderA.ID, <span class="hljs-string">"Lights"</span>);   <br>glUniformBlockBinding(shaderA.ID, lights_index, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">从OpenGL <span class="hljs-number">4.2</span>版本起，<br>可以添加一个布局标识符，<br>显式地将Uniform块的绑定点储存在着色器中，<br>下面的代码显式地设置了Lights Uniform块的绑定点。<br><br>layout(std140, binding = <span class="hljs-number">2</span>) uniform Lights &#123; ... &#125;;<br></code></pre></td></tr></table></figure><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数将uboExampleBlock链接到绑定点2</span><br>glBindBufferBase(GL_UNIFORM_BUFFER, <span class="hljs-number">2</span>, uboExampleBlock);<br><span class="hljs-comment">// 或</span><br>glBindBufferRange(GL_UNIFORM_BUFFER, <span class="hljs-number">2</span>, uboExampleBlock, <span class="hljs-number">0</span>, <span class="hljs-number">152</span>);<br></code></pre></td></tr></table></figure><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul><li>将投影和模型矩阵存储到一个叫做Matrices的Uniform块中，用四个shader分别绘制立方体。</li><li>四个shader公用同一个份顶点着色器代码。</li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std140</span>) <span class="hljs-keyword">uniform</span> Matrices<br>&#123;<br>    <span class="hljs-type">mat4</span> projection;<br>    <span class="hljs-type">mat4</span> view;<br>&#125;;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 需要对每个shader都做一次，将顶点着色器的Uniform块设置为绑定点0</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uniformBlockIndexRed = glGetUniformBlockIndex(shaderRed.ID, <span class="hljs-string">"Matrices"</span>);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uniformBlockIndexGreen = glGetUniformBlockIndex(shaderGreen.ID, <span class="hljs-string">"Matrices"</span>);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uniformBlockIndexBlue = glGetUniformBlockIndex(shaderBlue.ID, <span class="hljs-string">"Matrices"</span>);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uniformBlockIndexYellow = glGetUniformBlockIndex(shaderYellow.ID, <span class="hljs-string">"Matrices"</span>);<br><br>glUniformBlockBinding(shaderRed.ID, uniformBlockIndexRed, <span class="hljs-number">0</span>);<br>glUniformBlockBinding(shaderGreen.ID, uniformBlockIndexGreen, <span class="hljs-number">0</span>);<br>glUniformBlockBinding(shaderBlue.ID, uniformBlockIndexBlue, <span class="hljs-number">0</span>);<br>glUniformBlockBinding(shaderYellow.ID, uniformBlockIndexYellow, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 创建Uniform缓冲对象</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uboMatrices;<br>glGenBuffers(<span class="hljs-number">1</span>, &amp;uboMatrices);<br><br>glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);<br><span class="hljs-comment">// GLM矩阵类型的大小直接对应于GLSL中的mat4，其中会存储两个矩阵，故大小设置为2个mat4</span><br>glBufferData(GL_UNIFORM_BUFFER, <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(glm::mat4), <span class="hljs-literal">NULL</span>, GL_STATIC_DRAW);<br>glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 将Uniform缓冲对象链接到绑定点0</span><br>glBindBufferRange(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>, uboMatrices, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(glm::mat4));<br><br><span class="hljs-comment">// 将projection矩阵数据写入</span><br>glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (<span class="hljs-keyword">float</span>)SCR_WIDTH / (<span class="hljs-keyword">float</span>)SCR_HEIGHT, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br>glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);<br>glBufferSubData(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(glm::mat4), glm::value_ptr(projection));<br>glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">while</span>(loop) &#123;<br>  ...<br>  <span class="hljs-comment">// 在loop中只需要更新一次view矩阵</span><br>  glm::mat4 view = camera.GetViewMatrix();<br>glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);<br>glBufferSubData(GL_UNIFORM_BUFFER, <span class="hljs-keyword">sizeof</span>(glm::mat4), <span class="hljs-keyword">sizeof</span>(glm::mat4), glm::value_ptr(view));<br>glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><img src="/2019/02/09/高级OpenGL（下）/advanced_glsl_uniform_buffer_objects.png" alt="例子"></li></ul><hr><h2 id="几何着色器-Geometry-Shader"><a href="#几何着色器-Geometry-Shader" class="headerlink" title="几何着色器(Geometry Shader)"></a>几何着色器(Geometry Shader)</h2><ul><li><img src="/2019/02/09/高级OpenGL（下）/pipeline.png" alt="图形渲染管线"></li><li>在顶点和片段着色器之间有一个可选的几何着色器(Geometry Shader)，几何着色器的输入是一个图元（如点或三角形）的一组顶点。几何着色器可以在顶点发送到下一着色器阶段之前对它们随意变换，如生成更多的顶点或变成其他图元。</li></ul><h3 id="使用几何着色器"><a href="#使用几何着色器" class="headerlink" title="使用几何着色器"></a>使用几何着色器</h3><h4 id="几何着色器例子"><a href="#几何着色器例子" class="headerlink" title="几何着色器例子"></a>几何着色器例子</h4><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-comment">// 声明从顶点着色器输入的图元类型</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">points</span>) <span class="hljs-keyword">in</span>;<br><span class="hljs-comment">// 指定几何着色器输出的图元类型</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">triangle_strip</span>, <span class="hljs-keyword">max_vertices</span> = <span class="hljs-number">5</span>) <span class="hljs-keyword">out</span>;<br><br><span class="hljs-type">void</span> build_house(<span class="hljs-type">vec4</span> position)<br>&#123;    <br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>(<span class="hljs-number">-0.2</span>, <span class="hljs-number">-0.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 1:左下</span><br>    <span class="hljs-built_in">EmitVertex</span>();   <br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>( <span class="hljs-number">0.2</span>, <span class="hljs-number">-0.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 2:右下</span><br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>(<span class="hljs-number">-0.2</span>,  <span class="hljs-number">0.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 3:左上</span><br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>( <span class="hljs-number">0.2</span>,  <span class="hljs-number">0.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 4:右上</span><br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>( <span class="hljs-number">0.0</span>,  <span class="hljs-number">0.4</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 5:顶部</span><br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">EndPrimitive</span>();<br>&#125;<br><br><span class="hljs-type">void</span> main() &#123;    <br>    build_house(<span class="hljs-built_in">gl_in</span>[<span class="hljs-number">0</span>].<span class="hljs-built_in">gl_Position</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>从上面的例子中可以看到，几何着色器顶部需要声明从顶点着色器输入的图元类型，需要在 <font color="#D2691E" size="4"> <em>in</em> </font> 关键字前声明一个布局修饰符(Layout Qualifier)。这个输入布局修饰符可以从顶点着色器接收下列任何一个图元值：</li><li>提供给glDrawArrays渲染函数的几乎所有图元：</li></ul><div class="table-container"><table><thead><tr><th>shader中的输入图元</th><th>glDrawArrays中对应的图元</th><th>最小顶点数</th></tr></thead><tbody><tr><td>points</td><td>绘制GL_POINTS图元时</td><td>1</td></tr><tr><td>lines</td><td>绘制GL_LINES或GL_LINE_STRIP时</td><td>2</td></tr><tr><td>lines_adjacency</td><td>GL_LINES_ADJACENCY或GL_LINE_STRIP_ADJACENCY</td><td>4</td></tr><tr><td>triangles</td><td>GL_TRIANGLES、GL_TRIANGLE_STRIP或GL_TRIANGLE_FAN</td><td>3</td></tr><tr><td>triangles_adjacency</td><td>GL_TRIANGLES_ADJACENCY或GL_TRIANGLE_STRIP_ADJACENCY</td><td>6</td></tr></tbody></table></div><ul><li>同时，也需要指定几何着色器输出的图元类型，这需要在<font color="#D2691E" size="4"> <em>out</em> </font>关键字前面加一个布局修饰符，并设置一个它最大能够输出的顶点数量（如果你超过了这个值，OpenGL将不会绘制多出的顶点），上面的例子中设置了输出为triangle_strip且最大顶点数为5个。</li><li>输出布局修饰符可以接受的图元值：</li></ul><div class="table-container"><table><thead><tr><th>shader中的输出图元</th><th>含义</th><th>最小顶点数</th></tr></thead><tbody><tr><td>points</td><td>点</td><td>1</td></tr><tr><td>line_strip</td><td>按顺序连接所有给定点的一条线</td><td>2</td></tr><tr><td>triangle_strip</td><td>每3个临近的顶点将会形成一个三角形，如给出5个点，按(1, 2, 3)、(2, 3, 4)、(3, 4, 5)这样的分配来绘制3个三角形</td><td>3</td></tr></tbody></table></div><ul><li>例子往下看，在main函数中，通过内建变量gl_in来访问传入的图元，可以看出gl_in是一个数组，其内部实现类似于一个包含多个特征的结构体。</li></ul><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 内建变量gl_in的大概实现</span><br><span class="hljs-comment">// 其为一个接口块</span><br><span class="hljs-comment">// 其包含gl_Position位置信息，gl_PointSize大小信息</span><br><span class="hljs-comment">// gl_ClipDistance是为顶点裁剪提供了向前兼容所使用</span><br>in gl_Vertex<br>&#123;<br>    vec4  gl_Position;<br>    <span class="hljs-keyword">float</span> gl_PointSize;<br>    <span class="hljs-keyword">float</span> gl_ClipDistance[];<br>&#125; gl_in[];<br></code></pre></td></tr></table></figure><ul><li><p>查看main函数中调用的build_house函数，在每次对position进行位移之后，都调用了EmitVertex()函数，因为在调用了该函数后，gl_Position中的向量会被添加到图元中来；在函数最后调用了EndPrimitive()函数，这样所有发射出的(Emitted)顶点都会合成为指定的输出渲染图元。在一个或多个EmitVertex调用之后重复调用EndPrimitive能够生成多个图元。</p></li><li><p>至此，整段几何着色器的代码已解析完毕，其实现的功能便是接受一个点图元作为输入，以该点位中心，通过5次位移，生成5个新点，并将它们合成一个triangle_strip图元，该图元将会绘制3个三角形。</p></li></ul><h4 id="将例子显示"><a href="#将例子显示" class="headerlink" title="将例子显示"></a>将例子显示</h4><ul><li><p>出于简单考虑，顶点着色器和片段着色器都进行硬编码，写死一些数据即可。</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// vs</span><br><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>&#125;<br><br><span class="hljs-comment">// fs</span><br><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);   <br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对于几何着色器，我们也需要进行编译和连接，其传入的着色器类型为<font color="#D2691E" size="4"> <em>GL_GEOMETRY_SHADER</em> </font></p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">geometryShader = glCreateShader(GL_GEOMETRY_SHADER);<br>glShaderSource(geometryShader, <span class="hljs-number">1</span>, &amp;gShaderCode, <span class="hljs-literal">NULL</span>);<br>glCompileShader(geometryShader);  <br>...<br>glAttachShader(program, geometryShader);<br>glLinkProgram(program);<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/02/09/高级OpenGL（下）/geometry_sample.png" alt="效果显示"></p></li></ul><h3 id="爆破物体"><a href="#爆破物体" class="headerlink" title="爆破物体"></a>爆破物体</h3><ul><li>将物体的每个图元向法线方向进行小量位移，我们可以轻易得到类似物体爆破的效果。几何着色器提供了让我们访问及操作图元的可能，通过几何着色器，我们便可以实现爆破效果。</li><li><img src="/2019/02/09/高级OpenGL（下）/geometry_explode.png" alt="效果显示"></li></ul><h3 id="法向量可视化"><a href="#法向量可视化" class="headerlink" title="法向量可视化"></a>法向量可视化</h3><ul><li>首先不使用几何着色器正常绘制场景。然后再次绘制场景，但这次只显示通过几何着色器生成法向量。几何着色器接收一个三角形图元，并沿着法向量生成三条线——每个顶点一个法向量。</li><li><p>伪代码：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">shader.use();<br>DrawScene();<br>normalDisplayShader.use();<br>DrawScene();<br></code></pre></td></tr></table></figure></li><li><p>几何着色器接受的位置向量是剪裁空间坐标，所以需要将法向量变换到相同的空间中，这一步可以在顶点着色器中完成。</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aNormal;<br><br><span class="hljs-keyword">out</span> VS_OUT &#123;<br>    <span class="hljs-type">vec3</span> normal;<br>&#125; vs_out;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-type">mat3</span> normalMatrix = <span class="hljs-type">mat3</span>(<span class="hljs-built_in">transpose</span>(<span class="hljs-built_in">inverse</span>(view * model)));<br>    vs_out.normal = <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(projection * <span class="hljs-type">vec4</span>(normalMatrix * aNormal, <span class="hljs-number">0.0</span>)));<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">triangles</span>) <span class="hljs-keyword">in</span>;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">line_strip</span>, <span class="hljs-keyword">max_vertices</span> = <span class="hljs-number">6</span>) <span class="hljs-keyword">out</span>;<br><br><span class="hljs-keyword">in</span> VS_OUT &#123;<br>    <span class="hljs-type">vec3</span> normal;<br>&#125; gs_in[];<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> MAGNITUDE = <span class="hljs-number">0.4</span>;<br><br><span class="hljs-type">void</span> GenerateLine(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>)<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">gl_in</span>[<span class="hljs-keyword">index</span>].<span class="hljs-built_in">gl_Position</span>;<br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">gl_in</span>[<span class="hljs-keyword">index</span>].<span class="hljs-built_in">gl_Position</span> + <span class="hljs-type">vec4</span>(gs_in[<span class="hljs-keyword">index</span>].normal, <span class="hljs-number">0.0</span>) * MAGNITUDE;<br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">EndPrimitive</span>();<br>&#125;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    GenerateLine(<span class="hljs-number">0</span>); <span class="hljs-comment">// 第一个顶点法线</span><br>    GenerateLine(<span class="hljs-number">1</span>); <span class="hljs-comment">// 第二个顶点法线</span><br>    GenerateLine(<span class="hljs-number">2</span>); <span class="hljs-comment">// 第三个顶点法线</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>从模型内部往外看，可以看到每个顶点的法线均被显示出来。</li><li><img src="/2019/02/09/高级OpenGL（下）/geometry_shownormal.png" alt="效果显示"></li></ul><hr><h2 id="实例化-Instancing"><a href="#实例化-Instancing" class="headerlink" title="实例化(Instancing)"></a>实例化(Instancing)</h2><ul><li>对于要绘制很多相同模型的场景，过去我们使用的方式是要创建多少个实例则调用多少次glDrawArrays或glDrawElements，这种做法十分消耗性能。</li><li>使用glDrawArrays或glDrawElements函数告诉GPU去绘制你的顶点数据会消耗更多的性能，因为OpenGL在绘制顶点数据之前需要做很多准备工作（比如告诉GPU该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的CPU到GPU总线(CPU to GPU Bus)上进行的）。所以，即便渲染顶点非常快，命令GPU去渲染却未必。</li><li>如果模型都是使用同一份顶点数据，只是进行了不同的世界空间转换，我们可以将数据一次性发送给GPU，然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体，这就是<font color="#D2691E" size="5"> <em>实例化</em> </font>。</li><li>实例化这项技术能够让我们使用一个渲染调用来绘制多个物体，来节省每次绘制物体时CPU -&gt; GPU的通信，它只需要一次即可。</li></ul><h3 id="glDrawArraysInstanced和glDrawElementsInstanced"><a href="#glDrawArraysInstanced和glDrawElementsInstanced" class="headerlink" title="glDrawArraysInstanced和glDrawElementsInstanced"></a>glDrawArraysInstanced和glDrawElementsInstanced</h3><ul><li>glDrawArraysInstanced和glDrawElementsInstanced分别对应glDrawArrays和glDrawElements，相比只是多了一个叫做实例数量(Instance Count)的参数，它能够设置我们需要渲染的实例个数。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glBindVertexArray(quadVAO);<br>glDrawArraysInstanced(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="gl-InstanceID"><a href="#gl-InstanceID" class="headerlink" title="gl_InstanceID"></a>gl_InstanceID</h3><ul><li>在使用实例化渲染调用时，gl_InstanceID会从0开始，在每个实例被渲染时递增1。</li><li>使用实例化渲染函数进行物体渲染后，物体会集中在同一个位置，并没有太大用处，通过gl_InstanceID，我们可以得知当前正在渲染哪个实例，从而在shader中进行针对性处理。</li><li><p>利用gl_InstanceID对方形进行缩小及获得位置偏移量：</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aColor;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fColor;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec2</span> offsets[<span class="hljs-number">100</span>];<br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-type">vec2</span> pos = aPos * (<span class="hljs-built_in">gl_InstanceID</span> / <span class="hljs-number">100.0</span>);<br>    <span class="hljs-type">vec2</span> <span class="hljs-keyword">offset</span> = offsets[<span class="hljs-built_in">gl_InstanceID</span>];<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(pos + <span class="hljs-keyword">offset</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fColor = aColor;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/02/09/高级OpenGL（下）/instancing_InstanceID.png" alt="利用gl_InstanceID对方形进行缩小"></p></li></ul><h3 id="实例化数组-Instanced-Array"><a href="#实例化数组-Instanced-Array" class="headerlink" title="实例化数组(Instanced Array)"></a>实例化数组(Instanced Array)</h3><ul><li>使用uniform数组来获取每个实例位置的方式能力终究有限，当实例数量远超100的时候，发送至着色器的uniform数据大小将会超过上限。</li><li>实例化数组(Instanced Array)能够有效解决传输数据过大的问题。它被定义为一个顶点属性（能够让我们储存更多的数据），仅在顶点着色器渲染一个新的实例时才会更新。</li><li><p>将位置偏移量改为使用实例化数组来实现：</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aColor;<br><span class="hljs-comment">// 实例化数组</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aOffset;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fColor;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-type">vec2</span> pos = aPos * (<span class="hljs-built_in">gl_InstanceID</span> / <span class="hljs-number">100.0</span>);<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(pos + aOffset, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fColor = aColor;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实例化数组的配置方式：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> instanceVBO;<br>glGenBuffers(<span class="hljs-number">1</span>, &amp;instanceVBO);<br>glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);<br>glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(glm::vec2) * <span class="hljs-number">100</span>, &amp;translations[<span class="hljs-number">0</span>], GL_STATIC_DRAW);<br>glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<br>glEnableVertexAttribArray(<span class="hljs-number">2</span>);<br>glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);<br>glVertexAttribPointer(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);<br>glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 告诉OpenGL什么时候更新顶点属性的内容至新一组数据</span><br>glVertexAttribDivisor(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p>上面代码最后一处的<font color="#D2691E" size="4"> <em>glVertexAttribDivisor</em> </font>用于告知OpenGL合适更新顶点属性数据。其接受两个参数，第一个参数是顶点属性，在上面的例子中位置偏移量的顶点属性值是2；第二个参数是属性除数，即告知OpenGL每隔多少个实例更新一次顶点数据，默认值为0，表示不刷新，现在传1，表示每渲染一个新实例后便更新顶点属性。</p></li></ul><h3 id="使用实例化绘制小行星带"><a href="#使用实例化绘制小行星带" class="headerlink" title="使用实例化绘制小行星带"></a>使用实例化绘制小行星带</h3><ul><li>小行星带中含有成千上万的小陨石，是使用实例化的较好例子。</li><li><p>我们使用实例化数组来存放陨石位置，其对应的顶点着色器代码如下：</p><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoords;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">mat4</span> instanceMatrix;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> TexCoords;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * instanceMatrix * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>    TexCoords = aTexCoords;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对于陨石模型的每个网格，我们需要通过glVertexAttribDivisor设置每渲染一个物体则更新数据，在Loop中使用glDrawElementsInstanced绘制多个陨石。</p></li><li><p>现在我们改为使用mat4的顶点属性来存储model矩阵。然而，当我们顶点属性的类型大于vec4时，就要多进行一步处理了。顶点属性最大允许的数据大小等于一个vec4。因为一个mat4本质上是4个vec4，我们需要为这个矩阵预留4个顶点属性。因为我们将它的位置值设置为3，矩阵每一列的顶点属性位置值就是3、4、5和6。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 顶点缓冲对象</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> buffer;<br>glGenBuffers(<span class="hljs-number">1</span>, &amp;buffer);<br>glBindBuffer(GL_ARRAY_BUFFER, buffer);<br>glBufferData(GL_ARRAY_BUFFER, amount * <span class="hljs-keyword">sizeof</span>(glm::mat4), &amp;modelMatrices[<span class="hljs-number">0</span>], GL_STATIC_DRAW);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rock.meshes.size(); i++)<br>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> VAO = rock.meshes[i].VAO;<br>    glBindVertexArray(VAO);<br>    <span class="hljs-comment">// 顶点属性</span><br>    GLsizei vec4Size = <span class="hljs-keyword">sizeof</span>(glm::vec4);<br>    glEnableVertexAttribArray(<span class="hljs-number">3</span>);<br>    glVertexAttribPointer(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">4</span> * vec4Size, (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);<br>    glEnableVertexAttribArray(<span class="hljs-number">4</span>);<br>    glVertexAttribPointer(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">4</span> * vec4Size, (<span class="hljs-keyword">void</span>*)(vec4Size));<br>    glEnableVertexAttribArray(<span class="hljs-number">5</span>);<br>    glVertexAttribPointer(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">4</span> * vec4Size, (<span class="hljs-keyword">void</span>*)(<span class="hljs-number">2</span> * vec4Size));<br>    glEnableVertexAttribArray(<span class="hljs-number">6</span>);<br>    glVertexAttribPointer(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">4</span> * vec4Size, (<span class="hljs-keyword">void</span>*)(<span class="hljs-number">3</span> * vec4Size));<br><br>    glVertexAttribDivisor(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>    glVertexAttribDivisor(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>);<br>    glVertexAttribDivisor(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>);<br>    glVertexAttribDivisor(<span class="hljs-number">6</span>, <span class="hljs-number">1</span>);<br><br>    glBindVertexArray(<span class="hljs-number">0</span>);<br>&#125;<br><br>...<br><br><span class="hljs-comment">// 绘制小行星</span><br>instanceShader.use();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rock.meshes.size(); i++)<br>&#123;<br>    glBindVertexArray(rock.meshes[i].VAO);<br>    glDrawElementsInstanced(<br>        GL_TRIANGLES, rock.meshes[i].indices.size(), GL_UNSIGNED_INT, <span class="hljs-number">0</span>, amount<br>    );<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/02/09/高级OpenGL（下）/instancing_planet.png" alt="小行星带"></p></li></ul><hr><h2 id="抗锯齿-Anti-Aliasing"><a href="#抗锯齿-Anti-Aliasing" class="headerlink" title="抗锯齿(Anti Aliasing)"></a>抗锯齿(Anti Aliasing)</h2><ul><li>在绘制物体的过程中，由于某个具体像素点要么选择采样要么选择不采样，导致在高分辨率的情况下，其边缘会产生较严重的锯齿现象。</li><li>引用知乎文刀秋二的话来讲：“锯齿的来源是因为场景的定义在三维空间中是连续的，而最终显示的像素则是一个离散的二维数组。所以判断一个点到底没有被某个像素覆盖的时候单纯是一个“有”或者“没有”问题，丢失了连续性的信息，导致锯齿。”</li></ul><h3 id="锯齿产生原因"><a href="#锯齿产生原因" class="headerlink" title="锯齿产生原因"></a>锯齿产生原因</h3><ul><li><img src="/2019/02/09/高级OpenGL（下）/pipeline.png" alt="图形渲染管线"></li><li>物体边缘产生锯齿与光栅器将顶点数据转化为片段的方式有关，光栅器是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。</li><li><p>光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任意值，但片段不行，因为它们受限于你窗口的分辨率。顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段/屏幕坐标。</p></li><li><p><img src="/2019/02/09/高级OpenGL（下）/anti_aliasing_rasterization.png" alt="光栅化"></p></li><li>上图是渲染一个三角形光栅化的过程，左图中每个像素点中心都有一个采样点，当采样点处于三角形中时，该像素会生成一个片段。根据该方式得到的右图的片段，该片段也是最终渲染在屏幕上的效果，从此处可以看出锯齿产生的原因。</li></ul><h3 id="多重采样抗锯齿-Multisample-Anti-aliasing-MSAA"><a href="#多重采样抗锯齿-Multisample-Anti-aliasing-MSAA" class="headerlink" title="多重采样抗锯齿(Multisample Anti-aliasing, MSAA)"></a>多重采样抗锯齿(Multisample Anti-aliasing, MSAA)</h3><ul><li><img src="/2019/02/09/高级OpenGL（下）/anti_aliasing_sample_points.png" alt="多重采样"></li><li>由于仅通过对像素中心点是否在物体内来判断是否生成片段的方式容易出现锯齿，一个更好的方式是增加采样点，通过被物体所包含的采样点的数量来决定是否生成片段及片段的颜色缓冲大小。</li><li>右图是以特定图案排列的4个子采样点(Subsample)。我们将用这些子采样点来决定像素的遮盖度。颜色缓冲的大小会随着子采样点的增加而增加。</li><li><img src="/2019/02/09/高级OpenGL（下）/msaa.jpg" alt="MSAA工作方式"></li><li>MSAA的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只运行一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。</li></ul><h3 id="OpenGL中的MSAA"><a href="#OpenGL中的MSAA" class="headerlink" title="OpenGL中的MSAA"></a>OpenGL中的MSAA</h3><ul><li>使用MSAA需要一个能在每个像素中存储大于1个颜色值的颜色缓冲（因为多重采样需要我们为每个采样点都储存一个颜色）。所以，我们需要一个新的缓冲类型，来存储特定数量的多重采样样本，它叫做多重采样缓冲(Multisample Buffer)。</li><li><p>大多数的窗口系统都应该提供了一个多重采样缓冲，用以代替默认的颜色缓冲。在GLFW中，需要在创建窗口之前调用glfwWindowHint来设置包含多重采样的样本数量。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glfwWindowHint(GLFW_SAMPLES, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure></li><li><p>在调用了上述接口后，再使用glfwCreateWindow创建渲染窗口时，每个屏幕坐标就会使用一个包含4个子采样点的颜色缓冲了。GLFW会自动创建一个每像素4个子采样点的深度和样本缓冲。这也意味着所有缓冲的大小都增长了4倍。另外，还需要启用GL_MULTISAMPLE来确保启用了多重采样。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glEnable(GL_MULTISAMPLE);<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/02/09/高级OpenGL（下）/anti_aliasing_sample.png" alt="开启MSAA对比"></p></li></ul><h3 id="离屏MSAA"><a href="#离屏MSAA" class="headerlink" title="离屏MSAA"></a>离屏MSAA</h3><ul><li>若想要使用自己的帧缓冲来进行离屏渲染，那么就必须要手动生成多重采样缓冲。</li><li>与普通帧缓冲创建使用过程类似，只需要将附件改成对应的多重采样附件。</li></ul><h4 id="多重采样纹理附件"><a href="#多重采样纹理附件" class="headerlink" title="多重采样纹理附件"></a>多重采样纹理附件</h4><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex);<br>glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE);<br>glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, <span class="hljs-number">0</span>);<br><br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li>为了创建一个支持储存多个采样点的纹理，我们使用<font color="#D2691E" size="4"> <em>glTexImage2DMultisample</em> </font>来替代glTexImage2D，它的纹理目标是GL_TEXTURE_2D_MULTISAPLE。</li><li>它的第二个参数设置的是纹理所拥有的样本个数。如果最后一个参数为GL_TRUE，图像将会对每个纹素使用相同的样本位置以及相同数量的子采样点个数。</li><li>使用glFramebufferTexture2D将多重采样纹理附加到帧缓冲上，但这里纹理类型使用的是GL_TEXTURE_2D_MULTISAMPLE。</li></ul><h4 id="多重采样渲染缓冲对象"><a href="#多重采样渲染缓冲对象" class="headerlink" title="多重采样渲染缓冲对象"></a>多重采样渲染缓冲对象</h4><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> rbo;<br>glGenRenderbuffers(<span class="hljs-number">1</span>, &amp;rbo);<br>glBindRenderbuffer(GL_RENDERBUFFER, rbo);<br>glRenderbufferStorageMultisample(GL_RENDERBUFFER, <span class="hljs-number">4</span>, GL_DEPTH24_STENCIL8, SCR_WIDTH, SCR_HEIGHT);<br>glBindRenderbuffer(GL_RENDERBUFFER, <span class="hljs-number">0</span>);<br>glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);<br></code></pre></td></tr></table></figure><ul><li>我们所要做的只是在指定（当前绑定的）渲染缓冲的内存存储时，将glRenderbufferStorage的调用改为<font color="#D2691E" size="4"> <em>glRenderbufferStorageMultisample</em> </font>就可以了。</li></ul><h4 id="渲染到多重采样帧缓冲"><a href="#渲染到多重采样帧缓冲" class="headerlink" title="渲染到多重采样帧缓冲"></a>渲染到多重采样帧缓冲</h4><ul><li>渲染到多重采样帧缓冲对象的过程都是自动的。只要我们在帧缓冲绑定时绘制任何东西，光栅器就会负责所有的多重采样运算。我们最终会得到一个多重采样颜色缓冲以及/或深度和模板缓冲。因为多重采样缓冲有一点特别，我们不能直接将它们的缓冲图像用于其他运算，比如在着色器中对它们进行采样。</li><li>一个多重采样的图像包含比普通图像更多的信息，我们所要做的是缩小或者还原(Resolve)图像。多重采样帧缓冲的还原通常是通过<font color="#D2691E" size="4"> <em>glBlitFramebuffer</em> </font>来完成，它能够将一个帧缓冲中的某个区域复制到另一个帧缓冲中，并且将多重采样缓冲还原。</li><li><p><font color="#D2691E" size="4"> <em>glBlitFramebuffer</em> </font>会将一个用4个屏幕空间坐标所定义的源区域复制到一个同样用4个屏幕空间坐标所定义的目标区域中。将帧缓冲分开绑定至GL_READ_FRAMEBUFFER与GL_DRAW_FRAMEBUFFER。glBlitFramebuffer函数会根据这两个目标，决定哪个是源帧缓冲，哪个是目标帧缓冲。接下来，将图像位块传送(Blit)到默认的帧缓冲中，将多重采样的帧缓冲传送到屏幕上。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">glBindFramebuffer(GL_READ_FRAMEBUFFER, framebuffer);<br>glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO);<br>glBlitFramebuffer(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCR_WIDTH, SCR_HEIGHT, GL_COLOR_BUFFER_BIT, GL_NEAREST);<br></code></pre></td></tr></table></figure></li><li><p><img src="/2019/02/09/高级OpenGL（下）/offscreen.png" alt="离屏MSAA"></p></li></ul><h3 id="自定义抗锯齿算法"><a href="#自定义抗锯齿算法" class="headerlink" title="自定义抗锯齿算法"></a>自定义抗锯齿算法</h3><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2DMS</span> screenTextureMS;<br><span class="hljs-type">vec4</span> colorSample = <span class="hljs-built_in">texelFetch</span>(screenTextureMS, TexCoords, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 第4个子样本</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 高级OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高级OpenGL（上）</title>
      <link href="/2018/12/23/%E9%AB%98%E7%BA%A7OpenGL%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2018/12/23/%E9%AB%98%E7%BA%A7OpenGL%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 高级OpenGL学习笔记</p><p>深度测试，模板测试，混合，面剔除，帧缓冲，立方体贴图。</p></blockquote><a id="more"></a><h2 id="深度测试-Depth-testing"><a href="#深度测试-Depth-testing" class="headerlink" title="深度测试(Depth testing)"></a>深度测试(Depth testing)</h2><ul><li>将3D世界中的东西用2D屏幕来表示，我们需要知道物体的前后关系以让物体以正确的方式渲染。在OpenGL中是通过储存在深度缓冲（或z缓冲(z-buffer)）中的深度值(Depth Value)来确定一个片段是处于其它片段后方的。</li></ul><h3 id="深度测试运行机制"><a href="#深度测试运行机制" class="headerlink" title="深度测试运行机制"></a>深度测试运行机制</h3><h4 id="深度缓冲"><a href="#深度缓冲" class="headerlink" title="深度缓冲"></a>深度缓冲</h4><ul><li>深度缓冲就像颜色缓冲(Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。深度缓冲是由窗口系统自动创建的，它会以16、24或32位float的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是24位的。</li></ul><h4 id="深度测试规则"><a href="#深度测试规则" class="headerlink" title="深度测试规则"></a>深度测试规则</h4><ul><li><p>深度测试默认是禁用的，所以如果要启用深度测试的话，我们需要用GL_DEPTH_TEST选项来启用它：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glEnable(GL_DEPTH_TEST);<br></code></pre></td></tr></table></figure></li><li><p>当深度测试(Depth Testing)被启用的时候，OpenGL会将一个片段的的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值（深度缓冲中储存该片段的z值）。如果深度测试失败了，片段将会被丢弃。</p></li><li><p>因为深度被缓存，一般情况下，在每个渲染迭代前会使用GL_DEPTH_BUFFER_BIT来清除深度缓冲：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br></code></pre></td></tr></table></figure></li><li><p>OpenGL允许我们禁用深度缓冲的写入：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glDepthMask(GL_FALSE);<br></code></pre></td></tr></table></figure></li></ul><h4 id="深度测试时机"><a href="#深度测试时机" class="headerlink" title="深度测试时机"></a>深度测试时机</h4><ul><li>深度缓冲是在片段着色器运行之后（以及模板测试(Stencil Testing)运行之后，我们将在下一节中讨论）在屏幕空间中运行的。屏幕空间坐标与通过OpenGL的glViewport所定义的视口密切相关，并且可以直接使用GLSL内建变量gl_FragCoord从片段着色器中直接访问。gl_FragCoord的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。gl_FragCoord中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值。</li></ul><h4 id="提前深度测试"><a href="#提前深度测试" class="headerlink" title="提前深度测试"></a>提前深度测试</h4><ul><li>现在大部分的GPU都提供一个叫做提前深度测试(Early Depth Testing)的硬件特性。提前深度测试允许深度测试在片段着色器之前运行。只要我们清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。</li><li>片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL不能提前知道深度值。</li></ul><hr><h3 id="深度测试函数"><a href="#深度测试函数" class="headerlink" title="深度测试函数"></a>深度测试函数</h3><ul><li>OpenGL允许我们修改深度测试中使用的比较运算符。这允许我们来控制OpenGL什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。我们可以调用glDepthFunc函数来设置比较运算符（或者说深度函数(Depth Function)）：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glDepthFunc(GL_LESS);<br></code></pre></td></tr></table></figure></li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>GL_ALWAYS</td><td>永远通过深度测试</td></tr><tr><td>GL_NEVER</td><td>永远不通过深度测试</td></tr><tr><td>GL_LESS</td><td>在片段深度值小于缓冲的深度值时通过测试</td></tr><tr><td>GL_EQUAL</td><td>在片段深度值等于缓冲区的深度值时通过测试</td></tr><tr><td>GL_LEQUAL</td><td>在片段深度值小于等于缓冲区的深度值时通过测试</td></tr><tr><td>GL_GREATER</td><td>在片段深度值大于缓冲区的深度值时通过测试</td></tr><tr><td>GL_NOTEQUAL</td><td>在片段深度值不等于缓冲区的深度值时通过测试</td></tr><tr><td>GL_GEQUAL</td><td>在片段深度值大于等于缓冲区的深度值时通过测试</td></tr></tbody></table></div><hr><h3 id="深度值"><a href="#深度值" class="headerlink" title="深度值"></a>深度值</h3><h4 id="深度值精度"><a href="#深度值精度" class="headerlink" title="深度值精度"></a>深度值精度</h4><ul><li>使用线性深度缓冲(Linear Depth Buffer)会使得对1000单位远的物体和只有1单位远的充满细节的物体使用相同的精度，这与投影性质不相符，我们希望在近处有更精细的精度，而远处的精度可以很粗糙。</li><li>由投影矩阵所得的深度缓冲值函数：<script type="math/tex; mode=display">F_{depth} = \frac{1/z - 1/near}{1/far - 1/near}</script></li><li><img src="/2018/12/23/高级OpenGL（上）/depth_non_linear_graph.png" alt="z值和最终的深度缓冲值之间的非线性关系"></li></ul><h4 id="深度值可视化"><a href="#深度值可视化" class="headerlink" title="深度值可视化"></a>深度值可视化</h4><ul><li><p>片段着色器改为：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    FragColor = vec4(vec3(gl_FragCoord.z), <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>可视化的深度值如下图，几乎全白，很靠近物体的时候才会有黑色，体现了深度值的非线性特性。</p></li><li><img src="/2018/12/23/高级OpenGL（上）/depth_testing_depth.png" alt="深度值可视化"></li></ul><hr><h3 id="深度冲突"><a href="#深度冲突" class="headerlink" title="深度冲突"></a>深度冲突</h3><ul><li>一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。</li><li>由于深度值非线性，远近平面距离短时处于较远处的物体更容易出现深度冲突。</li><li><img src="/2018/12/23/高级OpenGL（上）/z_fighting.png" alt="深度冲突"></li><li><img src="/2018/12/23/高级OpenGL（上）/depth_testing_zfighting.png" alt="深度冲突"></li></ul><h4 id="防止深度冲突"><a href="#防止深度冲突" class="headerlink" title="防止深度冲突"></a>防止深度冲突</h4><ul><li><p>第一个也是最重要的技巧是永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，我们可以将箱子沿着正y轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。</p></li><li><p>第二个技巧是尽可能将近平面设置远一些。在前面我们提到了精度在靠近近平面时是非常高的，所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。</p></li><li><p>另外一个很好的技巧是牺牲一些性能，使用更高精度的深度缓冲。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。</p></li></ul><hr><h2 id="模板测试-Stencil-testing"><a href="#模板测试-Stencil-testing" class="headerlink" title="模板测试(Stencil testing)"></a>模板测试(Stencil testing)</h2><ul><li>一个模板缓冲中，（通常）每个模板值(Stencil Value)是8位的。所以每个像素/片段一共能有256种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。<blockquote><p>每个窗口库都需要为你配置一个模板缓冲。GLFW自动做了这件事，所以我们不需要告诉GLFW来创建一个，但其它的窗口库可能不会默认给你创建一个模板库，所以记得要查看库的文档。</p></blockquote></li></ul><h3 id="使用模板缓冲"><a href="#使用模板缓冲" class="headerlink" title="使用模板缓冲"></a>使用模板缓冲</h3><h4 id="大体步骤"><a href="#大体步骤" class="headerlink" title="大体步骤"></a>大体步骤</h4><ol><li><p>启用模板缓冲的写入。可以启用GL_STENCIL_TEST来启用模板测试。和颜色和深度缓冲一样，你也需要在每次迭代之前清除模板缓冲。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glEnable(GL_STENCIL_TEST);<br>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);<br></code></pre></td></tr></table></figure></li><li><p>和颜色和深度缓冲一样，你也需要在每次迭代之前清除模板缓冲。</p></li><li>禁用模板缓冲的写入。</li><li>渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。</li></ol><h4 id="掩码设置"><a href="#掩码设置" class="headerlink" title="掩码设置"></a>掩码设置</h4><ul><li>和深度测试的glDepthMask函数一样，模板缓冲也有一个类似的函数。glStencilMask允许我们设置一个位掩码(Bitmask)，它会与将要写入缓冲的模板值进行与(AND)运算。默认情况下设置的位掩码所有位都为1，不影响输出，但如果我们将它设置为0x00，写入缓冲的所有模板值最后都会变成0.这与深度测试中的glDepthMask(GL_FALSE)是等价的。</li><li>大部分情况下你都只会使用0x00或者0xFF作为模板掩码(Stencil Mask)，但是知道有选项可以设置自定义的位掩码总是好的。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glStencilMask(<span class="hljs-number">0xFF</span>); <span class="hljs-comment">// 每一位写入模板缓冲时都保持原样</span><br>glStencilMask(<span class="hljs-number">0x00</span>); <span class="hljs-comment">// 每一位在写入模板缓冲时都会变成0（禁用写入）</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h4><h5 id="glStencilFunc"><a href="#glStencilFunc" class="headerlink" title="glStencilFunc"></a>glStencilFunc</h5><ul><li>glStencilFunc决定模板与何值进行何种比较，且支持比较前进行掩码计算。</li><li>glStencilFunc(GLenum func, GLint ref, GLuint mask)一共包含三个参数：<ol><li>func：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的ref值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS。它们的语义和深度缓冲的函数类似。</li><li>ref：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。</li><li>mask：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1。</li></ol></li></ul><h5 id="glStencilOp"><a href="#glStencilOp" class="headerlink" title="glStencilOp"></a>glStencilOp</h5><ul><li>glStencilOp告诉OpenGL如何更新缓冲。</li><li>glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)一共包含三个参数：<ol><li>sfail：模板测试失败时采取的行为。</li><li>dpfail：模板测试通过，但深度测试失败时采取的行为。</li><li>dppass：模板测试和深度测试都通过时采取的行为。</li></ol></li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>GL_KEEP</td><td>保持当前储存的模板值</td></tr><tr><td>GL_ZERO</td><td>将模板值设置为0</td></tr><tr><td>GL_REPLACE</td><td>将模板值设置为glStencilFunc函数设置的ref值</td></tr><tr><td>GL_INCR</td><td>如果模板值小于最大值则将模板值加1</td></tr><tr><td>GL_INCR_WRAP</td><td>与GL_INCR一样，但如果模板值超过了最大值则归零</td></tr><tr><td>GL_DECR</td><td>如果模板值大于最小值则将模板值减1</td></tr><tr><td>GL_DECR_WRAP</td><td>与GL_DECR一样，但如果模板值小于0则将其设置为最大值</td></tr><tr><td>GL_INVERT</td><td>按位翻转当前的模板缓冲值</td></tr></tbody></table></div><ul><li>默认情况下glStencilOp是设置为(GL_KEEP, GL_KEEP, GL_KEEP)的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。</li></ul><hr><h3 id="模板缓冲例子"><a href="#模板缓冲例子" class="headerlink" title="模板缓冲例子"></a>模板缓冲例子</h3><h4 id="物体轮廓"><a href="#物体轮廓" class="headerlink" title="物体轮廓"></a>物体轮廓</h4><ul><li><p>绘制轮廓步骤</p><ol><li>在绘制（需要添加轮廓的）物体之前，将模板函数设置为GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为1。</li><li>渲染物体。</li><li>禁用模板写入以及深度测试。</li><li>将每个物体缩放一点点。</li><li>使用一个不同的片段着色器，输出一个单独的（边框）颜色。</li><li>再次绘制物体，但只在它们片段的模板值不等于1时才绘制。</li><li>再次启用模板写入和深度测试。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 开启模板缓冲</span><br>glEnable(GL_DEPTH_TEST);<br><span class="hljs-comment">// 设置测试通过时的替换模板值</span><br>glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);  <br><br><span class="hljs-comment">// 清空模板缓冲</span><br>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);<br><br>glStencilMask(<span class="hljs-number">0x00</span>); <span class="hljs-comment">// 记得保证我们在绘制地板的时候不会更新模板缓冲</span><br>normalShader.use();<br>DrawFloor()  <br><br><span class="hljs-comment">// 第一次绘制物体，让片段都通过模板测试。</span><br>glStencilFunc(GL_ALWAYS, <span class="hljs-number">1</span>, <span class="hljs-number">0xFF</span>);<br>glStencilMask(<span class="hljs-number">0xFF</span>);<br>DrawTwoContainers();<br><br><span class="hljs-comment">// 第二次绘制物体，禁止模板缓冲写入，将物体放大一点点，只通过模板缓冲值不等于1的片段。</span><br>glStencilFunc(GL_NOTEQUAL, <span class="hljs-number">1</span>, <span class="hljs-number">0xFF</span>);<br>glStencilMask(<span class="hljs-number">0x00</span>);<br>glDisable(GL_DEPTH_TEST);<br>shaderSingleColor.use();<br>DrawTwoScaledUpContainers();<br>glStencilMask(<span class="hljs-number">0xFF</span>);<br>glEnable(GL_DEPTH_TEST);<br></code></pre></td></tr></table></figure></li></ol></li><li><p><img src="/2018/12/23/高级OpenGL（上）/物体轮廓.jpg" alt="物体轮廓"></p></li></ul><hr><h2 id="混合-Blending"><a href="#混合-Blending" class="headerlink" title="混合(Blending)"></a>混合(Blending)</h2><ul><li>OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色。这也是混合这一名字的出处，我们混合(Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。</li></ul><h3 id="丢弃片段-discard"><a href="#丢弃片段-discard" class="headerlink" title="丢弃片段(discard)"></a>丢弃片段(discard)</h3><ul><li>在绘制物体时，有些时候，我们会希望丢弃某些片段，如alpha为0的片段。</li><li><p>GLSL给了我们discard命令，一旦被调用，它就会保证片段不会被进一步处理，所以就不会进入颜色缓冲。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#version 330 core</span><br>out vec4 FragColor;<br><br>in vec2 TexCoords;<br><br>uniform sampler2D texture1;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;             <br>    vec4 texColor = texture(texture1, TexCoords);<br>    <span class="hljs-keyword">if</span>(texColor.a &lt; <span class="hljs-number">0.1</span>)<br>        discard;<br>    FragColor = texColor;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2018/12/23/高级OpenGL（上）/discard.png" alt="使用discard去掉alpha值小于1的片段"></p></li><li>从上图可以看出，采样纹理的边缘的时候，OpenGL会对边缘的值和纹理下一个重复的值进行插值，从而造成草头上有点绿。（这是因为它的环绕方式被设置为了GL_REPEAT，将纹理的环绕方式设置为GL_CLAMP_TO_EDGE即可解决）。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br></code></pre></td></tr></table></figure></li></ul><h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><ul><li>截至上面，我们对一个片段的操作均为要么丢弃，要么渲染，并未能做到渲染多个透明度级别的图像。</li><li>OpenGL提供了glEnable(GL_BLEND)方法来启用混合，但我们需要告知OpenGL如何混合。</li></ul><h4 id="混合方程"><a href="#混合方程" class="headerlink" title="混合方程"></a>混合方程</h4><script type="math/tex; mode=display">\vec C_{result} = \vec C_{source} * \vec F_{source} + \vec C_{destination} * \vec F_{destination}</script><p>$\vec C_{source}$ ：源颜色向量，这是源自纹理的颜色向量。</p><p>$\vec C_{destination}$ ：目标颜色向量。这是当前储存在颜色缓冲中的颜色向量。</p><p>$\vec F_{destination}$ ：目标因子值，指定了alpha对目标颜色的影响。</p><p>$\vec F_{source}$ ：源因子值，指定了alpha对源颜色的影响。</p><p>$\vec C_{constant}$ ：常数颜色向量，通过glBlendColor函数来另外设置。</p><ul><li>片段着色器运行完成后，并且所有的测试都通过之后，这个混合方程(Blend Equation)才会应用到片段颜色输出与当前颜色缓冲中的值（当前片段之前储存的之前片段的颜色）上。源颜色和目标颜色将会由OpenGL自动设定，但源因子和目标因子的值可以由我们来决定。</li></ul><h4 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h4><ul><li>在混合方程中，对于OpenGL而言，因子值是不知道的，我们将通过glBlendFunc(GLenum sfactor, GLenum dfactor)来设置源和目标因子。</li></ul><div class="table-container"><table><thead><tr><th>选项</th><th>值</th></tr></thead><tbody><tr><td>GL_ZERO</td><td>因子等于0</td></tr><tr><td>GL_ONE</td><td>因子等于1</td></tr><tr><td>GL_SRC_COLOR</td><td>因子等于源颜色向量 $\vec C_{source}$</td></tr><tr><td>GL_ONE_MINUS_SRC_COLOR</td><td>因子等于1− $\vec C_{source}$</td></tr><tr><td>GL_DST_COLOR</td><td>因子等于目标颜色向量 $\vec C_{destination}$</td></tr><tr><td>GL_ONE_MINUS_DST_COLOR</td><td>因子等于1− $\vec C_{destination}$</td></tr><tr><td>GL_SRC_ALPHA</td><td>因子等于 $\vec C_{source}$ 的alpha分量</td></tr><tr><td>GL_ONE_MINUS_SRC_ALPHA</td><td>因子等于1− $\vec C_{source}$ 的alpha分量</td></tr><tr><td>GL_DST_ALPHA</td><td>因子等于 $\vec C_{destination}$ 的alpha分量</td></tr><tr><td>GL_ONE_MINUS_DST_ALPHA</td><td>因子等于1− $\vec C_{destination}$ 的alpha分量</td></tr><tr><td>GL_CONSTANT_COLOR</td><td>因子等于常数颜色向量 $\vec C_{constant}$</td></tr><tr><td>GL_ONE_MINUS_CONSTANT_COLOR</td><td>因子等于1− $\vec C_{constant}$</td></tr><tr><td>GL_CONSTANT_ALPHA</td><td>因子等于 $\vec C_{constant}$ 的alpha分量</td></tr><tr><td>GL_ONE_MINUS_CONSTANT_ALPHA</td><td>因子等于1− $\vec C_{constant}$ 的alpha分量</td></tr></tbody></table></div><ul><li>使用使用glBlendFuncSeparate为RGB和alpha通道分别设置不同的选项：<ul><li>glBlendFuncSeparate(GLenum srcRGB, GLenum destRGB, GLenum srcAlpha, GLenum destAlpha)</li></ul></li><li><p>使用glBlendEquation(GLenum mode)允许我们设置运算符，默认是相加。</p><ul><li>GL<em>FUNC_ADD：默认选项，将两个分量相加： $\vec C</em>{result}$ = Src + Dst</li><li>GL<em>FUNC_SUBTRACT：将两个分量相减： $\vec C</em>{result}$ = Src − Dst</li><li>GL<em>FUNC_REVERSE_SUBTRACT：将两个分量相减，但顺序相反： $\vec C</em>{result}$ = Dst − Src</li></ul></li><li><p>使用混合渲染半透明纹理效果：</p></li><li><img src="/2018/12/23/高级OpenGL（上）/blending_withoutsort.png" alt="使用混合渲染半透明纹理效果"></li><li>可以看到，最前面的窗口挡住了后面的一个窗口，这是由于深度测试与混合一起使用造成的问题。深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。</li><li>在不考虑旋转、缩放或者其它的变换，以及物体形状的情况下，我们通过对物体远近进行排序，逆序渲染，可以得到比较好的效果：</li><li><img src="/2018/12/23/高级OpenGL（上）/blending_withsort.png" alt="使用混合渲染半透明纹理效果"></li></ul><hr><h2 id="面剔除-Face-culling"><a href="#面剔除-Face-culling" class="headerlink" title="面剔除(Face culling)"></a>面剔除(Face culling)</h2><ul><li>对于一个被渲染的物体，我们看不见其背面部分，这部分的渲染其实是没必要的，可以通过面剔除的方法来实现这种想法。</li><li>OpenGL能够检查所有面向(Front Facing)观察者的面，并渲染它们，而丢弃那些背向(Back Facing)的面，节省我们很多的片段着色器调用（它们的开销很大！）。但我们仍要告诉OpenGL哪些面是正向面(Front Face)，哪些面是背向面(Back Face)。OpenGL使用了一个很聪明的技巧，分析顶点数据的环绕顺序(Winding Order)。</li></ul><h3 id="环绕顺序"><a href="#环绕顺序" class="headerlink" title="环绕顺序"></a>环绕顺序</h3><ul><li>当我们定义一组三角形顶点时，我们会以特定的环绕顺序来定义它们，可能是顺时针(Clockwise)的，也可能是逆时针(Counter-clockwise)的。每个三角形由3个顶点所组成，我们会从三角形中间来看，为这3个顶点设定一个环绕顺序。</li><li><img src="/2018/12/23/高级OpenGL（上）/faceculling_windingorder.png" alt="三角形顶点环绕顺序"></li><li>每组组成三角形图元的三个顶点就包含了一个环绕顺序。OpenGL在渲染图元的时候将使用这个信息来决定一个三角形是一个正向三角形还是背向三角形。默认情况下，逆时针顶点所定义的三角形将会被处理为正向三角形。</li><li>一般的，面向观察者视角所见的三角形为正向的。</li><li><img src="/2018/12/23/高级OpenGL（上）/faceculling_frontback.png" alt="三角形顶点环绕顺序"></li></ul><h3 id="面剔除"><a href="#面剔除" class="headerlink" title="面剔除"></a>面剔除</h3><ul><li>OpenGL提供glEnable(GL_CULL_FACE)方法供我们开启面剔除。</li><li>我们还可以通过glCullFace方法来修改要剔除的面的类型：<ul><li>GL_BACK：只剔除背向面。</li><li>GL_FRONT：只剔除正向面。</li><li>GL_FRONT_AND_BACK：剔除正向面和背向面。</li></ul></li><li>OpenGL也提供了glFrontFace方法，供我们设定何种环绕顺序为正向面：<ul><li>GL_CW：顺时针。</li><li>GL_CCW：逆时针。</li></ul></li><li>通过开启面剔除及设置正向面为顺时针方向，我们可以只渲染立方体背面：</li><li><img src="/2018/12/23/高级OpenGL（上）/face_culling.png" alt="面剔除效果"></li></ul><hr><h2 id="帧缓冲-Framebuffers"><a href="#帧缓冲-Framebuffers" class="headerlink" title="帧缓冲(Framebuffers)"></a>帧缓冲(Framebuffers)</h2><ul><li>用于写入颜色值的颜色缓冲、用于写入深度信息的深度缓冲和允许我们根据一些条件丢弃特定片段的模板缓冲。这些缓冲结合起来叫做帧缓冲(Framebuffer)，它被储存在内存中。OpenGL允许我们定义我们自己的帧缓冲，也就是说我们能够定义我们自己的颜色缓冲，甚至是深度缓冲和模板缓冲。</li></ul><h3 id="创建帧缓冲"><a href="#创建帧缓冲" class="headerlink" title="创建帧缓冲"></a>创建帧缓冲</h3><ul><li><p>帧缓冲的创建、使用、销毁步骤如下：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fbo;<br><span class="hljs-comment">// 创建一个帧缓冲对象(Framebuffer Object, FBO)</span><br>glGenFramebuffers(<span class="hljs-number">1</span>, &amp;fbo);<br><span class="hljs-comment">// 绑定帧缓冲</span><br>glBindFramebuffer(GL_FRAMEBUFFER, fbo);<br><span class="hljs-comment">// 附加缓冲，颜色附件等操作...</span><br>...<br><span class="hljs-comment">// 检查帧缓冲是否完整</span><br>glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE<br><span class="hljs-comment">// 再次激活默认帧缓冲</span><br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 在完成所有的帧缓冲操作之后，删除这个帧缓冲对象</span><br>glDeleteFramebuffers(<span class="hljs-number">1</span>, &amp;fbo);<br></code></pre></td></tr></table></figure></li><li><p>在创建完帧缓冲后，并不能马上进行使用，因为其是不完整的。一个完整的帧缓冲需要满足以下的条件：</p><ul><li>附加至少一个缓冲（颜色、深度或模板缓冲）。</li><li>至少有一个颜色附件(Attachment)。</li><li>所有的附件都必须是完整的（保留了内存）。</li><li>每个缓冲都应该有相同的样本数。</li></ul></li></ul><h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><h4 id="为帧缓存创建纹理"><a href="#为帧缓存创建纹理" class="headerlink" title="为帧缓存创建纹理"></a>为帧缓存创建纹理</h4><ul><li><p>当把一个纹理附加到帧缓冲的时候，所有的渲染指令将会写入到这个纹理中，就想它是一个普通的颜色/深度或模板缓冲一样。使用纹理的优点是，所有渲染操作的结果将会被储存在一个纹理图像中，我们之后可以在着色器中很方便地使用它。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> texture;<br>glGenTextures(<span class="hljs-number">1</span>, &amp;texture);<br>glBindTexture(GL_TEXTURE_2D, texture);<br><br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB, SCREEN_WIDTH, SCREEN_HEIGHT, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="hljs-literal">NULL</span>);<br><br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br></code></pre></td></tr></table></figure></li><li><p>我们将其大小设置为屏幕大小（非必要，但后面的例子中会直接使用其替换整个窗口屏幕），数据传入NULL。</p></li><li>即，我们仅创建了一片内存，并没有对其进行数据填充。填充这个纹理将会在我们渲染到帧缓冲之后来进行。同样注意我们并不关心环绕方式或多级渐远纹理，我们在大多数情况下都不会需要它们。</li><li><p>创建完纹理后，我们需要将其附加到帧缓冲上。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li><li><p>glFrameBufferTexture2D有以下的参数：</p><ul><li>target：帧缓冲的目标（绘制、读取或者两者皆有）</li><li>attachment：我们想要附加的附件类型。当前我们正在附加一个颜色附件。注意最后的0意味着我们可以附加多个颜色附件。</li><li>textarget：你希望附加的纹理类型</li><li>texture：要附加的纹理本身</li><li>level：多级渐远纹理的级别。我们将它保留为0。</li></ul></li><li><p>除了颜色附件之外，我们还可以附加一个深度和模板缓冲纹理到帧缓冲对象中。要附加深度缓冲的话，我们将附件类型设置为GL_DEPTH_ATTACHMENT。注意纹理的格式(Format)和内部格式(Internalformat)类型将变为GL_DEPTH_COMPONENT，来反映深度缓冲的储存格式。要附加模板缓冲的话，你要将第二个参数设置为GL_STENCIL_ATTACHMENT，并将纹理的格式设定为GL_STENCIL_INDEX。</p></li><li><p>也可以将深度缓冲和模板缓冲附加为一个单独的纹理。纹理的每32位数值将包含24位的深度信息和8位的模板信息。使用GL_DEPTH_STENCIL_ATTACHMENT类型，并配置纹理的格式，让它包含合并的深度和模板值。</p></li><li>将一个深度和模板缓冲附加为一个纹理到帧缓冲的例子：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">glTexImage2D(<br>  GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_DEPTH24_STENCIL8, SCREEN_WIDTH, SCREEN_HEIGHT, <span class="hljs-number">0</span>,<br>  GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, <span class="hljs-literal">NULL</span><br>);<br><br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ul><h4 id="渲染缓冲对象附件"><a href="#渲染缓冲对象附件" class="headerlink" title="渲染缓冲对象附件"></a>渲染缓冲对象附件</h4><ul><li>渲染缓冲对象(Renderbuffer Object)是在纹理之后引入到OpenGL中，作为一个可用的帧缓冲附件类型的，和纹理图像一样，渲染缓冲对象是一个真正的缓冲，即一系列的字节、整数、像素等。渲染缓冲对象附加的好处是，它会将数据储存为OpenGL原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。</li><li>渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。当然你仍然还是能够使用 <em>glReadPixels</em> 来读取它，这会从当前绑定的帧缓冲，而不是附件本身，中返回特定区域的像素。</li><li>因为它的数据已经是原生的格式了，当写入或者复制它的数据到其它缓冲中时是非常快的。所以，交换缓冲这样的操作在使用渲染缓冲对象时会非常快。我们在每个渲染迭代最后使用的glfwSwapBuffers，也可以通过渲染缓冲对象实现：只需要写入一个渲染缓冲图像，并在最后交换到另外一个渲染缓冲就可以了。渲染缓冲对象对这种操作非常完美。</li><li><p>使用渲染缓冲对象：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> rbo;<br>glGenRenderbuffers(<span class="hljs-number">1</span>, &amp;rbo);<br><span class="hljs-comment">// 绑定这个渲染缓冲对象</span><br>glBindRenderbuffer(GL_RENDERBUFFER, rbo);<br><span class="hljs-comment">// 创建一个深度和模板渲染缓冲对象</span><br>glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, SCREEN_WIDTH, SCREEN_HEIGHT);<br><span class="hljs-comment">// 附加这个渲染缓冲对象</span><br>glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);<br></code></pre></td></tr></table></figure></li><li><p>由于渲染缓冲对象通常都是只写的，它们会经常用于深度和模板附件，因为大部分时间我们都不需要从深度和模板缓冲中读取值，只关心深度和模板测试。我们需要深度和模板值用于测试，但不需要对它们进行采样，所以渲染缓冲对象非常适合它们。当我们不需要从这些缓冲中采样的时候，通常都会选择渲染缓冲对象，因为它会更优化一点。</p></li><li>渲染缓冲对象能为你的帧缓冲对象提供一些优化，但知道什么时候使用渲染缓冲对象，什么时候使用纹理是很重要的。通常的规则是，如果你不需要从一个缓冲中采样数据，那么对这个缓冲使用渲染缓冲对象会是明智的选择。如果你需要从缓冲中采样颜色或深度值等数据，那么你应该选择纹理附件。性能方面它不会产生非常大的影响的。</li></ul><h3 id="渲染到纹理"><a href="#渲染到纹理" class="headerlink" title="渲染到纹理"></a>渲染到纹理</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建一个帧缓冲对象，并绑定它</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> framebuffer;<br>glGenFramebuffers(<span class="hljs-number">1</span>, &amp;framebuffer);<br>glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);<br><br><span class="hljs-comment">// 生成纹理</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> texColorBuffer;<br>glGenTextures(<span class="hljs-number">1</span>, &amp;texColorBuffer);<br>glBindTexture(GL_TEXTURE_2D, texColorBuffer);<br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="hljs-literal">NULL</span>);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>glBindTexture(GL_TEXTURE_2D, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 将它附加到当前绑定的帧缓冲对象</span><br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, <span class="hljs-number">0</span>);  <br><br><span class="hljs-comment">// 创建渲染缓冲对象作为深度和模板附件渲染缓冲对象</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> rbo;<br>glGenRenderbuffers(<span class="hljs-number">1</span>, &amp;rbo);<br>glBindRenderbuffer(GL_RENDERBUFFER, rbo);<br>glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>);  <br>glBindRenderbuffer(GL_RENDERBUFFER, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 将渲染缓冲对象附加到帧缓冲的深度和模板附件</span><br>glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);<br><br><span class="hljs-comment">// 完整性检查</span><br><span class="hljs-keyword">if</span>(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::FRAMEBUFFER:: Framebuffer is not complete!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br><span class="hljs-comment">// 解绑帧缓冲</span><br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// render loop</span><br><span class="hljs-keyword">while</span> (!glfwWindowShouldClose(window))<br>&#123;<br>  glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);<br>  glClearColor(<span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">1.0f</span>);<br>  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="hljs-comment">// 我们现在不使用模板缓冲</span><br>  glEnable(GL_DEPTH_TEST);<br>  DrawScene();<br><br>  glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>); <span class="hljs-comment">// 返回默认缓冲</span><br>  glClearColor(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>);<br>  glClear(GL_COLOR_BUFFER_BIT);<br><br>  screenShader.use();<br>  glBindVertexArray(quadVAO);<br>  glDisable(GL_DEPTH_TEST);<br>  glBindTexture(GL_TEXTURE_2D, textureColorbuffer);<br>  glDrawArrays(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><img src="/2018/12/23/高级OpenGL（上）/framebuffers_screen_texture.png" alt="渲染帧缓冲"></li></ul><h3 id="核效果"><a href="#核效果" class="headerlink" title="核效果"></a>核效果</h3><ul><li><p>在一个纹理图像上做后期处理的另外一个好处是，我们可以从纹理的其它地方采样颜色值。比如说我们可以在当前纹理坐标的周围取一小块区域，对当前纹理值周围的多个纹理值进行采样。我们可以结合它们创建出很有意思的效果。</p></li><li><p>核(Kernel)（或卷积矩阵(Convolution Matrix)）是一个类矩阵的数值数组，它的中心为当前的像素，它会用它的核值乘以周围的像素值，并将结果相加变成一个值。所以，基本上我们是在对当前像素周围的纹理坐标添加一个小的偏移量，并根据核将结果合并。</p></li><li>通过核，我们可以实现锐化，边缘检测，模糊等效果。</li><li>下面是核的一个例子：<script type="math/tex; mode=display">\begin{bmatrix} 2 & 2 & 2 \\ 2 & -15 & 2 \\ 2 & 2 & 2 \end{bmatrix}</script></li></ul><blockquote><p>大部分核将所有的权重加起来之后都应该会等于1，如果它们加起来不等于1，这就意味着最终的纹理颜色将会比原纹理值更亮或者更暗了。</p></blockquote><ul><li><p>片段着色器实现：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> offset = <span class="hljs-number">1.0</span> / <span class="hljs-number">300.0</span>;  <br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    vec2 offsets[<span class="hljs-number">9</span>] = vec2[](<br>        vec2(-offset,  offset), <span class="hljs-comment">// 左上</span><br>        vec2( <span class="hljs-number">0.0f</span>,    offset), <span class="hljs-comment">// 正上</span><br>        vec2( offset,  offset), <span class="hljs-comment">// 右上</span><br>        vec2(-offset,  <span class="hljs-number">0.0f</span>),   <span class="hljs-comment">// 左</span><br>        vec2( <span class="hljs-number">0.0f</span>,    <span class="hljs-number">0.0f</span>),   <span class="hljs-comment">// 中</span><br>        vec2( offset,  <span class="hljs-number">0.0f</span>),   <span class="hljs-comment">// 右</span><br>        vec2(-offset, -offset), <span class="hljs-comment">// 左下</span><br>        vec2( <span class="hljs-number">0.0f</span>,   -offset), <span class="hljs-comment">// 正下</span><br>        vec2( offset, -offset)  <span class="hljs-comment">// 右下</span><br>    );<br><br>    <span class="hljs-keyword">float</span> kernel[<span class="hljs-number">9</span>] = <span class="hljs-keyword">float</span>[](<br>        <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,<br>        <span class="hljs-number">-1</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">-1</span>,<br>        <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span><br>    );<br><br>    vec3 sampleTex[<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>    &#123;<br>        sampleTex[i] = vec3(texture(screenTexture, TexCoords.st + offsets[i]));<br>    &#125;<br>    vec3 col = vec3(<span class="hljs-number">0.0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>        col += sampleTex[i] * kernel[i];<br><br>    FragColor = vec4(col, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>边缘检测的效果：</p></li><li><img src="/2018/12/23/高级OpenGL（上）/kernel.jpg" alt="边缘检测"></li></ul><hr><h2 id="立方体贴图-Cubemaps"><a href="#立方体贴图-Cubemaps" class="headerlink" title="立方体贴图(Cubemaps)"></a>立方体贴图(Cubemaps)</h2><ul><li>简单来说，立方体贴图就是一个包含了6个2D纹理的纹理，每个2D纹理都组成了立方体的一个面。</li></ul><h3 id="创建立方体贴图"><a href="#创建立方体贴图" class="headerlink" title="创建立方体贴图"></a>创建立方体贴图</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> textureID;<br>glGenTextures(<span class="hljs-number">1</span>, &amp;textureID);<br>glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);<br><br><span class="hljs-keyword">int</span> width, height, nrChannels;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *data;  <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; textures_faces.size(); i++)<br>&#123;<br>    data = stbi_load(textures_faces[i].c_str(), &amp;width, &amp;height, &amp;nrChannels, <span class="hljs-number">0</span>);<br>    glTexImage2D(<br>        GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,<br>        <span class="hljs-number">0</span>, GL_RGB, width, height, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data<br>    );<br>&#125;<br><br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br><span class="hljs-comment">//对应的是纹理的第三个维度（和位置的z一样）。我们将环绕方式设置为GL_CLAMP_TO_EDGE，</span><br><span class="hljs-comment">//这是因为正好处于两个面之间的纹理坐标可能不能击中一个面（由于一些硬件限制），</span><br><span class="hljs-comment">//所以通过使用GL_CLAMP_TO_EDGE，OpenGL将在我们对两个面之间采样的时候，永远返回它们的边界值。</span><br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);<br></code></pre></td></tr></table></figure><ul><li>因为立方体贴图包含有6个纹理，每个面一个，我们需要调用glTexImage2D函数6次，其第一个参数是纹理目标，是从GL_TEXTURE_CUBE_MAP_POSITIVE_X开始线性+1递增的枚举值：</li></ul><div class="table-container"><table><thead><tr><th>纹理目标</th><th>方位</th></tr></thead><tbody><tr><td>GL_TEXTURE_CUBE_MAP_POSITIVE_X</td><td>右</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</td><td>左</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</td><td>上</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</td><td>下</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</td><td>后</td></tr><tr><td>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</td><td>前</td></tr></tbody></table></div><ul><li><p>在绘制使用立方体贴图的物体之前，我们要先激活对应的纹理单元，并绑定立方体贴图。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glActiveTexture(GL_TEXTURE0);<br>glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTexture);<br></code></pre></td></tr></table></figure></li><li><p>在片段着色器中进行采样时，我们会使用vec3而不再是vec2，毕竟是个三维盒子，采样器也改为了samplerCube。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">in vec3 textureDir; <span class="hljs-comment">// 代表3D纹理坐标的方向向量</span><br>uniform samplerCube cubemap; <span class="hljs-comment">// 立方体贴图的纹理采样器</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;             <br>    FragColor = texture(cubemap, textureDir);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="天空盒"><a href="#天空盒" class="headerlink" title="天空盒"></a>天空盒</h3><ul><li>天空盒是一个包含了整个场景的（大）立方体，它包含周围环境的6个图像，让玩家以为他处在一个比实际大得多的环境当中。游戏中使用天空盒的例子有群山、白云或星空。</li><li><img src="/2018/12/23/高级OpenGL（上）/cubemaps_skybox.png" alt="天空盒"></li></ul><h4 id="加载天空盒"><a href="#加载天空盒" class="headerlink" title="加载天空盒"></a>加载天空盒</h4><ul><li>加载天空盒的本质是创建6个图像的纹理过程，具体代码如下：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; faces;<br>&#123;<br>    <span class="hljs-string">"right.jpg"</span>,<br>    <span class="hljs-string">"left.jpg"</span>,<br>    <span class="hljs-string">"top.jpg"</span>,<br>    <span class="hljs-string">"bottom.jpg"</span>,<br>    <span class="hljs-string">"front.jpg"</span>,<br>    <span class="hljs-string">"back.jpg"</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadCubemap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; faces)</span><br></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> textureID;<br>    glGenTextures(<span class="hljs-number">1</span>, &amp;textureID);<br>    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);<br><br>    <span class="hljs-keyword">int</span> width, height, nrChannels;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; faces.size(); i++)<br>    &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* data = stbi_load(faces[i].c_str(), &amp;width, &amp;height, &amp;nrChannels, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (data)<br>        &#123;<br>            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,<br>                         <span class="hljs-number">0</span>, GL_RGB, width, height, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data<br>            );<br>            stbi_image_free(data);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Cubemap texture failed to load at path: "</span> &lt;&lt; faces[i] &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>            stbi_image_free(data);<br>        &#125;<br>    &#125;<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);<br><br>    <span class="hljs-keyword">return</span> textureID;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="显示天空盒"><a href="#显示天空盒" class="headerlink" title="显示天空盒"></a>显示天空盒</h4><ul><li>当我们把天空盒的原点放置在(0, 0, 0)上时，它的每一个位置向量都是从原点出发的方向向量。这个方向向量正是获取立方体上特定位置的纹理值所需要的。正是因为这个，我们只需要提供位置向量而不用纹理坐标了。</li><li>绘制天空盒时，我们可以首先对其进行，并且禁用深度写入。这样子天空盒就会永远被绘制在其它物体的背后了。但是这样的处理方式带来的消耗也是明显的，整个屏幕会被绘制一遍天空盒，会存在大量overdraw的情况。</li><li>之所以先绘制天空盒，再绘制场景中的其他物体，是因为什么想要保证天空盒必然出现在任何其他物体背后，如果我们能通过某种方式，将天空盒的深度值设置为恒大于场景中的其他物体，那么便不需要优先绘制天空盒，相反，我们可以在最后绘制，只绘制其通过深度测试的部分。</li><li>透视除法是在顶点着色器运行之后执行的，将gl_Position的xyz坐标除以w分量。我们又从深度测试小节中知道，相除结果的z分量等于顶点的深度值。使用这些信息，我们可以将输出位置的z分量等于它的w分量，让z分量永远等于1.0，这样子的话，当透视除法执行之后，z分量会变为w / w = 1.0。</li><li><p>故顶点着色器的代码便是：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    TexCoords = aPos;<br>    vec4 pos = projection * view * vec4(aPos, <span class="hljs-number">1.0</span>);<br>    gl_Position = pos.xyww;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>我们还要改变一下深度函数，将它从默认的GL_LESS改为GL_LEQUAL。深度缓冲将会填充上天空盒的1.0值，所以我们需要保证天空盒在值小于或等于深度缓冲而不是小于时通过深度测试。</p></li></ul><h3 id="环境映射"><a href="#环境映射" class="headerlink" title="环境映射"></a>环境映射</h3><ul><li>使用环境立方体贴图的技术叫做环境映射(Environment Mapping)，其中最流行的两个是反射(Reflection)和折射(Refraction)。</li></ul><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ul><li>反射这个属性表现为物体（或物体的一部分）反射它周围环境，即根据观察者的视角，物体的颜色或多或少等于它的环境。镜子就是一个反射性物体：它会根据观察者的视角反射它周围的环境。</li><li><img src="/2018/12/23/高级OpenGL（上）/cubemaps_reflection_theory.png" alt="反射"></li><li><p>我们根据观察方向向量 $\vec I$ 和物体的法向量 $\vec N$ ，来计算反射向量 $\vec R$ 。我们可以使用GLSL内建的reflect函数来计算这个反射向量。最终的 $\vec R$ 向量将会作为索引/采样立方体贴图的方向向量，返回环境的颜色值。最终的结果是物体看起来反射了天空盒。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#version 330 core</span><br>out vec4 FragColor;<br><br>in vec3 Normal;<br>in vec3 Position;<br><br>uniform vec3 cameraPos;<br>uniform samplerCube skybox;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;             <br>    vec3 I = normalize(Position - cameraPos);<br>    vec3 R = reflect(I, normalize(Normal));<br>    FragColor = vec4(texture(skybox, R).rgb, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2018/12/23/高级OpenGL（上）/reflection.png" alt="反射"></p></li></ul><h4 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h4><ul><li>折射是光线由于传播介质的改变而产生的方向变化。</li><li>折射是通过<a href="https://en.wikipedia.org/wiki/Snell%27s_law" target="_blank" rel="noopener">斯涅尔定律(Snell’s Law)</a>来描述的，使用环境贴图的话看起来像是这样：</li><li><img src="/2018/12/23/高级OpenGL（上）/cubemaps_refraction_theory.png" alt="折射"></li><li>折射可以使用GLSL的内建refract函数来轻松实现，它需要一个法向量、一个观察方向和两个材质之间的折射率(Refractive Index)。</li><li>折射率决定了材质中光线弯曲的程度，每个材质都有自己的折射率。一些最常见的折射率可以在下表中找到：</li></ul><div class="table-container"><table><thead><tr><th>材质</th><th>折射率</th></tr></thead><tbody><tr><td>空气</td><td>1.00</td></tr><tr><td>水</td><td>1.33</td></tr><tr><td>冰</td><td>1.309</td></tr><tr><td>玻璃</td><td>1.52</td></tr><tr><td>钻石</td><td>2.42</td></tr></tbody></table></div><ul><li><p>假设场景中的物体为玻璃材质，则：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;             <br>    <span class="hljs-keyword">float</span> ratio = <span class="hljs-number">1.00</span> / <span class="hljs-number">1.52</span>;<br>    vec3 I = normalize(Position - cameraPos);<br>    vec3 R = refract(I, normalize(Normal), ratio);<br>    FragColor = vec4(texture(skybox, R).rgb, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2018/12/23/高级OpenGL（上）/refraction.png" alt="折射"></p></li></ul><h3 id="环境动态贴图"><a href="#环境动态贴图" class="headerlink" title="环境动态贴图"></a>环境动态贴图</h3><ul><li>前面的反射和折射均是建立在场景中只有一个物体的情况下实现的，但场景中有多个物体时，一个物体的反射/折射会受到其他物体的影响，而上面的实现只是从天空盒中进行采样，没有考虑其他物体对环境的影响。</li><li><p><img src="/2018/12/23/高级OpenGL（上）/double_man.png" alt="多个物体的反射"></p></li><li><p>通过使用帧缓冲，我们能够为物体的6个不同角度创建出场景的纹理，并在每个渲染迭代中将它们储存到一个立方体贴图中。之后我们就可以使用这个（动态生成的）立方体贴图来创建出更真实的，包含其它物体的，反射和折射表面了。这就叫做动态环境映射(Dynamic Environment Mapping)，因为我们动态创建了物体周围的立方体贴图，并将其用作环境贴图。</p></li><li><p>虽然它看起来很棒，但它有一个很大的缺点：我们需要为使用环境贴图的物体渲染场景6次，这是对程序是非常大的性能开销。现代的程序通常会尽可能使用天空盒，并在可能的时候使用预编译的立方体贴图，只要它们能产生一点动态环境贴图的效果。虽然动态环境贴图是一个很棒的技术，但是要想在不降低性能的情况下让它工作还是需要非常多的技巧的。</p></li><li><p>尚未进行实现。。。。</p></li></ul><h3 id="使用漫反射贴图-反射贴图的效果"><a href="#使用漫反射贴图-反射贴图的效果" class="headerlink" title="使用漫反射贴图+反射贴图的效果"></a>使用漫反射贴图+反射贴图的效果</h3><ul><li><img src="/2018/12/23/高级OpenGL（上）/combine.png" alt=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 高级OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>模型加载</title>
      <link href="/2018/12/10/%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD/"/>
      <url>/2018/12/10/%E6%A8%A1%E5%9E%8B%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 模型加载学习笔记</p><p>Assimp，网格，模型。</p></blockquote><a id="more"></a><h2 id="模型加载"><a href="#模型加载" class="headerlink" title="模型加载"></a>模型加载</h2><ul><li>利用Assimp库，将3D艺术家利用3D建模工具生成的3D模型载入到程序中，转换为我们所熟知的通用数据结构，再将这些数据结构转换为我们代码中自定义的数据结构，然后传给OpenGL，让其能正确渲染出来的过程。</li></ul><h2 id="Assimp"><a href="#Assimp" class="headerlink" title="Assimp"></a>Assimp</h2><ul><li>3D艺术家们可能会用多种3D建模工具（如Blender，3DS Max，Maya）来构建3D模型，<em>Assimp</em> 能够导入很多种不同的模型文件格式（并也能够导出部分的格式），它会将所有的模型数据加载至Assimp的通用数据结构中。当Assimp加载完模型之后，我们就能够从Assimp的数据结构中提取我们所需的所有数据了。由于Assimp的数据结构保持不变，不论导入的是什么种类的文件格式，它都能够将我们从这些不同的文件格式中抽象出来，用同一种方式访问我们需要的数据。</li><li>Wavefront的模型格式：<figure class="hljs highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs undefined">格式均以标识字符串开头，后面紧接着数据。<br># List of geometric vertices, with (x, y, z [,w]) coordinates, w is optional and defaults to 1.0.<br>v 0.123 0.234 0.345 1.0<br>v ...<br>...<br># List of texture coordinates, in (u, v [,w]) coordinates, these will vary between 0 and 1, w is optional and defaults to 0.<br>vt 0.500 1 [0]<br>vt ...<br>...<br># List of vertex normals in (x,y,z) form; normals might not be unit vectors.<br>vn 0.707 0.000 0.707<br>vn ...<br>...<br># Parameter space vertices in ( u [,v] [,w] ) form; free form geometry statement ( see below )<br>vp 0.310000 3.210000 2.100000<br>vp ...<br>...<br># Polygonal face element (see below)<br># Vertex indices/Vertex texture coordinate indices/Vertex normal indices<br># f v1/vt1/vn1<br>f 1 2 3<br>f 3/1 4/2 5/3<br>f 6/4/1 3/5/3 7/6/5<br>f 7//1 8//2 9//3<br>f ...<br>...<br># Line element (see below)<br>l 5 8 1 2 4 9<br></code></pre></td></tr></table></figure></li></ul><p><img src="/2018/12/10/模型加载/assimp_structure.png" alt="Assimp数据结构（简化）"></p><ul><li>和材质和网格(Mesh)一样，所有的场景/模型数据都包含在Scene对象中。Scene对象也包含了场景根节点的引用。</li><li>场景的Root node（根节点）可能包含子节点（和其它的节点一样），它会有一系列指向场景对象中mMeshes数组中储存的网格数据的索引。Scene下的mMeshes数组储存了真正的Mesh对象，节点中的mMeshes数组保存的只是场景中网格数组的索引。</li><li>一个Mesh对象本身包含了渲染所需要的所有相关数据，像是顶点位置、法向量、纹理坐标、面(Face)和物体的材质。</li><li>一个网格包含了多个面。Face代表的是物体的渲染图元(Primitive)（三角形、方形、点）。一个面包含了组成图元的顶点的索引。由于顶点和索引是分开的，使用一个索引缓冲来渲染是非常简单的。</li><li>最后，一个网格也包含了一个Material对象，它包含了一些函数能让我们获取物体的材质属性，比如说颜色和纹理贴图（比如漫反射和镜面光贴图）。</li></ul><h2 id="网格-Mesh"><a href="#网格-Mesh" class="headerlink" title="网格(Mesh )"></a>网格(Mesh )</h2><ul><li>当使用建模工具对物体建模的时候，艺术家通常不会用单个形状创建出整个模型。通常每个模型都由几个子模型/形状组合而成。组合模型的每个单独的形状就叫做一个网格(Mesh)。比如说有一个人形的角色：艺术家通常会将头部、四肢、衣服、武器建模为分开的组件，并将这些网格组合而成的结果表现为最终的模型。一个网格是我们在OpenGL中绘制物体所需的最小单位（顶点数据、索引和材质属性）。一个模型（通常）会包括多个网格。</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>通过网格需要能渲染出物体，故网格所需的数据有：<ol><li>位置向量。</li><li>法向量。</li><li>纹理坐标向量。</li><li>用于索引绘制的索引。</li><li>纹理形式的材质数据（漫反射/镜面光贴图）。</li></ol></li><li><p>故，一个网格类将会是这样的结构：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mesh</span> &#123;</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// 网格数据</span><br>        <span class="hljs-built_in">vector</span>&lt;vec3&gt; Position;<br>        <span class="hljs-built_in">vector</span>&lt;vec3&gt; Normal;<br>        <span class="hljs-built_in">vector</span>&lt;vec2&gt; TexCoords;<br>        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; indices;<br>        <span class="hljs-built_in">vector</span>&lt;Texture&gt; textures;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>将位置向量，法向量，纹理坐标向量合并为顶点结构体，纹理则需要存储纹理id及类型（漫反射贴图、镜面反射贴图）：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vertex</span> &#123;</span><br>    glm::vec3 Position;<br>    glm::vec3 Normal;<br>    glm::vec2 TexCoords;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Texture</span> &#123;</span><br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-built_in">string</span> type;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li><p>通过网格的数据结构，其初始化便是需要传入其所需数据，于是其构造函数便是：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">Mesh(<span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; indices, <span class="hljs-built_in">vector</span>&lt;Texture&gt; textures)<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;vertices = vertices;<br>    <span class="hljs-keyword">this</span>-&gt;indices = indices;<br>    <span class="hljs-keyword">this</span>-&gt;textures = textures;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>紧随着传入所需数据，我们需要将数据告知OpenGL如何解析，即我们需要配置缓冲及顶点着色器的布局。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c">Mesh(<span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; indices, <span class="hljs-built_in">vector</span>&lt;Texture&gt; textures)<br>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;vertices = vertices;<br>    <span class="hljs-keyword">this</span>-&gt;indices = indices;<br>    <span class="hljs-keyword">this</span>-&gt;textures = textures;<br><br>    setupMesh();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setupMesh</span><span class="hljs-params">()</span><br></span>&#123;<br>    glGenVertexArrays(<span class="hljs-number">1</span>, &amp;VAO);<br>    glGenBuffers(<span class="hljs-number">1</span>, &amp;VBO);<br>    glGenBuffers(<span class="hljs-number">1</span>, &amp;EBO);<br><br>    glBindVertexArray(VAO);<br>    glBindBuffer(GL_ARRAY_BUFFER, VBO);<br><br>    glBufferData(GL_ARRAY_BUFFER, vertices.size() * <span class="hljs-keyword">sizeof</span>(Vertex), &amp;vertices[<span class="hljs-number">0</span>], GL_STATIC_DRAW);  <br><br>    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);<br>    glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>),<br>                 &amp;indices[<span class="hljs-number">0</span>], GL_STATIC_DRAW);<br><br>    <span class="hljs-comment">// 顶点位置</span><br>    glEnableVertexAttribArray(<span class="hljs-number">0</span>);   <br>    glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword">sizeof</span>(Vertex), (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 顶点法线</span><br>    glEnableVertexAttribArray(<span class="hljs-number">1</span>);   <br>    glVertexAttribPointer(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword">sizeof</span>(Vertex), (<span class="hljs-keyword">void</span>*)offsetof(Vertex, Normal));<br>    <span class="hljs-comment">// 顶点纹理坐标</span><br>    glEnableVertexAttribArray(<span class="hljs-number">2</span>);   <br>    glVertexAttribPointer(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-keyword">sizeof</span>(Vertex), (<span class="hljs-keyword">void</span>*)offsetof(Vertex, TexCoords));<br><br>    glBindVertexArray(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><ul><li><p>通过规范命名的方式，即如每个漫反射纹理被命名为 <em>texture_diffuseN</em>，每个镜面光纹理应该被命名为 <em>texture_specularN</em>，其中N的范围是1到纹理采样器最大允许的数字。比如说我们对某一个网格有3个漫反射纹理，2个镜面光纹理，它们的纹理采样器应该之后会被调用：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">uniform sampler2D texture_diffuse1;<br>uniform sampler2D texture_diffuse2;<br>uniform sampler2D texture_diffuse3;<br>uniform sampler2D texture_specular1;<br>uniform sampler2D texture_specular2;<br></code></pre></td></tr></table></figure></li><li><p>进行纹理绑定之后，我们只需要调用glDrawElements即可进行绘制。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span><span class="hljs-params">(Shader shader)</span><br></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> diffuseNr = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> specularNr = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; textures.size(); i++)<br>    &#123;<br>        glActiveTexture(GL_TEXTURE0 + i); <span class="hljs-comment">// 在绑定之前激活相应的纹理单元</span><br>        <span class="hljs-comment">// 获取纹理序号（diffuse_textureN 中的 N）</span><br>        <span class="hljs-built_in">string</span> number;<br>        <span class="hljs-built_in">string</span> name = textures[i].type;<br>        <span class="hljs-keyword">if</span>(name == <span class="hljs-string">"texture_diffuse"</span>)<br>            number = <span class="hljs-built_in">std</span>::to_string(diffuseNr++);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(name == <span class="hljs-string">"texture_specular"</span>)<br>            number = <span class="hljs-built_in">std</span>::to_string(specularNr++);<br><br>        shader.setInt((name + number).c_str(), i);<br>        glBindTexture(GL_TEXTURE_2D, textures[i].id);<br>    &#125;<br>    glActiveTexture(GL_TEXTURE0);<br><br>    <span class="hljs-comment">// 绘制网格</span><br>    glBindVertexArray(VAO);<br>    glDrawElements(GL_TRIANGLES, indices.size(), GL_UNSIGNED_INT, <span class="hljs-number">0</span>);<br>    glBindVertexArray(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="模型-model"><a href="#模型-model" class="headerlink" title="模型(model)"></a>模型(model)</h2><ul><li>一个模型包含多个网格，通过对模型中所有网格的绘制，从而将模型整体展现出来。</li></ul><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>一个模型包含多个网格。</li><li>一般而言，网格中的纹理贴图等文件均为相对于模型路径的相对路径。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span><br>&#123;</span><br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">//  模型数据</span><br>        <span class="hljs-built_in">vector</span>&lt;Mesh&gt; meshes;<br>        <span class="hljs-built_in">string</span> directory;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><ul><li>通过指定的模型路径对模型进行加载。</li><li>在模型载入中，由于Assimp数据结构是树形结构，故需要一个递归便利node的函数。</li><li>需要一个将Assimp中的Mesh数据解析成我们程序中的Mesh结构体的方法。</li><li><p>于是Model类变为：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Model</span><br>&#123;</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">//  函数</span><br>        Model(<span class="hljs-keyword">char</span>* path)<br>        &#123;<br>            loadModel(path);<br>        &#125;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-comment">//  模型数据</span><br>        <span class="hljs-built_in">vector</span>&lt;Mesh&gt; meshes;<br>        <span class="hljs-built_in">string</span> directory;<br>        <span class="hljs-comment">//  函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadModel</span><span class="hljs-params">(<span class="hljs-built_in">string</span> path)</span></span>;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processNode</span><span class="hljs-params">(aiNode* node, <span class="hljs-keyword">const</span> aiScene* scene)</span></span>;<br>        <span class="hljs-function">Mesh <span class="hljs-title">processMesh</span><span class="hljs-params">(aiMesh* mesh, <span class="hljs-keyword">const</span> aiScene* scene)</span></span>;<br>        <span class="hljs-comment">// 方便材质处理</span><br>        <span class="hljs-built_in">vector</span>&lt;Texture&gt; loadMaterialTextures(aiMaterial* mat, aiTextureType type, <span class="hljs-built_in">string</span> typeName);<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>loadModel方法对指定路径的文件进行加载，然后调用递归遍历Node的方法。</p></li><li><p>将Assimp网格数据转换为网格结构体也可以在此函数中通过遍历所有Assimp数据然后生成meshes。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadModel</span><span class="hljs-params">(<span class="hljs-built_in">string</span> path)</span><br></span>&#123;<br>    Assimp::Importer <span class="hljs-keyword">import</span>;<br>    <span class="hljs-keyword">const</span> aiScene* scene = <span class="hljs-keyword">import</span>.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs);    <br><br>    <span class="hljs-keyword">if</span>(!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode)<br>    &#123;<br>        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::ASSIMP::"</span> &lt;&lt; <span class="hljs-keyword">import</span>.GetErrorString() &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    directory = path.substr(<span class="hljs-number">0</span>, path.find_last_of(<span class="hljs-string">'/'</span>));<br><br>    processNode(scene-&gt;mRootNode, scene);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>processNode方法先遍历所有网格索引以生成网格数据，再遍历子Node。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">processNode</span><span class="hljs-params">(aiNode* node, <span class="hljs-keyword">const</span> aiScene* scene)</span><br></span>&#123;<br>    <span class="hljs-comment">// 处理节点所有的网格（如果有的话）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;mNumMeshes; i++)<br>    &#123;<br>        aiMesh* mesh = scene-&gt;mMeshes[node-&gt;mMeshes[i]];<br>        meshes.push_back(processMesh(mesh, scene));         <br>    &#125;<br>    <span class="hljs-comment">// 接下来对它的子节点重复这一过程</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; node-&gt;mNumChildren; i++)<br>    &#123;<br>        processNode(node-&gt;mChildren[i], scene);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>processMesh将mesh-&gt;mNumVertices转换成顶点数据，mesh0&gt;mNumFaces转换成顶点索引使用数据，最后再通过GetTextureCount方法获取每种具体材质的数量来生成具体材质。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function">Mesh <span class="hljs-title">processMesh</span><span class="hljs-params">(aiMesh *mesh, <span class="hljs-keyword">const</span> aiScene *scene)</span><br></span>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;Vertex&gt; vertices;<br>    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>&gt; indices;<br>    <span class="hljs-built_in">vector</span>&lt;Texture&gt; textures;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mesh-&gt;mNumVertices; i++)<br>    &#123;<br>        Vertex vertex;<br>        <span class="hljs-comment">// 处理顶点位置、法线和纹理坐标</span><br>        glm::vec3 <span class="hljs-built_in">vector</span>;<br>        <span class="hljs-built_in">vector</span>.x = mesh-&gt;mVertices[i].x;<br>        <span class="hljs-built_in">vector</span>.y = mesh-&gt;mVertices[i].y;<br>        <span class="hljs-built_in">vector</span>.z = mesh-&gt;mVertices[i].z;<br>        vertex.Position = <span class="hljs-built_in">vector</span>;<br>        ...<br>        vertices.push_back(vertex);<br>    &#125;<br><br>    <span class="hljs-comment">// faces 处理索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mesh-&gt;mNumFaces; ++i) &#123;<br>        aiFace face = mesh-&gt;mFaces[i];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; face.mNumIndices; ++j) &#123;<br>          indices.push_back(face.mIndices[j]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// materials 处理材质</span><br>    <span class="hljs-keyword">if</span> (mesh-&gt;mMaterialIndex &gt;= <span class="hljs-number">0</span>) &#123;<br>        aiMaterial* material = scene-&gt;mMaterials[mesh-&gt;mMaterialIndex];<br>        <span class="hljs-built_in">vector</span>&lt;Texture&gt; diffuseMaps = loadMaterialTextures(material, aiTextureType_DIFFUSE, <span class="hljs-string">"texture_diffuse"</span>);<br>        textures.insert(textures.end(), diffuseMaps.begin(), diffuseMaps.end());<br>        <span class="hljs-built_in">vector</span>&lt;Texture&gt; specularMaps = loadMaterialTextures(material, aiTextureType_SPECULAR, <span class="hljs-string">"texture_specular"</span>);<br>        textures.insert(textures.end(), specularMaps.begin(), specularMaps.end());<br>        <span class="hljs-comment">// 3. normal maps</span><br>        <span class="hljs-comment">//std::vector&lt;Texture&gt; normalMaps = loadMaterialTextures(material, aiTextureType_HEIGHT, "texture_normal");</span><br>        <span class="hljs-comment">//textures.insert(textures.end(), normalMaps.begin(), normalMaps.end());</span><br>        <span class="hljs-comment">// 4. height maps</span><br>        <span class="hljs-comment">//std::vector&lt;Texture&gt; heightMaps = loadMaterialTextures(material, aiTextureType_AMBIENT, "texture_height");</span><br>        <span class="hljs-comment">//textures.insert(textures.end(), heightMaps.begin(), heightMaps.end());</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> Mesh(vertices, indices, textures);<br>&#125;<br><br><span class="hljs-built_in">vector</span>&lt;Texture&gt; loadMaterialTextures(aiMaterial *mat, aiTextureType type, <span class="hljs-built_in">string</span> typeName)<br>&#123;<br>    <span class="hljs-built_in">vector</span>&lt;Texture&gt; textures;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; mat-&gt;GetTextureCount(type); i++)<br>    &#123;<br>        aiString str;<br>        mat-&gt;GetTexture(type, i, &amp;str);<br>        Texture texture;<br>        texture.id = TextureFromFile(str.C_Str(), directory);<br>        texture.type = typeName;<br>        texture.path = str;<br>        textures.push_back(texture);<br>    &#125;<br>    <span class="hljs-keyword">return</span> textures;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ul><li>Assimp加载模型加入聚光后的效果。</li><li><img src="/2018/12/10/模型加载/效果图.png" alt="Assimp加载模型效果图"></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 模型加载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>光照</title>
      <link href="/2018/12/08/%E5%85%89%E7%85%A7/"/>
      <url>/2018/12/08/%E5%85%89%E7%85%A7/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 光照学习笔记</p><p>颜色、基础光照、材质、光照贴图、投光物体、多光源。</p></blockquote><a id="more"></a><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ul><li><p>颜色，即物体不要的颜色，即光照于其上，不被吸收的剩余部分，一般用三维向量来表示物体从一个光源反射各个颜色分量的大小，通过点乘容易得出物体被通过光反射后的颜色。</p><blockquote><p>如红光照射于物品上，其上红色被过滤了一半：<br>$dot(lightColor(1.0f, 0.0f, 0.0f),itemColor(0.5f, 0.5f, 0.31f))$<br>= $resultColor(0.5f, 0.0f, 0.0f)$</p><p>所以，光照显示的颜色最朴素的表示便是光照颜色点乘物品颜色。</p></blockquote></li></ul><hr><h2 id="基础光照"><a href="#基础光照" class="headerlink" title="基础光照"></a>基础光照</h2><h3 id="冯氏光照模型-Phong-Lighting-Model"><a href="#冯氏光照模型-Phong-Lighting-Model" class="headerlink" title="冯氏光照模型(Phong Lighting Model)"></a>冯氏光照模型(Phong Lighting Model)</h3><ul><li><p>物品由三部分光照分量组成，分别为：</p><ol><li>环境光(Ambient)<ul><li>即使在很黑暗的情况下，依稀有的一点点光亮，宛如黑夜中摸黑看见物体的轮廓。</li></ul></li><li>漫反射光(Diffuse)<ul><li>用于模拟方向性影响(Directional Imapct)，即越被光照到的地方（越是正对着光照）会越清晰。</li></ul></li><li>镜面光(Specular)<ul><li>就像杯子上的釉质，当光照射的时候会形成反光亮点，该亮点更倾向于光的颜色。即如黑色杯子反射出白色的反光亮点。</li></ul></li></ol><p><img src="/2018/12/08/光照/basic_lighting_phong.png" alt="冯氏光照模型"></p></li></ul><h3 id="环境光照"><a href="#环境光照" class="headerlink" title="环境光照"></a>环境光照</h3><ul><li>我们所处的世界不止一个光源，所看见的物品的颜色也不是由一个光源产生的结果，且物品会反射光照，从而对其他物品造成间接影响。考虑到这种情况的算法叫做<strong>全局光照</strong>，这种算法开销很大，而环境光照则是一种简化版，用一个很小的常量（光照）颜色，添加到物体片段的最终颜色中，这样子的话即便场景中没有直接的光源也能看起来存在有一些发散的光。</li></ul><h3 id="漫反射光照"><a href="#漫反射光照" class="headerlink" title="漫反射光照"></a>漫反射光照</h3><p>  <img src="/2018/12/08/光照/diffuse_light.png" alt=""></p><ul><li>法向量(Normal Vector)：垂直于片段表面的向量，一般会将之单位化，通过叉乘得出顶点的法向量。</li><li>定向的光线：作为光源的位置与片段的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和片段的位置向量。</li><li>通过法向量与定向的光线，我们容易通过余弦定理计算出其夹角，两者夹角越大，光照对其产生的漫反射影响越小。在实践中，我们通过计算两者单位化后的余弦值来替代夹角以减少运算量。至于其能替代的原因，一方面因为两者正相关，另外一方面，我认为是余弦函数的表现与实际情况更相符，显示中在夹角趋于90度时，物体反射光照不是线性减弱，其趋于0度时亦然。</li><li>注意：<ol><li>片段着色器里的计算都是在世界空间坐标中进行的。所以，法向量也需要转换为世界空间坐标。</li><li>法向量不代表空间中的特定位置，没有齐次坐标（顶点位置中的w分量），即位移不应该影响到法向量。如果我们打算把法向量乘以一个模型矩阵，我们就要从矩阵中移除位移部分，只选用模型矩阵左上角3×3的矩阵（注意，我们也可以把法向量的w分量设置为0，再乘以4×4矩阵；这同样可以移除位移，目前的学习中采用此种方式）。对于法向量，我们只希望对它实施缩放和旋转变换。</li><li>如果模型矩阵执行了不等比缩放，顶点的改变会导致法向量不再垂直于表面了。因此，我们不能用这样的模型矩阵来变换法向量。\<br><img src="/2018/12/08/光照/normalvec.png" alt="缩放前后向量"></li><li>我们通过<strong>法线矩阵</strong>来解决不等比缩放问题，在顶点着色器中，我们可以通过下面的方式来计算获得法线矩阵。（对于着色器来说，逆矩阵也是一个开销比较大的运算，因此，只要可能就应该避免在着色器中进行逆矩阵运算，它们必须为你场景中的每个顶点都进行这样的处理。在绘制之前你最好用CPU计算出法线矩阵，然后通过uniform把值传递给着色器（像模型矩阵一样）。）\<br>mat3(transpose(inverse(model)))</li><li>法线矩阵推导（利用缩放前后均垂直于切线的特性证明。）（参考<a href="http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix" target="_blank" rel="noopener">http://www.lighthouse3d.com/tutorials/glsl-12-tutorial/the-normal-matrix</a>）：<script type="math/tex; mode=display">T = P_{2} - P_{1}</script><script type="math/tex; mode=display">T * Modelview = (P_{2} - P_{1}) * Modelview</script><script type="math/tex; mode=display">T * Modelview = P_{2} * Modelview - P_{1} * Modelview</script><script type="math/tex; mode=display">T^{'} = P_{2}^{'} - P_{1}^{'}</script><script type="math/tex; mode=display">N = Q_{2} - Q_{1}</script><script type="math/tex; mode=display">设G为缩放后正确的3X3矩阵，M为模型矩阵左上角的3X3部分。</script><script type="math/tex; mode=display">N^{'}·T^{'} = (GN)·(MT) = 0</script><script type="math/tex; mode=display">(GN)·(MT) = (GN)^{T} * (MT)</script><script type="math/tex; mode=display">(GN)^{T} * (MT) = N^{T}G^{T}MT</script><script type="math/tex; mode=display">假设G^{T}M = I，那么上式变为N^{T}T</script><script type="math/tex; mode=display">于是有N^{'}·T^{'} = N·T = 0</script><script type="math/tex; mode=display">于是得出G</script><script type="math/tex; mode=display">G^{T}M = I \Longrightarrow G = (M^{-1})^{T}</script><script type="math/tex; mode=display">模型矩阵左上角的逆矩阵的转置矩阵</script></li></ol></li></ul><h3 id="镜面光照"><a href="#镜面光照" class="headerlink" title="镜面光照"></a>镜面光照</h3><p>  <img src="/2018/12/08/光照/basic_lighting_specular_theory.png" alt=""></p><ul><li>通过反射法向量周围光的方向来计算反射向量。然后我们计算反射向量和视线方向的角度差，如果夹角越小，那么镜面光的影响就会越大。它的作用效果就是，当我们去看光被物体所反射的那个方向的时候，我们会看到一个高光。</li><li>观察向量：通过观察者在世界空间位置和片段的位置来计算获得。（若希望在观察空间进行光照计算，所有相关的向量都要用观察矩阵进行变换，法线矩阵也需要进行变换。在观察空间进行光照计算的好处是观察者的位置总是(0, 0, 0)，所以这样你直接就获得了观察者位置。）</li><li>反射向量：与入射向量关于法向量成镜像但方向相反，在片段着色器中，我们可以通过reflect函数求得反射向量。reflect要求第一个向量是从光源指向片段位置的向量。vec3 reflectDir = reflect(-lightDir, norm)</li><li>反光度(Shininess)：一个物体的反光度越高，反射光的能力越强，散射得越少，高光点就会越小。\<br><img src="/2018/12/08/光照/basic_lighting_specular_shininess.png" alt=""></li><li>镜面分量计算：<br>$float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);$</li></ul><h3 id="Gouraud着色-Gouraud-Shading"><a href="#Gouraud着色-Gouraud-Shading" class="headerlink" title="Gouraud着色(Gouraud Shading)"></a>Gouraud着色(Gouraud Shading)</h3><ul><li>在光照着色器的早期，开发者曾经在顶点着色器中实现冯氏光照模型。在顶点着色器中做光照的优势是，相比片段来说，顶点要少得多，因此会更高效，所以（开销大的）光照计算频率会更低。然而，顶点着色器中的最终颜色值是仅仅只是那个顶点的颜色值，片段的颜色值是由插值光照颜色所得来的。结果就是这种光照看起来不会非常真实，除非使用了大量顶点。</li><li>目前在雾气的实现中有使用到Gouraud着色。\<br><img src="/2018/12/08/光照/basic_lighting_gouruad.png" alt=""></li></ul><hr><h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><ul><li><p>在现实世界里，每个物体会对光产生不同的反应。</p><blockquote><p>比如说，钢看起来通常会比陶瓷花瓶更闪闪发光，木头箱子也不会像钢制箱子那样对光产生很强的反射。每个物体对镜面高光也有不同的反应。有些物体反射光的时候不会有太多的散射(Scatter)，因而产生一个较小的高光点，而有些物体则会散射很多，产生一个有着更大半径的高光点。如果我们想要在OpenGL中模拟多种类型的物体，我们必须为每个物体分别定义一个材质(Material)属性。</p></blockquote></li><li><p>利用冯氏光照模型，我们通过对物体环境光照(Ambient Lighting)、漫反射光照(Diffuse Lighting)和镜面光照(Specular Lighting)分别指定一个颜色，再加上反光度(Shininess)来得到物体的材质属性。环境光和漫反射分量一般设置成我们想要让物体所拥有的颜色，镜面分量则设置为RGB相等的值。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Material</span> &#123;</span><br>    vec3 ambient;<br>    vec3 diffuse;<br>    vec3 specular;<br>    <span class="hljs-keyword">float</span> shininess;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>对于光，我们也可以定义光照属性，单独设置光照对物体环境光照(Ambient Lighting)、漫反射光照(Diffuse Lighting)和镜面光照(Specular Lighting)的影响值。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Light</span> &#123;</span><br>    vec3 position;<br><br>    vec3 ambient;<br>    vec3 diffuse;<br>    vec3 specular;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>通过光照属性和材质属性的配合，我们能得到更好视觉效果：</p><figure class="hljs highlight C"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">vec3 ambient  = light.ambient * material.ambient;<br>vec3 diffuse  = light.diffuse * (diff * material.diffuse);<br>vec3 specular = light.specular * (spec * material.specular);<br></code></pre></td></tr></table></figure><ul><li><img src="/2018/12/08/光照/materials.png" alt=""></li></ul></li></ul><hr><h2 id="光照贴图"><a href="#光照贴图" class="headerlink" title="光照贴图"></a>光照贴图</h2><ul><li>仅有材质属性是不够的，世界上大多数物体不是一个纯净物状态的整体，如杯子外壁是黑色高反光而内壁则为白色反光性较低。</li></ul><h3 id="漫反射贴图-Diffuse-Map"><a href="#漫反射贴图-Diffuse-Map" class="headerlink" title="漫反射贴图(Diffuse Map)"></a>漫反射贴图(Diffuse Map)</h3><ul><li>与纹理用于获取片段在物体具体位置上的颜色相似，在光照场景中，我们用相同的方式来获取其漫反射颜色，这种纹理被叫做漫反射贴图。</li></ul><h3 id="镜面光贴图-Specular-Map"><a href="#镜面光贴图-Specular-Map" class="headerlink" title="镜面光贴图(Specular Map)"></a>镜面光贴图(Specular Map)</h3><ul><li>与漫反射贴图相同，对于镜面光我们也需要从纹理中采集，便有了镜面光贴图。</li><li>从现实角度来说，镜面高光的颜色大部分（甚至全部）都是由光源本身所决定的，所以这样并不能生成非常真实的视觉效果（这也是为什么图像通常是黑白的，我们只关心强度）。</li><li><p>增加了漫反射贴图和镜面反射贴图后，材质的数据结构改为：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Material</span> &#123;</span><br>    sampler2D diffuse;<br>    sampler2D specular;<br>    <span class="hljs-keyword">float</span>     shininess;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>片段着色器中代码改为：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));<br>vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));  <br>vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));<br>FragColor = vec4(ambient + diffuse + specular, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="放射光贴图-Emission-Map"><a href="#放射光贴图-Emission-Map" class="headerlink" title="放射光贴图(Emission Map)"></a>放射光贴图(Emission Map)</h3><ul><li><p>对于想让物体自发光的情况，如黑暗房间中看见一个发光的箱子等，可以通过放射光贴图实现。在片段着色器生成最终颜色时加上采样放射光贴图上的颜色，以达到忽略光照条件进行发光的效果。</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">vec3 result = ambient  + diffuse + specular + vec3(texture(material.emission, TexCoord));<br></code></pre></td></tr></table></figure></li><li><p><img src="/2018/12/08/光照/lightingmaps.png" alt=""></p></li></ul><hr><h2 id="投光物-Light-Caster"><a href="#投光物-Light-Caster" class="headerlink" title="投光物(Light Caster)"></a>投光物(Light Caster)</h2><ul><li>将光投射(Cast)到物体的光源叫做投光物(Light Caster)。</li></ul><h3 id="定向光-Directional-Light"><a href="#定向光-Directional-Light" class="headerlink" title="定向光(Directional Light)"></a>定向光(Directional Light)</h3><ul><li>当我们使用一个假设光源处于无限远处的模型时，它就被称为定向光，因为它的所有光线都有着相同的方向，它与光源的位置是没有关系的。太阳便是定向光的一个好例子。</li><li><img src="/2018/12/08/光照/light_casters_directional.png" alt=""></li><li>定向光的特点：<ul><li>光源位置对定向光无影响。</li><li>光的方向恒定且平行。</li><li>光照强度不会衰减。</li></ul></li><li><p>由于光源的位置对定向光没有影响，而光照方向恒定且平行，所以对于定向光的数据结构为：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Light</span> &#123;</span><br>    <span class="hljs-comment">// vec3 position; // 使用定向光就不再需要了</span><br>    vec3 direction;  <span class="hljs-comment">// 光射出的方向</span><br><br>    vec3 ambient;<br>    vec3 diffuse;<br>    vec3 specular;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2018/12/08/光照/dir_light.png" alt=""></p></li></ul><h3 id="点光源-Point-Light"><a href="#点光源-Point-Light" class="headerlink" title="点光源(Point Light)"></a>点光源(Point Light)</h3><ul><li>如同现实世界的白炽灯一般，点光源的光从一点发出，发向所有方向，光线随距离增加而衰减。</li><li><img src="/2018/12/08/光照/light_casters_point.png" alt=""></li><li>点光源的特点：<ul><li>光源位置对点光源有影响。</li><li>光从一点发出，发向所有方向。</li><li>光照强度会衰减。</li></ul></li></ul><h3 id="衰减"><a href="#衰减" class="headerlink" title="衰减"></a>衰减</h3><ul><li>随着光线传播距离的增长逐渐削减光的强度通常叫做衰减(Attenuation)。</li><li>衰减方程：<script type="math/tex; mode=display">F_{att} = \frac{1.0}{K_{c} + K_{l} * d + K_{q} * d^2}</script></li><li><p>光照衰减方程的理解：</p><ol><li>为符合先衰减得快，再衰减得慢，所以是距离倒数($\frac{1.0}{d}$)的形式。</li><li>为保证衰减值恒小于等于1，加入常数项 $K_{c}$ 。</li><li>为了加快远距离光的衰减，加入二次项 $K_{q} * d^2$ 。</li></ol></li><li><p>于是对于点光源的结构体便是：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Light</span> &#123;</span><br>    vec3 position;  <br><br>    vec3 ambient;<br>    vec3 diffuse;<br>    vec3 specular;<br><br>    <span class="hljs-keyword">float</span> constant;<br>    <span class="hljs-keyword">float</span> linear;<br>    <span class="hljs-keyword">float</span> quadratic;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2018/12/08/光照/point_light.png" alt=""></p></li></ul><h3 id="聚光-Spotlight"><a href="#聚光-Spotlight" class="headerlink" title="聚光(Spotlight)"></a>聚光(Spotlight)</h3><ul><li>只朝特定方向而不是所有方向发射光线，如现实世界中的手电筒。</li><li>OpenGL中聚光是用一个世界空间位置、一个方向和一个切光角(Cutoff Angle)来表示的，切光角指定了聚光的半径。对于每个片段，我们会计算片段是否位于聚光的切光方向之间（也就是在锥形内），如果是的话，我们就会相应地照亮片段。</li><li><img src="/2018/12/08/光照/light_casters_spotlight_angles.png" alt=""></li><li>LightDir：从片段指向光源的向量。</li><li>SpotDir：聚光所指向的方向。</li><li>Phiϕ：指定了聚光半径的切光角。落在这个角度之外的物体都不会被这个聚光所照亮。</li><li>Thetaθ：LightDir向量和SpotDir向量之间的夹角。在聚光内部的话θ值应该比ϕ值小。</li><li>在实际运算中，我们用LightDir和SpotDir的点积与切光角ϕ的余弦值比较大小来替代角度大小比较，以减少计算量。</li></ul><h3 id="平滑边缘"><a href="#平滑边缘" class="headerlink" title="平滑边缘"></a>平滑边缘</h3><ul><li>用上面的方式创造出来的聚光的边缘界限会很明显，与现实不相符。</li><li><img src="/2018/12/08/光照/spot_light1.png" alt=""></li><li>通过设置内圆锥(Inner Cone)和外圆锥(Outer Cone)的方式，对于落在内圆锥外及外圆锥内的光，让其光照从内圆锥逐渐向外圆锥减少至0。</li><li><p>使用的递减公式为：</p><script type="math/tex; mode=display">I= \frac{\theta - \gamma}{\epsilon}</script><blockquote><p>这里ϵ(Epsilon)是内（ϕ）和外圆锥（γ）之间的余弦值差（ϵ=ϕ−γ）。最终的I值就是在当前片段聚光的强度。</p></blockquote></li><li><p>聚光的特点：</p><ul><li>光源位置对聚光有影响。</li><li>光从一点发出，发向指定方向，即光被聚集在一个范围内。</li></ul></li><li><p>对于聚光的结构体为：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Light</span> &#123;</span><br>vec3 position;<br>  vec3 direction;<br><span class="hljs-keyword">float</span> cutOff;<br><span class="hljs-keyword">float</span> outerCutOff;<br><br>  vec3 ambient;<br>  vec3 diffuse;<br>  vec3 specular;<br><br>  <span class="hljs-comment">// float constant;</span><br>  <span class="hljs-comment">// float linear;</span><br>  <span class="hljs-comment">// float quadratic;</span><br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><img src="/2018/12/08/光照/spot_light2.png" alt=""></p></li><li><p>最终计算聚光的片段着色器代码为：</p><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 环境光</span><br>vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoord));<br>vec3 diffuse = vec3(<span class="hljs-number">0</span>);<br>vec3 specular = vec3(<span class="hljs-number">0</span>);<br><br>vec3 norm = normalize(Normal);<br>vec3 lightDir = normalize(light.position - FragPos);<br><span class="hljs-keyword">float</span> theta = dot(lightDir, normalize(-light.direction));<br><span class="hljs-keyword">float</span> epsilon   = light.cutOff - light.outerCutOff;<br><span class="hljs-keyword">float</span> intensity = clamp((theta - light.outerCutOff) / epsilon, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br><br><span class="hljs-keyword">if</span>(theta &gt; light.outerCutOff) &#123;<br><span class="hljs-comment">// 漫反射光</span><br><span class="hljs-keyword">float</span> diff = max(dot(norm, lightDir), <span class="hljs-number">0.0</span>);<br>diffuse = intensity * light.diffuse * diff * vec3(texture(material.diffuse, TexCoord));<br><br><span class="hljs-comment">// 镜面光</span><br>vec3 viewDir = normalize(viewPos - FragPos);<br>vec3 reflectDir = reflect(-lightDir, norm);<br><span class="hljs-keyword">float</span> spec = <span class="hljs-built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="hljs-number">0.0</span>), material.shininess);<br>specular = intensity * light.specular * spec * vec3(texture(material.specular, TexCoord));<br>&#125;<br><br>vec3 result = ambient  + diffuse + specular;<br>FragColor = vec4(result, <span class="hljs-number">1.0</span>);<br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="多光源-Multiple-lights"><a href="#多光源-Multiple-lights" class="headerlink" title="多光源(Multiple lights)"></a>多光源(Multiple lights)</h2><ul><li>将冯氏着色(Phong Shading)、材质(Material)、光照贴图(Lighting Map)以及不同种类的投光物(Light Caster)等零碎知识都放于同一场景中。</li><li>对光照的计算将会变成下面的样式：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c">out vec4 FragColor;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>  <span class="hljs-comment">// 定义一个输出颜色值</span><br>  vec3 output;<br>  <span class="hljs-comment">// 将定向光的贡献加到输出中</span><br>  output += someFunctionToCalculateDirectionalLight();<br>  <span class="hljs-comment">// 对所有的点光源也做相同的事情</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nr_of_point_lights; i++)<br>    output += someFunctionToCalculatePointLight();<br>  <span class="hljs-comment">// 也加上其它的光源（比如聚光）</span><br>  output += someFunctionToCalculateSpotLight();<br><br>  FragColor = vec4(output, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="定向光"><a href="#定向光" class="headerlink" title="定向光"></a>定向光</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DirLight</span> &#123;</span><br>    vec3 direction;<br><br>    vec3 ambient;<br>    vec3 diffuse;<br>    vec3 specular;<br>&#125;;  <br>uniform DirLight dirLight;<br><br><span class="hljs-function">vec3 <span class="hljs-title">CalcDirLight</span><span class="hljs-params">(DirLight light, vec3 normal, vec3 viewDir)</span><br></span>&#123;<br>    vec3 lightDir = normalize(-light.direction);<br>    <span class="hljs-comment">// 漫反射着色</span><br>    <span class="hljs-keyword">float</span> diff = max(dot(normal, lightDir), <span class="hljs-number">0.0</span>);<br>    <span class="hljs-comment">// 镜面光着色</span><br>    vec3 reflectDir = reflect(-lightDir, normal);<br>    <span class="hljs-keyword">float</span> spec = <span class="hljs-built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="hljs-number">0.0</span>), material.shininess);<br>    <span class="hljs-comment">// 合并结果</span><br>    vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));<br>    vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));<br>    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));<br>    <span class="hljs-keyword">return</span> (ambient + diffuse + specular);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="点光源"><a href="#点光源" class="headerlink" title="点光源"></a>点光源</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PointLight</span> &#123;</span><br>    vec3 position;<br><br>    <span class="hljs-keyword">float</span> constant;<br>    <span class="hljs-keyword">float</span> linear;<br>    <span class="hljs-keyword">float</span> quadratic;<br><br>    vec3 ambient;<br>    vec3 diffuse;<br>    vec3 specular;<br>&#125;;  <br><br><span class="hljs-function">vec3 <span class="hljs-title">CalcPointLight</span><span class="hljs-params">(PointLight light, vec3 normal, vec3 fragPos, vec3 viewDir)</span><br></span>&#123;<br>    vec3 lightDir = normalize(light.position - fragPos);<br>    <span class="hljs-comment">// 漫反射着色</span><br>    <span class="hljs-keyword">float</span> diff = max(dot(normal, lightDir), <span class="hljs-number">0.0</span>);<br>    <span class="hljs-comment">// 镜面光着色</span><br>    vec3 reflectDir = reflect(-lightDir, normal);<br>    <span class="hljs-keyword">float</span> spec = <span class="hljs-built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="hljs-number">0.0</span>), material.shininess);<br>    <span class="hljs-comment">// 衰减</span><br>    <span class="hljs-keyword">float</span> distance    = length(light.position - fragPos);<br>    <span class="hljs-keyword">float</span> attenuation = <span class="hljs-number">1.0</span> / (light.constant + light.linear * distance +<br>                 light.quadratic * (distance * distance));    <br>    <span class="hljs-comment">// 合并结果</span><br>    vec3 ambient  = light.ambient  * vec3(texture(material.diffuse, TexCoords));<br>    vec3 diffuse  = light.diffuse  * diff * vec3(texture(material.diffuse, TexCoords));<br>    vec3 specular = light.specular * spec * vec3(texture(material.specular, TexCoords));<br>    ambient  * = attenuation;<br>    diffuse  * = attenuation;<br>    specular * = attenuation;<br>    <span class="hljs-keyword">return</span> (ambient + diffuse + specular);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="聚光"><a href="#聚光" class="headerlink" title="聚光"></a>聚光</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SpotLight</span> &#123;</span><br>vec3 position;<br>vec3 direction;<br><br><span class="hljs-keyword">float</span> cutOff;<br><span class="hljs-keyword">float</span> outerCutOff;<br><br><span class="hljs-keyword">float</span> constant;<br>  <span class="hljs-keyword">float</span> linear;<br>  <span class="hljs-keyword">float</span> quadratic;<br><br>vec3 ambient;<br>  vec3 diffuse;<br>  vec3 specular;<br>&#125;;<br><br><span class="hljs-function">vec3 <span class="hljs-title">CalcSpotLight</span><span class="hljs-params">(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir)</span><br></span>&#123;<br><span class="hljs-comment">// 环境光</span><br>  vec3 ambient = light.ambient * vec3(texture(material.diffuse, TexCoord));<br>vec3 diffuse = vec3(<span class="hljs-number">0</span>);<br>vec3 specular = vec3(<span class="hljs-number">0</span>);<br><br>vec3 lightDir = normalize(light.position - fragPos);<br><span class="hljs-keyword">float</span> theta = dot(lightDir, normalize(-light.direction));<br><span class="hljs-keyword">float</span> epsilon   = light.cutOff - light.outerCutOff;<br><span class="hljs-keyword">float</span> intensity = clamp((theta - light.outerCutOff) / epsilon, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br><br><span class="hljs-keyword">if</span>(theta &gt; light.outerCutOff) &#123;<br><span class="hljs-comment">// 漫反射光</span><br><span class="hljs-keyword">float</span> diff = max(dot(normal, lightDir), <span class="hljs-number">0.0</span>);<br>diffuse = intensity * light.diffuse * diff * vec3(texture(material.diffuse, TexCoord));<br><br><span class="hljs-comment">// 镜面光</span><br>vec3 viewDir = normalize(viewPos - fragPos);<br>vec3 reflectDir = reflect(-lightDir, normal);<br><span class="hljs-keyword">float</span> spec = <span class="hljs-built_in">pow</span>(max(dot(viewDir, reflectDir), <span class="hljs-number">0.0</span>), material.shininess);<br>specular = intensity * light.specular * spec * vec3(texture(material.specular, TexCoord));<br>&#125;<br><br><span class="hljs-keyword">float</span> disition = length(light.position - fragPos);<br><span class="hljs-keyword">float</span> attennuation = <span class="hljs-number">1.0</span> / (light.constant + light.linear * disition + light.quadratic * disition * disition);<br><br>    <span class="hljs-keyword">return</span> attennuation * (ambient  + diffuse + specular);<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
          <category> 光照 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017随记-1200bookshop</title>
      <link href="/2017/03/12/2017%E9%9A%8F%E8%AE%B0-1200bookshop/"/>
      <url>/2017/03/12/2017%E9%9A%8F%E8%AE%B0-1200bookshop/</url>
      
        <content type="html"><![CDATA[<p><img src="/2017/03/12/2017随记-1200bookshop/img1.jpg" style="width: 30em;" alt="书店清晨"></p><a id="more"></a><ul><li>下班后天空飘着细雨，漫步在正佳大街上，看着人来人往，听着伞上的细响，一路走着，我走向书店。</li><li>三楼依旧挤满了人，幸运的是，我在二楼找到座位。</li><li>午夜12点，店里的分享活动开始了，回到三楼，听了约摸一小时的分享，周围回归宁静。在宁静中看完汤川学与石神的较量后，天泛起了亮光。透过玻璃窗隔着雾气看着清静的街道，广州，正在醒来。如同相反一般，我闭上眼睛，揉了揉眼，进入了梦乡。</li><li>在突然变大的音乐声中醒来，因清扫需要，读者们纷纷离开书店。简单梳洗过后，我在楼下吃过早餐，又回到店中。之后便是阅读，觅食，阅读，觅食，归巢。</li></ul><p><img src="/2017/03/12/2017随记-1200bookshop/img2.jpg" style="width: 30em;" alt="书店夜晚"></p>]]></content>
      
      
      <categories>
          
          <category> 2017随记 </category>
          
          <category> 1200bookshop </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017随记-海鸥岛</title>
      <link href="/2017/02/12/2017%E9%9A%8F%E8%AE%B0-%E6%B5%B7%E9%B8%A5%E5%B2%9B/"/>
      <url>/2017/02/12/2017%E9%9A%8F%E8%AE%B0-%E6%B5%B7%E9%B8%A5%E5%B2%9B/</url>
      
        <content type="html"><![CDATA[<p><img src="/2017/02/12/2017随记-海鸥岛/img2.jpg" alt="没有海鸥的海鸥岛"><br><a id="more"></a></p><ul><li>起床，肝阴阳师到10点。</li><li>吃石磨肠粉，到11.30出发，去海鸥岛。</li></ul><hr><ul><li>到了石磅后，等了好久的车，终于等到148B了，车上有三个妹纸目的地是海鸥岛，不过却在同兴村下了。我在江鸥村下，寻找红树林，遇到了一个跟我目的地相同的妹纸，于是便约着一起去海鸥岛。</li><li>一路走，一路聊，她来自湖南，学经济的，刚来广州一个月，做销售管理，校招来这里的，公司在浔峰岗那边，打算辞职回湖南，故临走前到处走走玩玩。</li><li>我们绕着湖骑自行车到五点，坐148回去。在进地铁前，问她回去吃什么，她说公司食堂五点关门，回去只能吃泡面。我说，吃泡面这么恶心？遂邀请之一同吃饭。最后我们在体育西的绿茵阁吃过晚饭，在燕塘分手。我最终也没问她名字，她也没问我名字，吃饭给钱时她要转回我支付宝也被我拒了。</li></ul><hr><ul><li>跟名字都不知道的陌生人过了一天。<br><img src="/2017/02/12/2017随记-海鸥岛/img1.jpg" style="width: 30em;"></li></ul>]]></content>
      
      
      <categories>
          
          <category> 2017随记 </category>
          
          <category> 海鸥岛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
  
</search>
