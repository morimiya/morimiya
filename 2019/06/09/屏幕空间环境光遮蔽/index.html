<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    
    <meta name="keywords" content="Life, ARIA, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="MoriMiya" type="application/atom+xml">
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/clipboard.min.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var cb = null;
      var els = $(".post figure.highlight");
      if (els.length) {
        // Enabled Hexo highlight line number.
        $(els).each(function (i, e) {
          $(e).before("<button class=\"copy button\">复制</button>");
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              // nextElementSibling is figure,highlight.
              // And following is the sequence of Hexo's internal
              // highlight layout with line number.
              return trigger.nextElementSibling.firstChild.firstChild.firstChild.lastChild.firstChild.firstChild;
          }
        });
      } else {
        // Disabled Hexo highlight line number.
        els = $(".post pre code");
        $(els).each(function (i, e) {
          // Add button before pre, not code.
          $(e).parent().before("<button class=\"copy button\">复制</button>");
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              // nextElementSibling is figure,highlight.
              // And following is the sequence of Hexo's internal
              // highlight layout without line number.
              return trigger.nextElementSibling.firstChild;
          }
        });
      }
      cb.on("success", function (e) {
        e.clearSelection();
        var trigger = e.trigger;
        // Change button text as a user tip.
        trigger.innerHTML = "已复制";
        $(trigger).addClass("copied");
        // Change button text back;
        setTimeout(function () {
          trigger.innerHTML = "复制";
          $(trigger).removeClass("copied");
        }, 1500);
      });
    });
    </script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>屏幕空间环境光遮蔽 | MoriMiya - Don't you want to be alive before you die?</title>
  </head>
  <body itemscope="" itemtype="http://schema.org/WebPage" lang="zh_CN" data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">MoriMiya</a></h1>
        <h2 class="subtitle">Don't you want to be alive before you die?</h2>
      </div>
      
      <div class="logo">
        <img src="/images/logo.png" alt="logo">
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/"><i class="fas fa-home"></i><span class="menu-text">首页</span></a></li>
        
        <li role="menuitem"><a href="/archives/"><i class="fas fa-archive"></i><span class="menu-text">归档</span></a></li>
        
        <li role="menuitem"><a href="/categories/"><i class="fas fa-th-list"></i><span class="menu-text">分类</span></a></li>
        
        <li role="menuitem"><a href="/tags/"><i class="fas fa-tags"></i><span class="menu-text">标签</span></a></li>
        
        <li role="menuitem"><a href="/about/"><i class="fas fa-user-edit"></i><span class="menu-text">关于</span></a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            
<div id="post" class="page">
  
  <article class="article post card animate" itemscope="" itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://morimiya.me/2019/06/09/屏幕空间环境光遮蔽/">
      <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
       <meta itemprop="name" content="MoriMiya">
       <meta itemprop="description" content="">
       <meta itemprop="image" content="/images/myavatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
       <meta itemprop="name" content="MoriMiya">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">屏幕空间环境光遮蔽</h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2019-06-09T19:52:34+08:00">2019-06-09 19:52:34</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a></span><i class="fas fa-angle-right"></i><span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/OpenGL/屏幕空间环境光遮蔽/" itemprop="url" rel="index"><span itemprop="name">屏幕空间环境光遮蔽</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      <blockquote>
<p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> SSAO学习笔记</p>
</blockquote>
<ul>
<li><img src="/2019/06/09/屏幕空间环境光遮蔽/without_ssao.png" alt=""></li>
<li><img src="/2019/06/09/屏幕空间环境光遮蔽/with_ssao.png" alt=""></li>
</ul>
<a id="more"></a>
<hr>
<h2 id="环境光遮蔽"><a href="#环境光遮蔽" class="headerlink" title="环境光遮蔽"></a>环境光遮蔽</h2><ul>
<li>在之前的光照模型中，我们一直用漫反射乘以一个较小的常数来模拟环境光的散射，然而，在现实世界中，物体的散射并不是一成不变的，在背光面，褶皱处，它们会更加的暗。环境光遮蔽(Ambient Occlusion)，它的原理是通过将褶皱、孔洞和非常靠近的墙面变暗的方法近似模拟出间接光照。这些区域很大程度上是被周围的几何体遮蔽的，光线会很难流失，所以这些地方看起来会更暗一些。</li>
<li>环境光遮蔽这一技术会带来很大的性能开销，因为它还需要考虑周围的几何体。我们可以对空间中每一点发射大量光线来确定其遮蔽量，但是这在实时运算中会很快变成大问题。</li>
</ul>
<h2 id="屏幕空间环境光遮蔽-SSAO"><a href="#屏幕空间环境光遮蔽-SSAO" class="headerlink" title="屏幕空间环境光遮蔽(SSAO)"></a>屏幕空间环境光遮蔽(SSAO)</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul>
<li>对于铺屏四边形(Screen-filled Quad)上的每一个片段，我们都会根据周边深度值计算一个遮蔽因子(Occlusion Factor)。这个遮蔽因子之后会被用来减少或者抵消片段的环境光照分量。遮蔽因子是通过采集片段周围球型核心(Kernel)的多个深度样本，并和当前片段深度值对比而得到的。高于片段深度值样本的个数就是我们想要的遮蔽因子。</li>
</ul>
<p><img src="/2019/06/09/屏幕空间环境光遮蔽/ssao_crysis_circle.png" style="width: 400px;"></p>
<ul>
<li>上图中在几何体内灰色的深度样本都是高于片段深度值的，他们会增加遮蔽因子；几何体内样本个数越多，片段获得的环境光照也就越少。</li>
<li>使用球体作为采样核心容易使得显示效果灰蒙蒙，因为在法线背面的样本都在增加遮蔽因子。因此，我们将使用一个沿着表面法向量的半球体采样核心。</li>
</ul>
<p><img src="/2019/06/09/屏幕空间环境光遮蔽/ssao_hemisphere.png" style="width: 400px;"></p>
<ul>
<li>为了降低计算消耗，会使用随机性的采样核心(Sample Kernel)进行采样，从而减少样本的数目。再通过随机旋转采样核心，我们能在有限样本数量中得到高质量的结果。然而这仍然会有一定的麻烦，因为随机性引入了一个很明显的噪声图案，我们将需要通过模糊结果来修复这一问题。</li>
</ul>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><ul>
<li>SSAO的过程与延迟着色法相似，只是在最后处理光照部分需要加入对遮蔽因子的处理。因此这里最主要的问题便是如何计算遮蔽因子。遮蔽因子将存放于纹理附件中，供最终处理光照时使用。</li>
<li>对于一个片段，我们需要以下的数据来计算出其遮蔽因子：<ol>
<li>逐片段的 <em>位置</em> 向量。</li>
<li>逐片段的 <em>法线</em> 向量。</li>
<li><em>采样核心</em> 。</li>
<li>用来旋转采样核心的随机旋转矢量（ <em>噪声纹理</em> ）。</li>
</ol>
</li>
<li>位置向量和法线向量于延迟着色中的做法相似，直接计算输出到G缓冲中即可，需要注意的是要统一空间，这里将它们统一为观察空间输出。</li>
</ul>
<h4 id="采样核心"><a href="#采样核心" class="headerlink" title="采样核心"></a>采样核心</h4><ul>
<li>我们需要沿着表面法线方向生成大量的样本。由于对每个表面法线方向生成采样核心非常困难，也不合实际，我们将在切线空间(Tangent Space)内生成采样核心，法向量将指向正z方向。</li>
<li>随机的采样核心会在片段周围平均的进行采样，为了越靠近片段有越多的采样，这里对随机到的采样点乘以一个系数，让它们更多的靠近原片段。</li>
</ul>
<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::uniform_real_distribution&lt;GLfloat&gt; randomFloats(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>); <span class="hljs-comment">// generates random floats between 0.0 and 1.0</span><br><span class="hljs-built_in">std</span>::default_random_engine generator;<br><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;glm::vec3&gt; ssaoKernel;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; ++i) &#123;<br>	glm::<span class="hljs-function">vec3 <span class="hljs-title">sample</span><span class="hljs-params">(randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>, randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>, randomFloats(generator))</span></span>;<br>	sample = glm::normalize(sample);<br>	sample * = randomFloats(generator);<br>	<span class="hljs-keyword">float</span> scale = <span class="hljs-keyword">float</span>(i) / <span class="hljs-number">64.0</span>;<br><br>	<span class="hljs-comment">// scale samples s.t. they're more aligned to center of kernel</span><br>	scale = <span class="hljs-number">0.1</span> + scale * scale * (<span class="hljs-number">1.0f</span> - <span class="hljs-number">0.1f</span>);<br>	sample * = scale;<br>	ssaoKernel.push_back(sample);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="/2019/06/09/屏幕空间环境光遮蔽/ssao_kernel_weight.png" style="width: 700px;"></p>
<h4 id="噪声纹理"><a href="#噪声纹理" class="headerlink" title="噪声纹理"></a>噪声纹理</h4><ul>
<li>通过引入一些随机性到采样核心上，我们可以大大减少获得不错结果所需的样本数量。我们可以对场景中每一个片段创建一个随机旋转向量，但这会很快将内存耗尽。所以，更好的方法是创建一个小的随机旋转向量纹理平铺在屏幕上。</li>
</ul>
<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;glm::vec3&gt; ssaoNoise;<br><span class="hljs-keyword">for</span> (GLuint i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">16</span>; i++)<br>&#123;<br>	glm::<span class="hljs-function">vec3 <span class="hljs-title">noise</span><span class="hljs-params">(<br>		randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>,<br>		randomFloats(generator) * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>,<br>		<span class="hljs-number">0.0f</span>)</span></span>;<br>	ssaoNoise.push_back(noise);<br>&#125;<br><br>GLuint noiseTexture;<br>glGenTextures(<span class="hljs-number">1</span>, &amp;noiseTexture);<br>glBindTexture(GL_TEXTURE_2D, noiseTexture);<br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB16F, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, GL_RGB, GL_FLOAT, &amp;ssaoNoise[<span class="hljs-number">0</span>]);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br></code></pre></td></tr></table></figure>
<h3 id="SSAO着色器"><a href="#SSAO着色器" class="headerlink" title="SSAO着色器"></a>SSAO着色器</h3><ul>
<li>为了对每一个屏幕上的片段都生成一个遮蔽值，并将该值存在纹理中，这里需要再使用一个帧缓冲对象用于缓存临时结果，供最后光照处理阶段使用。</li>
<li>由于环境遮蔽的结果是一个灰度值，我们将只需要纹理的红色分量，所以我们将颜色缓冲的内部格式设置为 <em>GL_RED</em> 。</li>
</ul>
<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">GLuint ssaoFBO;<br>glGenFramebuffers(<span class="hljs-number">1</span>, &amp;ssaoFBO);  <br>glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO);<br>GLuint ssaoColorBuffer;<br><br>glGenTextures(<span class="hljs-number">1</span>, &amp;ssaoColorBuffer);<br>glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer);<br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number">0</span>, GL_RGB, GL_FLOAT, <span class="hljs-literal">NULL</span>);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBuffer, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li>其完整渲染过程大致如下：</li>
</ul>
<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 几何处理阶段: 渲染到G缓冲中</span><br>glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);<br>	[...]<br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);  <br><br><span class="hljs-comment">// 使用G缓冲渲染SSAO纹理</span><br>glBindFramebuffer(GL_FRAMEBUFFER, ssaoFBO);<br>	glClear(GL_COLOR_BUFFER_BIT);<br>	ssaoShader.Use();<br>	glActiveTexture(GL_TEXTURE0);<br>	glBindTexture(GL_TEXTURE_2D, gPosition);<br>	glActiveTexture(GL_TEXTURE1);<br>	glBindTexture(GL_TEXTURE_2D, gNormal);<br>	glActiveTexture(GL_TEXTURE2);<br>	glBindTexture(GL_TEXTURE_2D, noiseTexture);<br>	SendKernelSamplesToShader();<br>	glUniformMatrix4fv(projLocation, <span class="hljs-number">1</span>, GL_FALSE, glm::value_ptr(projection));<br>	RenderQuad();<br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 光照处理阶段: 渲染场景光照</span><br>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>shaderLightingPass.Use();<br>[...]<br>glActiveTexture(GL_TEXTURE3);<br>glBindTexture(GL_TEXTURE_2D, ssaoColorBuffer);<br>[...]<br>RenderQuad();<br></code></pre></td></tr></table></figure>
<ul>
<li>ssao的片段着色器实现如下：</li>
</ul>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">float</span> FragColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> TexCoords;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> gPosition;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> gNormal;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> texNoise;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec3</span> samples[<span class="hljs-number">64</span>];<br><br><span class="hljs-type">int</span> kernelSize = <span class="hljs-number">64</span>;<br><span class="hljs-type">float</span> radius = <span class="hljs-number">0.5</span>;<br><span class="hljs-type">float</span> bias = <span class="hljs-number">0.025</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">vec2</span> noiseScale = <span class="hljs-type">vec2</span>(<span class="hljs-number">800.0</span> / <span class="hljs-number">4.0</span>, <span class="hljs-number">400.0</span> / <span class="hljs-number">4.0</span>);<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-type">vec3</span> fragPos = <span class="hljs-built_in">texture</span>(gPosition, TexCoords).rgb;<br>	<span class="hljs-type">vec3</span> normal = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">texture</span>(gNormal, TexCoords).rgb);<br>	<span class="hljs-type">vec3</span> randomVec = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">texture</span>(texNoise, TexCoords * noiseScale).xyz);<br><br>	<span class="hljs-type">vec3</span> tangent = <span class="hljs-built_in">normalize</span>(randomVec - normal * <span class="hljs-built_in">dot</span>(randomVec, normal));<br>    <span class="hljs-type">vec3</span> bitangent = <span class="hljs-built_in">cross</span>(normal, tangent);<br>    <span class="hljs-type">mat3</span> TBN = <span class="hljs-type">mat3</span>(tangent, bitangent, normal);<br><br>	<span class="hljs-type">float</span> occlusion = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kernelSize; ++i) &#123;<br>        <span class="hljs-comment">// get sample position</span><br>        <span class="hljs-type">vec3</span> <span class="hljs-keyword">sample</span> = TBN * samples[i]; <span class="hljs-comment">// from tangent to view-space</span><br>        <span class="hljs-keyword">sample</span> = fragPos + <span class="hljs-keyword">sample</span> * radius;<br><br>        <span class="hljs-comment">// project sample position (to sample texture) (to get position on screen/texture)</span><br>        <span class="hljs-type">vec4</span> <span class="hljs-keyword">offset</span> = <span class="hljs-type">vec4</span>(<span class="hljs-keyword">sample</span>, <span class="hljs-number">1.0</span>);<br>        <span class="hljs-keyword">offset</span> = projection * <span class="hljs-keyword">offset</span>; <span class="hljs-comment">// from view to clip-space</span><br>        <span class="hljs-keyword">offset</span>.xyz /= <span class="hljs-keyword">offset</span>.w; <span class="hljs-comment">// perspective divide</span><br>        <span class="hljs-keyword">offset</span>.xyz = <span class="hljs-keyword">offset</span>.xyz * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>; <span class="hljs-comment">// transform to range 0.0 - 1.0</span><br><br>        <span class="hljs-comment">// get sample depth</span><br>        <span class="hljs-type">float</span> sampleDepth = <span class="hljs-built_in">texture</span>(gPosition, <span class="hljs-keyword">offset</span>.xy).z; <span class="hljs-comment">// get depth value of kernel sample</span><br><br>        <span class="hljs-comment">// range check &amp; accumulate</span><br>        <span class="hljs-type">float</span> rangeCheck = <span class="hljs-built_in">smoothstep</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, radius / <span class="hljs-built_in">abs</span>(fragPos.z - sampleDepth));<br>        occlusion += (sampleDepth &gt;= <span class="hljs-keyword">sample</span>.z + bias ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>) * rangeCheck;<br>    &#125;<br>    occlusion = <span class="hljs-number">1.0</span> - (occlusion / kernelSize);<br><br>    FragColor = occlusion;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">const</span> <span class="hljs-type">vec2</span> noiseScale = <span class="hljs-type">vec2</span>(<span class="hljs-number">800.0</span> / <span class="hljs-number">4.0</span>, <span class="hljs-number">400.0</span> / <span class="hljs-number">4.0</span>);<br><span class="hljs-type">vec3</span> randomVec = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">texture</span>(texNoise, TexCoords * noiseScale).xyz);<br></code></pre></td></tr></table></figure>
<ul>
<li>由于噪声纹理只为4X4的大小，通过REPEAT的方式将屏幕铺满，故在采样时需要乘上对应的缩放比率，缩放比率为屏幕大小除以噪声纹理大小。</li>
</ul>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">vec3</span> fragPos = <span class="hljs-built_in">texture</span>(gPosition, TexCoords).rgb;<br><span class="hljs-type">vec3</span> normal = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">texture</span>(gNormal, TexCoords).rgb);<br><span class="hljs-type">vec3</span> randomVec = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">texture</span>(texNoise, TexCoords * noiseScale).xyz);<br><br><span class="hljs-type">vec3</span> tangent = <span class="hljs-built_in">normalize</span>(randomVec - normal * <span class="hljs-built_in">dot</span>(randomVec, normal));<br><span class="hljs-type">vec3</span> bitangent = <span class="hljs-built_in">cross</span>(normal, tangent);<br><span class="hljs-type">mat3</span> TBN = <span class="hljs-type">mat3</span>(tangent, bitangent, normal);<br></code></pre></td></tr></table></figure>
<ul>
<li>这里使用一个随机的向量来构造切线向量来构建TBN矩阵，没有使用沿着几何体表面的TBN矩阵。</li>
</ul>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> occlusion = <span class="hljs-number">0.0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; kernelSize; ++i) &#123;<br>    <span class="hljs-comment">// get sample position</span><br>    <span class="hljs-type">vec3</span> <span class="hljs-keyword">sample</span> = TBN * samples[i]; <span class="hljs-comment">// from tangent to view-space</span><br>    <span class="hljs-keyword">sample</span> = fragPos + <span class="hljs-keyword">sample</span> * radius;<br><br>    <span class="hljs-comment">// project sample position (to sample texture) (to get position on screen/texture)</span><br>    <span class="hljs-type">vec4</span> <span class="hljs-keyword">offset</span> = <span class="hljs-type">vec4</span>(<span class="hljs-keyword">sample</span>, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-keyword">offset</span> = projection * <span class="hljs-keyword">offset</span>; <span class="hljs-comment">// from view to clip-space</span><br>    <span class="hljs-keyword">offset</span>.xyz /= <span class="hljs-keyword">offset</span>.w; <span class="hljs-comment">// perspective divide</span><br>    <span class="hljs-keyword">offset</span>.xyz = <span class="hljs-keyword">offset</span>.xyz * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>; <span class="hljs-comment">// transform to range 0.0 - 1.0</span><br><br>    <span class="hljs-comment">// get sample depth</span><br>    <span class="hljs-type">float</span> sampleDepth = <span class="hljs-built_in">texture</span>(gPosition, <span class="hljs-keyword">offset</span>.xy).z; <span class="hljs-comment">// get depth value of kernel sample</span><br><br>    <span class="hljs-comment">// range check &amp; accumulate</span><br>    <span class="hljs-type">float</span> rangeCheck = <span class="hljs-built_in">smoothstep</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, radius / <span class="hljs-built_in">abs</span>(fragPos.z - sampleDepth));<br>    occlusion += (sampleDepth &gt;= <span class="hljs-keyword">sample</span>.z + bias ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>) * rangeCheck;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>这里的kernelSize和radius变量都可以用来调整效果；在这里我们分别保持他们的默认值为64和1.0。对于每一次迭代我们首先变换各自样本到观察空间。之后我们会加观察空间核心偏移样本到观察空间片段位置上；最后再用radius乘上偏移样本来增加(或减少)SSAO的有效取样半径。</p>
</li>
<li><p>接下来我们变换sample到屏幕空间，从而我们可以就像正在直接渲染它的位置到屏幕上一样取样sample的(线性)深度值。由于这个向量目前在观察空间，我们将首先使用projection矩阵uniform变换它到裁剪空间。在变量被变换到裁剪空间之后，我们用xyz分量除以w分量进行透视划分。结果所得的标准化设备坐标之后变换到[0.0, 1.0]范围以便我们使用它们去取样深度纹理。</p>
</li>
</ul>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl">occlusion += (sampleDepth &gt;= <span class="hljs-keyword">sample</span>.z ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li>接下来可以直接检查样本的当前深度值是否大于存储的深度值，如果是的，添加到最终的贡献因子上。</li>
<li>但在检测一个靠近表面边缘的片段时，它将会考虑测试表面之下的表面的深度值；这些值将会(不正确地)影响遮蔽因子。</li>
</ul>
<p><img src="/2019/06/09/屏幕空间环境光遮蔽/without_smoothstep.png" style="width: 600px;"></p>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> rangeCheck = <span class="hljs-built_in">smoothstep</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, radius / <span class="hljs-built_in">abs</span>(fragPos.z - sampleDepth));<br>occlusion += (sampleDepth &gt;= <span class="hljs-keyword">sample</span>.z + bias ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>) * rangeCheck;<br></code></pre></td></tr></table></figure>
<ul>
<li>最后一步替换使用了GLSL的smoothstep函数，它非常光滑地在第一和第二个参数范围内插值了第三个参数。如果深度差因此最终取值在radius之间，它们的值将会光滑地根据下面这个曲线插值在0.0和1.0之间：</li>
</ul>
<p><img src="/2019/06/09/屏幕空间环境光遮蔽/ssao_smoothstep.png" style="width: 400px;"><br><img src="/2019/06/09/屏幕空间环境光遮蔽/with_smoothstep.png" style="width: 600px;"></p>
<h3 id="环境遮蔽模糊"><a href="#环境遮蔽模糊" class="headerlink" title="环境遮蔽模糊"></a>环境遮蔽模糊</h3><ul>
<li>直接使用SSAO的结果会发现噪声较为严重，从图中能看到阴影呈现格子块状，故需要在SSAO阶段和光照处理阶段中间插入对SSAO进行模糊的处理。因而需要再创建一个帧缓冲来保存模糊结果。</li>
</ul>
<figure class="hljs highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">GLuint ssaoBlurFBO, ssaoColorBufferBlur;<br>glGenFramebuffers(<span class="hljs-number">1</span>, &amp;ssaoBlurFBO);<br>glBindFramebuffer(GL_FRAMEBUFFER, ssaoBlurFBO);<br>glGenTextures(<span class="hljs-number">1</span>, &amp;ssaoColorBufferBlur);<br>glBindTexture(GL_TEXTURE_2D, ssaoColorBufferBlur);<br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RED, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number">0</span>, GL_RGB, GL_FLOAT, <span class="hljs-literal">NULL</span>);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, ssaoColorBufferBlur, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> TexCoords;<br><span class="hljs-keyword">out</span> <span class="hljs-type">float</span> fragColor;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> ssaoInput;<br><br><span class="hljs-type">void</span> main() &#123;<br>    <span class="hljs-type">vec2</span> texelSize = <span class="hljs-number">1.0</span> / <span class="hljs-type">vec2</span>(<span class="hljs-built_in">textureSize</span>(ssaoInput, <span class="hljs-number">0</span>));<br>    <span class="hljs-type">float</span> result = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">-2</span>; x &lt; <span class="hljs-number">2</span>; ++x)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">-2</span>; y &lt; <span class="hljs-number">2</span>; ++y)<br>        &#123;<br>            <span class="hljs-type">vec2</span> <span class="hljs-keyword">offset</span> = <span class="hljs-type">vec2</span>(<span class="hljs-type">float</span>(x), <span class="hljs-type">float</span>(y)) * texelSize;<br>            result += <span class="hljs-built_in">texture</span>(ssaoInput, TexCoords + <span class="hljs-keyword">offset</span>).r;<br>        &#125;<br>    &#125;<br>    fragColor = result / (<span class="hljs-number">4.0</span> * <span class="hljs-number">4.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>这里我们遍历了周围在-2.0和2.0之间的SSAO纹理单元(Texel)，采样与噪声纹理维度相同数量的SSAO纹理。我们通过使用返回vec2纹理维度的textureSize，根据纹理单元的真实大小偏移了每一个纹理坐标。我们平均所得的结果，获得一个简单但是有效的模糊效果：</li>
</ul>
<p><img src="/2019/06/09/屏幕空间环境光遮蔽/ssao_blur.png" style="width: 600px;"></p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ul>
<li>在最终处理光照阶段对环境光加上遮蔽值的影响即可。</li>
</ul>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">float</span> AmbientOcclusion = <span class="hljs-built_in">texture</span>(ssao, TexCoords).r;<br><span class="hljs-type">vec3</span> ambient = <span class="hljs-type">vec3</span>(<span class="hljs-number">0.3</span> * Diffuse * AmbientOcclusion);<br></code></pre></td></tr></table></figure>
<p><img src="/2019/06/09/屏幕空间环境光遮蔽/with_ssao.png" style="width: 600px;"></p>

    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/OpenGL/" rel="tag"><i class="fas fa-tags"></i>OpenGL</a>
        
        <a class="post-tag button" href="/tags/屏幕空间环境光遮蔽/" rel="tag"><i class="fas fa-tags"></i>屏幕空间环境光遮蔽</a>
        
        <a class="post-tag button" href="/tags/SSAO/" rel="tag"><i class="fas fa-tags"></i>SSAO</a>
        
      </div>
      
    </footer>
  </article>
  
  
  <nav class="page-nav">
    <div class="page-nav-next page-nav-item">
      
      <a href="/2019/06/08/延迟着色法/" rel="next" title="延迟着色法"><i class="fas fa-angle-left"></i><span class="nav-title">延迟着色法</span></a>
      
    </div>
    <div class="page-nav-prev page-nav-item">
      
      <a href="/2019/08/30/2019CGDC-CJ/" rel="prev" title="2019CGDC+CJ"><span class="nav-title">2019CGDC+CJ</span><i class="fas fa-angle-right"></i></a>
      
    </div>
  </nav>
  
  
  

<div class="comments" id="comments">
  
  
  <div id="vcomments" class="vcomments"></div>
  <script defer src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script defer src="//unpkg.com/valine/dist/Valine.min.js"></script>
  <script type="text/javascript">
  $(document).ready(function () {
    new Valine({
      "el": "#vcomments",
      "appId": "g87PyVdDsH5EP8VCTtaGlIBo-gzGzoHsz",
      "appKey": "wboY6qvCvYXBESIQQOWkFzYq",
      "verify": "false",
      "notify": "false",
      "avatar": "mm",
      "meta": ["nick", "mail", "link"],
      "pageSize": 10,
      "lang": "zh-cn",
      "visitor": "false",
      "highlight": "true",
      "placeholder": "在这里说点什么……",
      "avatarForce": "false"
    });
  });
  </script>
  
  
</div>



  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control">
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/myavatar.png" alt="MoriMiya">
  
  <h1 class="author-name">MoriMiya</h1>
  <h2 class="author-description"></h2>
  <div class="site-count">
    
    
    
    
    <div class="archives-count count-block">
      <div class="site-count-title">归档</div>
      <div><a href="/archives/">28</a></div>
    </div>
    
    
    
    <div class="categories-count count-block">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">23</a></div>
    </div>
    
    
    
    <div class="tags-count count-block">
      <div class="site-count-title">标签</div>
      <div><a href="/tags/">25</a></div>
    </div>
    
    
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    
    
    
    <hr>
    <div class="post-toc sidebar-item" id="toc-div">
      <div><i class="fas fa-list-ol"></i>文章目录</div>
      <div class="post-toc-content"><ol class="list-group toc"><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#环境光遮蔽"><span class="toc-text">环境光遮蔽</span></a></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#屏幕空间环境光遮蔽-SSAO"><span class="toc-text">屏幕空间环境光遮蔽(SSAO)</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#原理"><span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#过程"><span class="toc-text">过程</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#采样核心"><span class="toc-text">采样核心</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#噪声纹理"><span class="toc-text">噪声纹理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#SSAO着色器"><span class="toc-text">SSAO着色器</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#环境遮蔽模糊"><span class="toc-text">环境遮蔽模糊</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#效果"><span class="toc-text">效果</span></a></li></ol></div>
    </div>
    
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接<p></p></div>
      <ul>
        
        <li><i class="fab fa-github"></i><a href="https://github.com/morimiya" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
    
    <hr>
    <div class="blogroll sidebar-item">
      <div><i class="fas fa-link"></i>友情链接</div>
      <ul>
        
        <li><i class="fas fa-link"></i><a href="https://github.com/" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">MoriMiya</span><span class="year"><i class="far fa-copyright"></i>2018 - 2021</span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
