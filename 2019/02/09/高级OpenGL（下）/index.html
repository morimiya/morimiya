<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    
    <meta name="keywords" content="Life, ARIA, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="MoriMiya" type="application/atom+xml">
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/clipboard.min.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var cb = null;
      var els = $(".post figure.highlight");
      if (els.length) {
        // Enabled Hexo highlight line number.
        $(els).each(function (i, e) {
          $(e).before("<button class=\"copy button\">复制</button>");
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              // nextElementSibling is figure,highlight.
              // And following is the sequence of Hexo's internal
              // highlight layout with line number.
              return trigger.nextElementSibling.firstChild.firstChild.firstChild.lastChild.firstChild.firstChild;
          }
        });
      } else {
        // Disabled Hexo highlight line number.
        els = $(".post pre code");
        $(els).each(function (i, e) {
          // Add button before pre, not code.
          $(e).parent().before("<button class=\"copy button\">复制</button>");
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              // nextElementSibling is figure,highlight.
              // And following is the sequence of Hexo's internal
              // highlight layout without line number.
              return trigger.nextElementSibling.firstChild;
          }
        });
      }
      cb.on("success", function (e) {
        e.clearSelection();
        var trigger = e.trigger;
        // Change button text as a user tip.
        trigger.innerHTML = "已复制";
        $(trigger).addClass("copied");
        // Change button text back;
        setTimeout(function () {
          trigger.innerHTML = "复制";
          $(trigger).removeClass("copied");
        }, 1500);
      });
    });
    </script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>高级OpenGL（下） | MoriMiya - Don't you want to be alive before you die?</title>
  </head>
  <body itemscope="" itemtype="http://schema.org/WebPage" lang="zh_CN" data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">MoriMiya</a></h1>
        <h2 class="subtitle">Don't you want to be alive before you die?</h2>
      </div>
      
      <div class="logo">
        <img src="/images/logo.png" alt="logo">
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/"><i class="fas fa-home"></i><span class="menu-text">首页</span></a></li>
        
        <li role="menuitem"><a href="/archives/"><i class="fas fa-archive"></i><span class="menu-text">归档</span></a></li>
        
        <li role="menuitem"><a href="/categories/"><i class="fas fa-th-list"></i><span class="menu-text">分类</span></a></li>
        
        <li role="menuitem"><a href="/tags/"><i class="fas fa-tags"></i><span class="menu-text">标签</span></a></li>
        
        <li role="menuitem"><a href="/about/"><i class="fas fa-user-edit"></i><span class="menu-text">关于</span></a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            
<div id="post" class="page">
  
  <article class="article post card animate" itemscope="" itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://morimiya.me/2019/02/09/高级OpenGL（下）/">
      <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
       <meta itemprop="name" content="MoriMiya">
       <meta itemprop="description" content="">
       <meta itemprop="image" content="/images/myavatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
       <meta itemprop="name" content="MoriMiya">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">高级OpenGL（下）</h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2019-02-09T15:08:17+08:00">2019-02-09 15:08:17</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a></span><i class="fas fa-angle-right"></i><span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/OpenGL/高级OpenGL/" itemprop="url" rel="index"><span itemprop="name">高级OpenGL</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      <blockquote>
<p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 高级OpenGL学习笔记</p>
<p>高级数据、高级GLSL，几何着色器，实例化，抗锯齿。</p>
</blockquote>
<a id="more"></a>
<h2 id="高级数据-Advanced-Data"><a href="#高级数据-Advanced-Data" class="headerlink" title="高级数据(Advanced Data)"></a>高级数据(Advanced Data)</h2><h3 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h3><ul>
<li>OpenGL中的缓冲只是一个管理特定内存块的对象，没有其它更多的功能了。在我们将它绑定到一个缓冲目标(Buffer Target)时，我们才赋予了其意义。当我们绑定一个缓冲到GL_ARRAY_BUFFER时，它就是一个顶点数组缓冲，但我们也可以很容易地将其绑定到GL_ELEMENT_ARRAY_BUFFER。OpenGL内部会为每个目标储存一个缓冲，并且会根据目标的不同，以不同的方式处理缓冲。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>glBufferData</td>
<td>填充缓冲对象所管理的内存，这个函数会分配一块内存，并将数据添加到这块内存中。如果我们将它的data参数设置为NULL，那么这个函数将只会分配内存，但不进行填充。这在我们需要预留(Reserve)特定大小的内存，之后回到这个缓冲一点一点填充的时候会很有用。</td>
</tr>
<tr>
<td>glBufferSubData</td>
<td>填充缓冲的特定区域。这个函数需要一个缓冲目标、一个偏移量、数据的大小和数据本身作为它的参数。这个函数不同的地方在于，我们可以提供一个偏移量，指定从何处开始填充这个缓冲。这能够让我们插入或者更新缓冲内存的某一部分。要注意的是，缓冲需要有足够的已分配内存，所以对一个缓冲调用glBufferSubData之前必须要先调用glBufferData。</td>
</tr>
<tr>
<td>glMapBuffer</td>
<td>请求缓冲内存的指针，直接将数据复制到缓冲当中。调用glMapBuffer函数，OpenGL会返回当前绑定缓冲的内存指针。</td>
</tr>
<tr>
<td>glUnmapBuffer</td>
<td>使用glUnmapBuffer函数，告诉OpenGL我们已经完成指针操作之后，OpenGL就会知道你已经完成了。在解除映射(Unmapping)之后，指针将会不再可用，并且如果OpenGL能够成功将您的数据映射到缓冲中，这个函数将会返回GL_TRUE。</td>
</tr>
</tbody>
</table>
</div>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// glBufferSubData使用例子</span><br>glBufferSubData(GL_ARRAY_BUFFER, <span class="hljs-number">24</span>, <span class="hljs-keyword">sizeof</span>(data), &amp;data); <span class="hljs-comment">// 范围： [24, 24 + sizeof(data)]</span><br></code></pre></td></tr></table></figure>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// glMapBuffer、glUnmapBuffer使用例子</span><br><span class="hljs-keyword">float</span> data[] = &#123;<br>  <span class="hljs-number">0.5f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">-0.35f</span><br>  ...<br>&#125;;<br>glBindBuffer(GL_ARRAY_BUFFER, buffer);<br><span class="hljs-comment">// 获取指针</span><br><span class="hljs-keyword">void</span> *ptr = glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);<br><span class="hljs-comment">// 复制数据到内存</span><br><span class="hljs-built_in">memcpy</span>(ptr, data, <span class="hljs-keyword">sizeof</span>(data));<br><span class="hljs-comment">// 记得告诉OpenGL我们不再需要这个指针了</span><br>glUnmapBuffer(GL_ARRAY_BUFFER);<br></code></pre></td></tr></table></figure>
<h3 id="分批顶点属性"><a href="#分批顶点属性" class="headerlink" title="分批顶点属性"></a>分批顶点属性</h3><ul>
<li>通过使用glVertexAttribPointer，我们能够指定顶点数组缓冲内容的属性布局。</li>
<li>之前，我们将顶点的位置、法线、纹理坐标连续且交错的放在一起，即形如123123123123布局。而从文件中加载顶点数据的时候，你通常获取到的是一个位置数组、一个法线数组和/或一个纹理坐标数组。我们需要花点力气才能将这些数组转化为一个大的交错数据数组。</li>
<li>使用glVertexAttribPointer能将每一种属性类型的向量数据打包(Batch)为一个大的区块，而不是对它们进行交错储存，即形如111122223333。</li>
</ul>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">float</span> positions[] = &#123; ... &#125;;<br><span class="hljs-keyword">float</span> normals[] = &#123; ... &#125;;<br><span class="hljs-keyword">float</span> tex[] = &#123; ... &#125;;<br><span class="hljs-comment">// 填充缓冲</span><br>glBufferSubData(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(positions), &amp;positions);<br>glBufferSubData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(positions), <span class="hljs-keyword">sizeof</span>(normals), &amp;normals);<br>glBufferSubData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(positions) + <span class="hljs-keyword">sizeof</span>(normals), <span class="hljs-keyword">sizeof</span>(tex), &amp;tex);<br><br><span class="hljs-comment">// 更新顶点属性指针</span><br>glVertexAttribPointer(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), <span class="hljs-number">0</span>);  <br>glVertexAttribPointer(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">3</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)(<span class="hljs-keyword">sizeof</span>(positions)));  <br>glVertexAttribPointer(<br>  <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)(<span class="hljs-keyword">sizeof</span>(positions) + <span class="hljs-keyword">sizeof</span>(normals)));<br></code></pre></td></tr></table></figure>
<h3 id="复制缓冲"><a href="#复制缓冲" class="headerlink" title="复制缓冲"></a>复制缓冲</h3><ul>
<li><p>glCopyBufferSubData能够让我们相对容易地从一个缓冲中复制数据到另一个缓冲中。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数原型</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">glCopyBufferSubData</span><span class="hljs-params">(<br>  GLenum readtarget, <span class="hljs-comment">// 复制源</span><br>  GLenum writetarget, <span class="hljs-comment">// 复制目标的缓冲目标</span><br>  GLintptr readoffset, <span class="hljs-comment">// 读偏移</span><br>  GLintptr writeoffset, <span class="hljs-comment">// 写偏移</span><br>  GLsizeiptr size  <span class="hljs-comment">// 读取数据的大小</span><br>)</span></span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p>我们可以将VERTEX_ARRAY_BUFFER缓冲复制到VERTEX_ELEMENT_ARRAY_BUFFER缓冲，分别将这些缓冲目标设置为读和写的目标。当前绑定到这些缓冲目标的缓冲将会被影响到。</p>
</li>
<li>如果读写的两个缓冲均为同类型的缓冲（如，均为顶点数组缓冲），由于不能将两个缓冲绑定至同一个缓冲目标上，故OpenGL提供了GL_COPY_READ_BUFFER和GL_COPY_WRITE_BUFFER这两个缓冲目标。</li>
<li>使用方式如下：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">float</span> vertexData[] = &#123; ... &#125;;<br>glBindBuffer(GL_COPY_READ_BUFFER, vbo1);<br>glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);<br>glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vertexData));<br><br><span class="hljs-comment">// 只将writetarget缓冲绑定为新的缓冲目标类型之一</span><br><span class="hljs-keyword">float</span> vertexData[] = &#123; ... &#125;;<br>glBindBuffer(GL_ARRAY_BUFFER, vbo1);<br>glBindBuffer(GL_COPY_WRITE_BUFFER, vbo2);<br>glCopyBufferSubData(GL_ARRAY_BUFFER, GL_COPY_WRITE_BUFFER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(vertexData));<br></code></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="高级GLSL-Advanced-GLSL"><a href="#高级GLSL-Advanced-GLSL" class="headerlink" title="高级GLSL(Advanced GLSL)"></a>高级GLSL(Advanced GLSL)</h2><h3 id="GLSL的内建变量"><a href="#GLSL的内建变量" class="headerlink" title="GLSL的内建变量"></a>GLSL的内建变量</h3><h4 id="顶点着色器变量"><a href="#顶点着色器变量" class="headerlink" title="顶点着色器变量"></a>顶点着色器变量</h4><h5 id="gl-PointSize（输出变量）"><a href="#gl-PointSize（输出变量）" class="headerlink" title="gl_PointSize（输出变量）"></a>gl_PointSize（输出变量）</h5><ul>
<li>当图元选择为GL_POINTS时，我们可以通过glPointSize函数来设置渲染出来的点的大小，也可以在顶点着色器中修改这个值。</li>
<li>GLSL定义了一个叫做gl_PointSize输出变量，它是一个float变量，你可以使用它来设置点的宽高（像素）。在顶点着色器中修改点的大小的话，你就能对每个顶点设置不同的值了。</li>
<li>在顶点着色器中修改点大小的功能默认是禁用的，如果你需要启用它的话，你需要启用OpenGL的GL_PROGRAM_POINT_SIZE。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glEnable(GL_PROGRAM_POINT_SIZE);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// 顶点着色器</span><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-built_in">gl_PointSize</span> = <span class="hljs-built_in">gl_Position</span>.z;  <span class="hljs-comment">// 点的大小会随着观察者距顶点距离变远而增大。</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="gl-VertexID（输入变量）"><a href="#gl-VertexID（输入变量）" class="headerlink" title="gl_VertexID（输入变量）"></a>gl_VertexID（输入变量）</h5><ul>
<li>gl_Position和gl_PointSize都是输出变量，因为它们的值是作为顶点着色器的输出被读取的。我们可以对它们进行写入，来改变结果。顶点着色器提供了一个输入变量gl_VertexID，该只能对它进行读取。</li>
<li>整型变量gl_VertexID储存了正在绘制顶点的当前ID。当（使用glDrawElements）进行索引渲染的时候，这个变量会存储正在绘制顶点的当前索引。当（使用glDrawArrays）不使用索引进行绘制的时候，这个变量会储存从渲染调用开始的已处理顶点数量。</li>
</ul>
<h4 id="片段着色器变量"><a href="#片段着色器变量" class="headerlink" title="片段着色器变量"></a>片段着色器变量</h4><h5 id="gl-FragCoord（输入变量）"><a href="#gl-FragCoord（输入变量）" class="headerlink" title="gl_FragCoord（输入变量）"></a>gl_FragCoord（输入变量）</h5><ul>
<li>gl_FragCoord的z分量等于对应片段的深度值。也能使用它的x和y分量来实现一些有趣的效果。</li>
<li>gl_FragCoord的x和y分量是片段的窗口空间(Window-space)坐标，其原点为窗口的左下角。我们已经使用glViewport设定了一个800x600的窗口了，所以片段窗口空间坐标的x分量将在0到800之间，y分量在0到600之间。</li>
<li>通过利用片段着色器，我们可以根据片段的窗口坐标，计算出不同的颜色。gl_FragCoord的一个常见用处是用于对比不同片段计算的视觉输出效果，这在技术演示中可以经常看到。比如说，我们能够将屏幕分成两部分，在窗口的左侧渲染一种输出，在窗口的右侧渲染另一种输出。下面这个例子片段着色器会根据窗口坐标输出不同的颜色：<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-type">void</span> main()<br>&#123;             <br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gl_FragCoord</span>.x &lt; <span class="hljs-number">400</span>)<br>        FragColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-keyword">else</span><br>        FragColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);        <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="gl-FrontFacing（输入变量）"><a href="#gl-FrontFacing（输入变量）" class="headerlink" title="gl_FrontFacing（输入变量）"></a>gl_FrontFacing（输入变量）</h5><ul>
<li>如果我们不（启用GL_FACE_CULL来）使用面剔除，那么gl_FrontFacing将会告诉我们当前片段是属于正向面的一部分还是背向面的一部分。</li>
<li><p>gl_FrontFacing变量是一个bool，如果当前片段是正向面的一部分那么就是true，否则就是false。</p>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> TexCoords;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> frontTexture;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> backTexture;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// 立方体内部和外部使用不同的纹理</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">gl_FrontFacing</span>)<br>        FragColor = <span class="hljs-built_in">texture</span>(frontTexture, TexCoords);<br>    <span class="hljs-keyword">else</span><br>        FragColor = <span class="hljs-built_in">texture</span>(backTexture, TexCoords);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><img src="/2019/02/09/高级OpenGL（下）/advanced_glsl_frontfacing.png" alt="立方体内部和外部使用不同的纹理"></p>
</li>
</ul>
<h5 id="gl-FragDepth（输出变量）"><a href="#gl-FragDepth（输出变量）" class="headerlink" title="gl_FragDepth（输出变量）"></a>gl_FragDepth（输出变量）</h5><ul>
<li>输入变量gl_FragCoord能让我们读取当前片段的窗口空间坐标，并获取它的深度值，但是它是一个只读(Read-only)变量。我们不能修改片段的窗口空间坐标，但OpenGL提供了名为gl_FragDepth的输出变量，我们可以通过他修改片段的深度值。</li>
<li><p>要想设置深度值，我们直接写入一个0.0到1.0之间的float值到输出变量就可以了，如果着色器没有写入值到gl_FragDepth，它会自动取用gl_FragCoord.z的值。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gl_FragDepth = <span class="hljs-number">0.0</span>; <span class="hljs-comment">// 这个片段现在的深度值为 0.0</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>由自己设置深度值有一个很大的缺点，只要我们在片段着色器中对gl_FragDepth进行写入，OpenGL就会禁用所有的提前深度测试(Early Depth Testing)。</p>
</li>
<li>从OpenGL 4.2起，我们仍可以对两者进行一定的调和，在片段着色器的顶部使用深度条件(Depth Condition)重新声明gl_FragDepth变量：<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span> (depth_&lt;condition&gt;) <span class="hljs-keyword">out</span> <span class="hljs-type">float</span> <span class="hljs-built_in">gl_FragDepth</span>;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>condition可以为下面的值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>条件</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>any</td>
<td>默认值。提前深度测试是禁用的，你会损失很多性能</td>
</tr>
<tr>
<td>greater</td>
<td>你只能让深度值比gl_FragCoord.z更大</td>
</tr>
<tr>
<td>less</td>
<td>你只能让深度值比gl_FragCoord.z更小</td>
</tr>
<tr>
<td>unchanged</td>
<td>如果你要写入gl_FragDepth，你将只能写入gl_FragCoord.z的值</td>
</tr>
</tbody>
</table>
</div>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 420 core // 注意GLSL的版本！</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><span class="hljs-comment">// 片段的深度值进行了递增，但仍然也保留了一些提前深度测试</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">depth_greater</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">float</span> <span class="hljs-built_in">gl_FragDepth</span>;<br><br><span class="hljs-type">void</span> main()<br>&#123;             <br>    FragColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>);<br>    <span class="hljs-built_in">gl_FragDepth</span> = <span class="hljs-built_in">gl_FragCoord</span>.z + <span class="hljs-number">0.1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="接口块"><a href="#接口块" class="headerlink" title="接口块"></a>接口块</h3><ul>
<li>GLSL提供了一个叫做接口块(Interface Block)的东西，来方便组合变量。接口块的声明和struct的声明有点相像，不同的是，现在根据它是一个输入还是输出块(Block)，使用in或out关键字来定义的。</li>
</ul>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoords;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><br><span class="hljs-comment">// 块名（VS_OUT），需要与片段着色器中保持一致</span><br><span class="hljs-comment">// 实例名（vs_out）可以随意修改。</span><br><span class="hljs-keyword">out</span> VS_OUT<br>&#123;<br>    <span class="hljs-type">vec2</span> TexCoords;<br>&#125; vs_out;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);    <br>    vs_out.TexCoords = aTexCoords;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-comment">// 块名（VS_OUT），需要与顶点着色器中保持一致</span><br><span class="hljs-comment">// 实例名（vs_out）可以随意修改。</span><br><span class="hljs-keyword">in</span> VS_OUT<br>&#123;<br>    <span class="hljs-type">vec2</span> TexCoords;<br>&#125; fs_in;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> <span class="hljs-built_in">texture</span>;<br><br><span class="hljs-type">void</span> main()<br>&#123;             <br>    FragColor = <span class="hljs-built_in">texture</span>(<span class="hljs-built_in">texture</span>, fs_in.TexCoords);   <br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>接口块，打包了我们希望发送到下一个着色器中的所有输出变量。</li>
<li>只要两个接口块的名字一样，它们对应的输入和输出将会匹配起来。</li>
</ul>
<h3 id="Uniform缓冲对象"><a href="#Uniform缓冲对象" class="headerlink" title="Uniform缓冲对象"></a>Uniform缓冲对象</h3><ul>
<li>OpenGL为我们提供了一个叫做Uniform缓冲对象(Uniform Buffer Object)的工具，它允许我们定义一系列在多个着色器中相同的全局Uniform变量。当使用Uniform缓冲对象的时候，我们只需要设置相关的uniform一次。当然，我们仍需要手动设置每个着色器中不同的uniform。并且创建和配置Uniform缓冲对象会有一点繁琐。</li>
</ul>
<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li>因为Uniform缓冲对象仍是一个缓冲，我们可以使用glGenBuffers来创建它，将它绑定到GL_UNIFORM_BUFFER缓冲目标，并将所有相关的uniform数据存入缓冲。<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><br><span class="hljs-comment">// 声明了一个叫做Matrices的Uniform块，它储存了两个4x4矩阵。</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std140</span>) <span class="hljs-keyword">uniform</span> Matrices<br>&#123;<br>    <span class="hljs-type">mat4</span> projection;<br>    <span class="hljs-type">mat4</span> view;<br>&#125;;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-comment">// Uniform块中的变量可以直接访问，不需要加块名作为前缀。</span><br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Uniform块布局"><a href="#Uniform块布局" class="headerlink" title="Uniform块布局"></a>Uniform块布局</h4><ul>
<li>Uniform块的内容是储存在一个缓冲对象中的，它实际上只是一块预留内存。因为这块内存并不会保存它具体保存的是什么类型的数据，我们还需要告诉OpenGL内存的哪一部分对应着着色器中的哪一个uniform变量。</li>
<li>我们需要知道的是每个变量的大小（字节）和（从块起始位置的）偏移量，来让我们能够按顺序将它们放进缓冲中。每个元素的大小都是在OpenGL中有清楚地声明的，而且直接对应C++数据类型，其中向量和矩阵都是大的float数组。OpenGL没有声明的是这些变量间的间距(Spacing)。这允许硬件能够在它认为合适的位置放置变量。比如说，一些硬件可能会将一个vec3放置在float边上。不是所有的硬件都能这样处理，可能会在附加这个float之前，先将vec3填充(Pad)为一个4个float的数组。</li>
<li><p>以以下的Uniform块为例：</p>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std140</span>) <span class="hljs-keyword">uniform</span> ExampleBlock<br>&#123;<br>    <span class="hljs-type">float</span> value;<br>    <span class="hljs-type">vec3</span>  vector;<br>    <span class="hljs-type">mat4</span>  matrix;<br>    <span class="hljs-type">float</span> values[<span class="hljs-number">3</span>];<br>    <span class="hljs-type">bool</span>  boolean;<br>    <span class="hljs-type">int</span>   integer;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Uniform的内存布局有三种，默认情况下的共享(Shared)布局，显式声明每个变量类型布局的std140布局，不能在每个程序中保持不变（非共享）的紧凑(Packed)布局。</p>
</li>
</ul>
<h5 id="共享-Shared-布局"><a href="#共享-Shared-布局" class="headerlink" title="共享(Shared)布局"></a>共享(Shared)布局</h5><ul>
<li>默认情况下，GLSL会使用一个叫做共享(Shared)布局的Uniform内存布局，共享是因为一旦硬件定义了偏移量，它们在多个程序中是共享并一致的。</li>
<li>使用共享布局时，GLSL是可以为了优化而对uniform变量的位置进行变动的，只要变量的顺序保持不变。</li>
<li>需要使用glGetUniformIndices来获得每个uniform变量的偏移量，从而才能准确地填充Uniform缓冲。</li>
</ul>
<h5 id="std140布局"><a href="#std140布局" class="headerlink" title="std140布局"></a>std140布局</h5><ul>
<li>虽然共享布局给了我们很多节省空间的优化，但是我们需要查询每个uniform变量的偏移量，这会产生非常多的工作量。通常的做法是，不使用共享布局，而是使用std140布局。std140布局声明了每个变量的偏移量都是由一系列规则所决定的，这显式地声明了每个变量类型的内存布局。由于这是显式提及的，我们可以手动计算出每个变量的偏移量。</li>
<li>每个变量都有一个基准对齐量(Base Alignment)，它等于一个变量在Uniform块中所占据的空间（包括填充量(Padding)），这个基准对齐量是使用std140布局的规则计算出来的。接下来，对每个变量，我们再计算它的对齐偏移量(Aligned Offset)，它是一个变量从块起始位置的字节偏移量。一个变量的对齐字节偏移量必须等于基准对齐量的倍数。</li>
<li>GLSL中的每个变量，比如说int、float和bool，都被定义为4字节量。每4个字节将会用一个N来表示。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>布局规则</th>
</tr>
</thead>
<tbody>
<tr>
<td>标量，比如int和bool</td>
<td>每个标量的基准对齐量为N。</td>
</tr>
<tr>
<td>向量</td>
<td>2N或者4N。这意味着vec3的基准对齐量为4N。</td>
</tr>
<tr>
<td>标量或向量的数组</td>
<td>每个元素的基准对齐量与vec4的相同。</td>
</tr>
<tr>
<td>矩阵</td>
<td>储存为列向量的数组，每个向量的基准对齐量与vec4的相同。</td>
</tr>
<tr>
<td>结构体</td>
<td>等于所有元素根据规则计算后的大小，但会填充到vec4大小的倍数。</td>
</tr>
</tbody>
</table>
</div>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std140</span>) <span class="hljs-keyword">uniform</span> ExampleBlock<br>&#123;<br>                     <span class="hljs-comment">// 基准对齐量       // 对齐偏移量</span><br>    <span class="hljs-type">float</span> value;     <span class="hljs-comment">// 4               // 0</span><br>    <span class="hljs-type">vec3</span> vector;     <span class="hljs-comment">// 16              // 16  (必须是16的倍数，所以 4-&gt;16)</span><br>    <span class="hljs-type">mat4</span> matrix;     <span class="hljs-comment">// 16              // 32  (列 0)</span><br>                     <span class="hljs-comment">// 16              // 48  (列 1)</span><br>                     <span class="hljs-comment">// 16              // 64  (列 2)</span><br>                     <span class="hljs-comment">// 16              // 80  (列 3)</span><br>    <span class="hljs-type">float</span> values[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 16              // 96  (values[0])</span><br>                     <span class="hljs-comment">// 16              // 112 (values[1])</span><br>                     <span class="hljs-comment">// 16              // 128 (values[2])</span><br>    <span class="hljs-type">bool</span> boolean;    <span class="hljs-comment">// 4               // 144</span><br>    <span class="hljs-type">int</span> integer;     <span class="hljs-comment">// 4               // 148 (必须是4的倍数)</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<ul>
<li>使用计算后的偏移量值，根据std140布局的规则，我们就能使用像是glBufferSubData的函数将变量数据按照偏移量填充进缓冲中了。虽然std140布局不是最高效的布局，但它保证了内存布局在每个声明了这个Uniform块的程序中是一致的。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 更新uniform变量boolean</span><br>glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);<br><span class="hljs-keyword">int</span> b = <span class="hljs-literal">true</span>; <span class="hljs-comment">// GLSL中的bool是4字节的，所以我们将它存为一个integer</span><br>glBufferSubData(GL_UNIFORM_BUFFER, <span class="hljs-number">144</span>, <span class="hljs-number">4</span>, &amp;b);<br>glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="紧凑-Packed-布局"><a href="#紧凑-Packed-布局" class="headerlink" title="紧凑(Packed)布局"></a>紧凑(Packed)布局</h5><ul>
<li>不能保证这个布局在每个程序中保持不变的（即非共享），因为它允许编译器去将uniform变量从Uniform块中优化掉，这在每个着色器中都可能是不同的。</li>
</ul>
<h4 id="使用Uniform缓冲"><a href="#使用Uniform缓冲" class="headerlink" title="使用Uniform缓冲"></a>使用Uniform缓冲</h4><ul>
<li><p>调用glGenBuffers，创建一个Uniform缓冲对象。再将缓冲对象绑定到GL_UNIFORM_BUFFER目标，最后调用glBufferData，分配足够的内存。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uboExampleBlock;<br>glGenBuffers(<span class="hljs-number">1</span>, &amp;uboExampleBlock);<br>glBindBuffer(GL_UNIFORM_BUFFER, uboExampleBlock);<br>glBufferData(GL_UNIFORM_BUFFER, <span class="hljs-number">152</span>, <span class="hljs-literal">NULL</span>, GL_STATIC_DRAW); <span class="hljs-comment">// 分配152字节的内存</span><br>glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>在OpenGL上下文中，定义了一些绑定点(Binding Point)，我们可以将一个Uniform缓冲链接至它。在创建Uniform缓冲之后，我们将它绑定到其中一个绑定点上，并将着色器中的Uniform块绑定到相同的绑定点，把它们连接到一起。</p>
</li>
<li><img src="/2019/02/09/高级OpenGL（下）/advanced_glsl_binding_points.png" alt="绑定点"></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>glUniformBlockBinding</td>
<td>将Uniform块绑定到一个特定的绑定点中，它的第一个参数是一个 <em>程序对象</em> ，之后是一个 <em>Uniform块索引</em> 和 <em>链接到的绑定点</em> 。</td>
</tr>
<tr>
<td>glGetUniformBlockIndex</td>
<td>获取Uniform块索引(Uniform Block Index)使用，接受一个程序对象和Uniform块的名称。</td>
</tr>
<tr>
<td>glBindBufferBase</td>
<td>所需参数为 目标，绑定点索引，Uniform缓冲对象。</td>
</tr>
<tr>
<td>glBindBufferRange</td>
<td>所需参数为 目标，绑定点索引，Uniform缓冲对象，附加偏移量，大小。使用glBindBufferRange函数，你可以让多个不同的Uniform块绑定到同一个Uniform缓冲对象上。</td>
</tr>
</tbody>
</table>
</div>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 获取shaderA中名为Lights的Uniform块索引，将绑定到2号绑定点中。</span><br><span class="hljs-comment">// 需要注意对每个着色器重复这一步骤。</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> lights_index = glGetUniformBlockIndex(shaderA.ID, <span class="hljs-string">"Lights"</span>);   <br>glUniformBlockBinding(shaderA.ID, lights_index, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">从OpenGL <span class="hljs-number">4.2</span>版本起，<br>可以添加一个布局标识符，<br>显式地将Uniform块的绑定点储存在着色器中，<br>下面的代码显式地设置了Lights Uniform块的绑定点。<br><br>layout(std140, binding = <span class="hljs-number">2</span>) uniform Lights &#123; ... &#125;;<br></code></pre></td></tr></table></figure>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 函数将uboExampleBlock链接到绑定点2</span><br>glBindBufferBase(GL_UNIFORM_BUFFER, <span class="hljs-number">2</span>, uboExampleBlock);<br><span class="hljs-comment">// 或</span><br>glBindBufferRange(GL_UNIFORM_BUFFER, <span class="hljs-number">2</span>, uboExampleBlock, <span class="hljs-number">0</span>, <span class="hljs-number">152</span>);<br></code></pre></td></tr></table></figure>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>将投影和模型矩阵存储到一个叫做Matrices的Uniform块中，用四个shader分别绘制立方体。</li>
<li>四个shader公用同一个份顶点着色器代码。</li>
</ul>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">std140</span>) <span class="hljs-keyword">uniform</span> Matrices<br>&#123;<br>    <span class="hljs-type">mat4</span> projection;<br>    <span class="hljs-type">mat4</span> view;<br>&#125;;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 需要对每个shader都做一次，将顶点着色器的Uniform块设置为绑定点0</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uniformBlockIndexRed = glGetUniformBlockIndex(shaderRed.ID, <span class="hljs-string">"Matrices"</span>);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uniformBlockIndexGreen = glGetUniformBlockIndex(shaderGreen.ID, <span class="hljs-string">"Matrices"</span>);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uniformBlockIndexBlue = glGetUniformBlockIndex(shaderBlue.ID, <span class="hljs-string">"Matrices"</span>);<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uniformBlockIndexYellow = glGetUniformBlockIndex(shaderYellow.ID, <span class="hljs-string">"Matrices"</span>);<br><br>glUniformBlockBinding(shaderRed.ID, uniformBlockIndexRed, <span class="hljs-number">0</span>);<br>glUniformBlockBinding(shaderGreen.ID, uniformBlockIndexGreen, <span class="hljs-number">0</span>);<br>glUniformBlockBinding(shaderBlue.ID, uniformBlockIndexBlue, <span class="hljs-number">0</span>);<br>glUniformBlockBinding(shaderYellow.ID, uniformBlockIndexYellow, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 创建Uniform缓冲对象</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> uboMatrices;<br>glGenBuffers(<span class="hljs-number">1</span>, &amp;uboMatrices);<br><br>glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);<br><span class="hljs-comment">// GLM矩阵类型的大小直接对应于GLSL中的mat4，其中会存储两个矩阵，故大小设置为2个mat4</span><br>glBufferData(GL_UNIFORM_BUFFER, <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(glm::mat4), <span class="hljs-literal">NULL</span>, GL_STATIC_DRAW);<br>glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 将Uniform缓冲对象链接到绑定点0</span><br>glBindBufferRange(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>, uboMatrices, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(glm::mat4));<br><br><span class="hljs-comment">// 将projection矩阵数据写入</span><br>glm::mat4 projection = glm::perspective(glm::radians(camera.Zoom), (<span class="hljs-keyword">float</span>)SCR_WIDTH / (<span class="hljs-keyword">float</span>)SCR_HEIGHT, <span class="hljs-number">0.1f</span>, <span class="hljs-number">100.0f</span>);<br>glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);<br>glBufferSubData(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(glm::mat4), glm::value_ptr(projection));<br>glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">while</span>(loop) &#123;<br>  ...<br>  <span class="hljs-comment">// 在loop中只需要更新一次view矩阵</span><br>  glm::mat4 view = camera.GetViewMatrix();<br>	glBindBuffer(GL_UNIFORM_BUFFER, uboMatrices);<br>	glBufferSubData(GL_UNIFORM_BUFFER, <span class="hljs-keyword">sizeof</span>(glm::mat4), <span class="hljs-keyword">sizeof</span>(glm::mat4), glm::value_ptr(view));<br>	glBindBuffer(GL_UNIFORM_BUFFER, <span class="hljs-number">0</span>);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><img src="/2019/02/09/高级OpenGL（下）/advanced_glsl_uniform_buffer_objects.png" alt="例子"></li>
</ul>
<hr>
<h2 id="几何着色器-Geometry-Shader"><a href="#几何着色器-Geometry-Shader" class="headerlink" title="几何着色器(Geometry Shader)"></a>几何着色器(Geometry Shader)</h2><ul>
<li><img src="/2019/02/09/高级OpenGL（下）/pipeline.png" alt="图形渲染管线"></li>
<li>在顶点和片段着色器之间有一个可选的几何着色器(Geometry Shader)，几何着色器的输入是一个图元（如点或三角形）的一组顶点。几何着色器可以在顶点发送到下一着色器阶段之前对它们随意变换，如生成更多的顶点或变成其他图元。</li>
</ul>
<h3 id="使用几何着色器"><a href="#使用几何着色器" class="headerlink" title="使用几何着色器"></a>使用几何着色器</h3><h4 id="几何着色器例子"><a href="#几何着色器例子" class="headerlink" title="几何着色器例子"></a>几何着色器例子</h4><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-comment">// 声明从顶点着色器输入的图元类型</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">points</span>) <span class="hljs-keyword">in</span>;<br><span class="hljs-comment">// 指定几何着色器输出的图元类型</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">triangle_strip</span>, <span class="hljs-keyword">max_vertices</span> = <span class="hljs-number">5</span>) <span class="hljs-keyword">out</span>;<br><br><span class="hljs-type">void</span> build_house(<span class="hljs-type">vec4</span> position)<br>&#123;    <br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>(<span class="hljs-number">-0.2</span>, <span class="hljs-number">-0.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 1:左下</span><br>    <span class="hljs-built_in">EmitVertex</span>();   <br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>( <span class="hljs-number">0.2</span>, <span class="hljs-number">-0.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 2:右下</span><br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>(<span class="hljs-number">-0.2</span>,  <span class="hljs-number">0.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 3:左上</span><br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>( <span class="hljs-number">0.2</span>,  <span class="hljs-number">0.2</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 4:右上</span><br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">gl_Position</span> = position + <span class="hljs-type">vec4</span>( <span class="hljs-number">0.0</span>,  <span class="hljs-number">0.4</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>);    <span class="hljs-comment">// 5:顶部</span><br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">EndPrimitive</span>();<br>&#125;<br><br><span class="hljs-type">void</span> main() &#123;    <br>    build_house(<span class="hljs-built_in">gl_in</span>[<span class="hljs-number">0</span>].<span class="hljs-built_in">gl_Position</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>从上面的例子中可以看到，几何着色器顶部需要声明从顶点着色器输入的图元类型，需要在 <font color="#D2691E" size="4"> <em>in</em> </font> 关键字前声明一个布局修饰符(Layout Qualifier)。这个输入布局修饰符可以从顶点着色器接收下列任何一个图元值：</li>
<li>提供给glDrawArrays渲染函数的几乎所有图元：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>shader中的输入图元</th>
<th>glDrawArrays中对应的图元</th>
<th>最小顶点数</th>
</tr>
</thead>
<tbody>
<tr>
<td>points</td>
<td>绘制GL_POINTS图元时</td>
<td>1</td>
</tr>
<tr>
<td>lines</td>
<td>绘制GL_LINES或GL_LINE_STRIP时</td>
<td>2</td>
</tr>
<tr>
<td>lines_adjacency</td>
<td>GL_LINES_ADJACENCY或GL_LINE_STRIP_ADJACENCY</td>
<td>4</td>
</tr>
<tr>
<td>triangles</td>
<td>GL_TRIANGLES、GL_TRIANGLE_STRIP或GL_TRIANGLE_FAN</td>
<td>3</td>
</tr>
<tr>
<td>triangles_adjacency</td>
<td>GL_TRIANGLES_ADJACENCY或GL_TRIANGLE_STRIP_ADJACENCY</td>
<td>6</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>同时，也需要指定几何着色器输出的图元类型，这需要在<font color="#D2691E" size="4"> <em>out</em> </font>关键字前面加一个布局修饰符，并设置一个它最大能够输出的顶点数量（如果你超过了这个值，OpenGL将不会绘制多出的顶点），上面的例子中设置了输出为triangle_strip且最大顶点数为5个。</li>
<li>输出布局修饰符可以接受的图元值：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>shader中的输出图元</th>
<th>含义</th>
<th>最小顶点数</th>
</tr>
</thead>
<tbody>
<tr>
<td>points</td>
<td>点</td>
<td>1</td>
</tr>
<tr>
<td>line_strip</td>
<td>按顺序连接所有给定点的一条线</td>
<td>2</td>
</tr>
<tr>
<td>triangle_strip</td>
<td>每3个临近的顶点将会形成一个三角形，如给出5个点，按(1, 2, 3)、(2, 3, 4)、(3, 4, 5)这样的分配来绘制3个三角形</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>例子往下看，在main函数中，通过内建变量gl_in来访问传入的图元，可以看出gl_in是一个数组，其内部实现类似于一个包含多个特征的结构体。</li>
</ul>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 内建变量gl_in的大概实现</span><br><span class="hljs-comment">// 其为一个接口块</span><br><span class="hljs-comment">// 其包含gl_Position位置信息，gl_PointSize大小信息</span><br><span class="hljs-comment">// gl_ClipDistance是为顶点裁剪提供了向前兼容所使用</span><br>in gl_Vertex<br>&#123;<br>    vec4  gl_Position;<br>    <span class="hljs-keyword">float</span> gl_PointSize;<br>    <span class="hljs-keyword">float</span> gl_ClipDistance[];<br>&#125; gl_in[];<br></code></pre></td></tr></table></figure>
<ul>
<li><p>查看main函数中调用的build_house函数，在每次对position进行位移之后，都调用了EmitVertex()函数，因为在调用了该函数后，gl_Position中的向量会被添加到图元中来；在函数最后调用了EndPrimitive()函数，这样所有发射出的(Emitted)顶点都会合成为指定的输出渲染图元。在一个或多个EmitVertex调用之后重复调用EndPrimitive能够生成多个图元。</p>
</li>
<li><p>至此，整段几何着色器的代码已解析完毕，其实现的功能便是接受一个点图元作为输入，以该点位中心，通过5次位移，生成5个新点，并将它们合成一个triangle_strip图元，该图元将会绘制3个三角形。</p>
</li>
</ul>
<h4 id="将例子显示"><a href="#将例子显示" class="headerlink" title="将例子显示"></a>将例子显示</h4><ul>
<li><p>出于简单考虑，顶点着色器和片段着色器都进行硬编码，写死一些数据即可。</p>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// vs</span><br><span class="hljs-meta">#version 330 core</span><br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>&#125;<br><br><span class="hljs-comment">// fs</span><br><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> FragColor;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    FragColor = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);   <br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>对于几何着色器，我们也需要进行编译和连接，其传入的着色器类型为<font color="#D2691E" size="4"> <em>GL_GEOMETRY_SHADER</em> </font></p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">geometryShader = glCreateShader(GL_GEOMETRY_SHADER);<br>glShaderSource(geometryShader, <span class="hljs-number">1</span>, &amp;gShaderCode, <span class="hljs-literal">NULL</span>);<br>glCompileShader(geometryShader);  <br>...<br>glAttachShader(program, geometryShader);<br>glLinkProgram(program);<br></code></pre></td></tr></table></figure>
</li>
<li><p><img src="/2019/02/09/高级OpenGL（下）/geometry_sample.png" alt="效果显示"></p>
</li>
</ul>
<h3 id="爆破物体"><a href="#爆破物体" class="headerlink" title="爆破物体"></a>爆破物体</h3><ul>
<li>将物体的每个图元向法线方向进行小量位移，我们可以轻易得到类似物体爆破的效果。几何着色器提供了让我们访问及操作图元的可能，通过几何着色器，我们便可以实现爆破效果。</li>
<li><img src="/2019/02/09/高级OpenGL（下）/geometry_explode.png" alt="效果显示"></li>
</ul>
<h3 id="法向量可视化"><a href="#法向量可视化" class="headerlink" title="法向量可视化"></a>法向量可视化</h3><ul>
<li>首先不使用几何着色器正常绘制场景。然后再次绘制场景，但这次只显示通过几何着色器生成法向量。几何着色器接收一个三角形图元，并沿着法向量生成三条线——每个顶点一个法向量。</li>
<li><p>伪代码：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">shader.use();<br>DrawScene();<br>normalDisplayShader.use();<br>DrawScene();<br></code></pre></td></tr></table></figure>
</li>
<li><p>几何着色器接受的位置向量是剪裁空间坐标，所以需要将法向量变换到相同的空间中，这一步可以在顶点着色器中完成。</p>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aNormal;<br><br><span class="hljs-keyword">out</span> VS_OUT &#123;<br>    <span class="hljs-type">vec3</span> normal;<br>&#125; vs_out;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> model;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * model * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>    <span class="hljs-type">mat3</span> normalMatrix = <span class="hljs-type">mat3</span>(<span class="hljs-built_in">transpose</span>(<span class="hljs-built_in">inverse</span>(view * model)));<br>    vs_out.normal = <span class="hljs-built_in">normalize</span>(<span class="hljs-type">vec3</span>(projection * <span class="hljs-type">vec4</span>(normalMatrix * aNormal, <span class="hljs-number">0.0</span>)));<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">triangles</span>) <span class="hljs-keyword">in</span>;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">line_strip</span>, <span class="hljs-keyword">max_vertices</span> = <span class="hljs-number">6</span>) <span class="hljs-keyword">out</span>;<br><br><span class="hljs-keyword">in</span> VS_OUT &#123;<br>    <span class="hljs-type">vec3</span> normal;<br>&#125; gs_in[];<br><br><span class="hljs-keyword">const</span> <span class="hljs-type">float</span> MAGNITUDE = <span class="hljs-number">0.4</span>;<br><br><span class="hljs-type">void</span> GenerateLine(<span class="hljs-type">int</span> <span class="hljs-keyword">index</span>)<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">gl_in</span>[<span class="hljs-keyword">index</span>].<span class="hljs-built_in">gl_Position</span>;<br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">gl_in</span>[<span class="hljs-keyword">index</span>].<span class="hljs-built_in">gl_Position</span> + <span class="hljs-type">vec4</span>(gs_in[<span class="hljs-keyword">index</span>].normal, <span class="hljs-number">0.0</span>) * MAGNITUDE;<br>    <span class="hljs-built_in">EmitVertex</span>();<br>    <span class="hljs-built_in">EndPrimitive</span>();<br>&#125;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    GenerateLine(<span class="hljs-number">0</span>); <span class="hljs-comment">// 第一个顶点法线</span><br>    GenerateLine(<span class="hljs-number">1</span>); <span class="hljs-comment">// 第二个顶点法线</span><br>    GenerateLine(<span class="hljs-number">2</span>); <span class="hljs-comment">// 第三个顶点法线</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>从模型内部往外看，可以看到每个顶点的法线均被显示出来。</li>
<li><img src="/2019/02/09/高级OpenGL（下）/geometry_shownormal.png" alt="效果显示"></li>
</ul>
<hr>
<h2 id="实例化-Instancing"><a href="#实例化-Instancing" class="headerlink" title="实例化(Instancing)"></a>实例化(Instancing)</h2><ul>
<li>对于要绘制很多相同模型的场景，过去我们使用的方式是要创建多少个实例则调用多少次glDrawArrays或glDrawElements，这种做法十分消耗性能。</li>
<li>使用glDrawArrays或glDrawElements函数告诉GPU去绘制你的顶点数据会消耗更多的性能，因为OpenGL在绘制顶点数据之前需要做很多准备工作（比如告诉GPU该从哪个缓冲读取数据，从哪寻找顶点属性，而且这些都是在相对缓慢的CPU到GPU总线(CPU to GPU Bus)上进行的）。所以，即便渲染顶点非常快，命令GPU去渲染却未必。</li>
<li>如果模型都是使用同一份顶点数据，只是进行了不同的世界空间转换，我们可以将数据一次性发送给GPU，然后使用一个绘制函数让OpenGL利用这些数据绘制多个物体，这就是<font color="#D2691E" size="5"> <em>实例化</em> </font>。</li>
<li>实例化这项技术能够让我们使用一个渲染调用来绘制多个物体，来节省每次绘制物体时CPU -&gt; GPU的通信，它只需要一次即可。</li>
</ul>
<h3 id="glDrawArraysInstanced和glDrawElementsInstanced"><a href="#glDrawArraysInstanced和glDrawElementsInstanced" class="headerlink" title="glDrawArraysInstanced和glDrawElementsInstanced"></a>glDrawArraysInstanced和glDrawElementsInstanced</h3><ul>
<li>glDrawArraysInstanced和glDrawElementsInstanced分别对应glDrawArrays和glDrawElements，相比只是多了一个叫做实例数量(Instance Count)的参数，它能够设置我们需要渲染的实例个数。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glBindVertexArray(quadVAO);<br>glDrawArraysInstanced(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="gl-InstanceID"><a href="#gl-InstanceID" class="headerlink" title="gl_InstanceID"></a>gl_InstanceID</h3><ul>
<li>在使用实例化渲染调用时，gl_InstanceID会从0开始，在每个实例被渲染时递增1。</li>
<li>使用实例化渲染函数进行物体渲染后，物体会集中在同一个位置，并没有太大用处，通过gl_InstanceID，我们可以得知当前正在渲染哪个实例，从而在shader中进行针对性处理。</li>
<li><p>利用gl_InstanceID对方形进行缩小及获得位置偏移量：</p>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aColor;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fColor;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">vec2</span> offsets[<span class="hljs-number">100</span>];<br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-type">vec2</span> pos = aPos * (<span class="hljs-built_in">gl_InstanceID</span> / <span class="hljs-number">100.0</span>);<br>    <span class="hljs-type">vec2</span> <span class="hljs-keyword">offset</span> = offsets[<span class="hljs-built_in">gl_InstanceID</span>];<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(pos + <span class="hljs-keyword">offset</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fColor = aColor;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><img src="/2019/02/09/高级OpenGL（下）/instancing_InstanceID.png" alt="利用gl_InstanceID对方形进行缩小"></p>
</li>
</ul>
<h3 id="实例化数组-Instanced-Array"><a href="#实例化数组-Instanced-Array" class="headerlink" title="实例化数组(Instanced Array)"></a>实例化数组(Instanced Array)</h3><ul>
<li>使用uniform数组来获取每个实例位置的方式能力终究有限，当实例数量远超100的时候，发送至着色器的uniform数据大小将会超过上限。</li>
<li>实例化数组(Instanced Array)能够有效解决传输数据过大的问题。它被定义为一个顶点属性（能够让我们储存更多的数据），仅在顶点着色器渲染一个新的实例时才会更新。</li>
<li><p>将位置偏移量改为使用实例化数组来实现：</p>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aColor;<br><span class="hljs-comment">// 实例化数组</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aOffset;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec3</span> fColor;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-type">vec2</span> pos = aPos * (<span class="hljs-built_in">gl_InstanceID</span> / <span class="hljs-number">100.0</span>);<br>    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-type">vec4</span>(pos + aOffset, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);<br>    fColor = aColor;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>实例化数组的配置方式：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> instanceVBO;<br>glGenBuffers(<span class="hljs-number">1</span>, &amp;instanceVBO);<br>glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);<br>glBufferData(GL_ARRAY_BUFFER, <span class="hljs-keyword">sizeof</span>(glm::vec2) * <span class="hljs-number">100</span>, &amp;translations[<span class="hljs-number">0</span>], GL_STATIC_DRAW);<br>glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<br>glEnableVertexAttribArray(<span class="hljs-number">2</span>);<br>glBindBuffer(GL_ARRAY_BUFFER, instanceVBO);<br>glVertexAttribPointer(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">2</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">float</span>), (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);<br>glBindBuffer(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 告诉OpenGL什么时候更新顶点属性的内容至新一组数据</span><br>glVertexAttribDivisor(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>上面代码最后一处的<font color="#D2691E" size="4"> <em>glVertexAttribDivisor</em> </font>用于告知OpenGL合适更新顶点属性数据。其接受两个参数，第一个参数是顶点属性，在上面的例子中位置偏移量的顶点属性值是2；第二个参数是属性除数，即告知OpenGL每隔多少个实例更新一次顶点数据，默认值为0，表示不刷新，现在传1，表示每渲染一个新实例后便更新顶点属性。</p>
</li>
</ul>
<h3 id="使用实例化绘制小行星带"><a href="#使用实例化绘制小行星带" class="headerlink" title="使用实例化绘制小行星带"></a>使用实例化绘制小行星带</h3><ul>
<li>小行星带中含有成千上万的小陨石，是使用实例化的较好例子。</li>
<li><p>我们使用实例化数组来存放陨石位置，其对应的顶点着色器代码如下：</p>
<figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 330 core</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> aPos;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> aTexCoords;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">mat4</span> instanceMatrix;<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> TexCoords;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> projection;<br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> view;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>    <span class="hljs-built_in">gl_Position</span> = projection * view * instanceMatrix * <span class="hljs-type">vec4</span>(aPos, <span class="hljs-number">1.0</span>);<br>    TexCoords = aTexCoords;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>对于陨石模型的每个网格，我们需要通过glVertexAttribDivisor设置每渲染一个物体则更新数据，在Loop中使用glDrawElementsInstanced绘制多个陨石。</p>
</li>
<li><p>现在我们改为使用mat4的顶点属性来存储model矩阵。然而，当我们顶点属性的类型大于vec4时，就要多进行一步处理了。顶点属性最大允许的数据大小等于一个vec4。因为一个mat4本质上是4个vec4，我们需要为这个矩阵预留4个顶点属性。因为我们将它的位置值设置为3，矩阵每一列的顶点属性位置值就是3、4、5和6。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 顶点缓冲对象</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> buffer;<br>glGenBuffers(<span class="hljs-number">1</span>, &amp;buffer);<br>glBindBuffer(GL_ARRAY_BUFFER, buffer);<br>glBufferData(GL_ARRAY_BUFFER, amount * <span class="hljs-keyword">sizeof</span>(glm::mat4), &amp;modelMatrices[<span class="hljs-number">0</span>], GL_STATIC_DRAW);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rock.meshes.size(); i++)<br>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> VAO = rock.meshes[i].VAO;<br>    glBindVertexArray(VAO);<br>    <span class="hljs-comment">// 顶点属性</span><br>    GLsizei vec4Size = <span class="hljs-keyword">sizeof</span>(glm::vec4);<br>    glEnableVertexAttribArray(<span class="hljs-number">3</span>);<br>    glVertexAttribPointer(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">4</span> * vec4Size, (<span class="hljs-keyword">void</span>*)<span class="hljs-number">0</span>);<br>    glEnableVertexAttribArray(<span class="hljs-number">4</span>);<br>    glVertexAttribPointer(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">4</span> * vec4Size, (<span class="hljs-keyword">void</span>*)(vec4Size));<br>    glEnableVertexAttribArray(<span class="hljs-number">5</span>);<br>    glVertexAttribPointer(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">4</span> * vec4Size, (<span class="hljs-keyword">void</span>*)(<span class="hljs-number">2</span> * vec4Size));<br>    glEnableVertexAttribArray(<span class="hljs-number">6</span>);<br>    glVertexAttribPointer(<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, GL_FLOAT, GL_FALSE, <span class="hljs-number">4</span> * vec4Size, (<span class="hljs-keyword">void</span>*)(<span class="hljs-number">3</span> * vec4Size));<br><br>    glVertexAttribDivisor(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>    glVertexAttribDivisor(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>);<br>    glVertexAttribDivisor(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>);<br>    glVertexAttribDivisor(<span class="hljs-number">6</span>, <span class="hljs-number">1</span>);<br><br>    glBindVertexArray(<span class="hljs-number">0</span>);<br>&#125;<br><br>...<br><br><span class="hljs-comment">// 绘制小行星</span><br>instanceShader.use();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; rock.meshes.size(); i++)<br>&#123;<br>    glBindVertexArray(rock.meshes[i].VAO);<br>    glDrawElementsInstanced(<br>        GL_TRIANGLES, rock.meshes[i].indices.size(), GL_UNSIGNED_INT, <span class="hljs-number">0</span>, amount<br>    );<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><img src="/2019/02/09/高级OpenGL（下）/instancing_planet.png" alt="小行星带"></p>
</li>
</ul>
<hr>
<h2 id="抗锯齿-Anti-Aliasing"><a href="#抗锯齿-Anti-Aliasing" class="headerlink" title="抗锯齿(Anti Aliasing)"></a>抗锯齿(Anti Aliasing)</h2><ul>
<li>在绘制物体的过程中，由于某个具体像素点要么选择采样要么选择不采样，导致在高分辨率的情况下，其边缘会产生较严重的锯齿现象。</li>
<li>引用知乎文刀秋二的话来讲：“锯齿的来源是因为场景的定义在三维空间中是连续的，而最终显示的像素则是一个离散的二维数组。所以判断一个点到底没有被某个像素覆盖的时候单纯是一个“有”或者“没有”问题，丢失了连续性的信息，导致锯齿。”</li>
</ul>
<h3 id="锯齿产生原因"><a href="#锯齿产生原因" class="headerlink" title="锯齿产生原因"></a>锯齿产生原因</h3><ul>
<li><img src="/2019/02/09/高级OpenGL（下）/pipeline.png" alt="图形渲染管线"></li>
<li>物体边缘产生锯齿与光栅器将顶点数据转化为片段的方式有关，光栅器是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。</li>
<li><p>光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任意值，但片段不行，因为它们受限于你窗口的分辨率。顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段/屏幕坐标。</p>
</li>
<li><p><img src="/2019/02/09/高级OpenGL（下）/anti_aliasing_rasterization.png" alt="光栅化"></p>
</li>
<li>上图是渲染一个三角形光栅化的过程，左图中每个像素点中心都有一个采样点，当采样点处于三角形中时，该像素会生成一个片段。根据该方式得到的右图的片段，该片段也是最终渲染在屏幕上的效果，从此处可以看出锯齿产生的原因。</li>
</ul>
<h3 id="多重采样抗锯齿-Multisample-Anti-aliasing-MSAA"><a href="#多重采样抗锯齿-Multisample-Anti-aliasing-MSAA" class="headerlink" title="多重采样抗锯齿(Multisample Anti-aliasing, MSAA)"></a>多重采样抗锯齿(Multisample Anti-aliasing, MSAA)</h3><ul>
<li><img src="/2019/02/09/高级OpenGL（下）/anti_aliasing_sample_points.png" alt="多重采样"></li>
<li>由于仅通过对像素中心点是否在物体内来判断是否生成片段的方式容易出现锯齿，一个更好的方式是增加采样点，通过被物体所包含的采样点的数量来决定是否生成片段及片段的颜色缓冲大小。</li>
<li>右图是以特定图案排列的4个子采样点(Subsample)。我们将用这些子采样点来决定像素的遮盖度。颜色缓冲的大小会随着子采样点的增加而增加。</li>
<li><img src="/2019/02/09/高级OpenGL（下）/msaa.jpg" alt="MSAA工作方式"></li>
<li>MSAA的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只运行一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。</li>
</ul>
<h3 id="OpenGL中的MSAA"><a href="#OpenGL中的MSAA" class="headerlink" title="OpenGL中的MSAA"></a>OpenGL中的MSAA</h3><ul>
<li>使用MSAA需要一个能在每个像素中存储大于1个颜色值的颜色缓冲（因为多重采样需要我们为每个采样点都储存一个颜色）。所以，我们需要一个新的缓冲类型，来存储特定数量的多重采样样本，它叫做多重采样缓冲(Multisample Buffer)。</li>
<li><p>大多数的窗口系统都应该提供了一个多重采样缓冲，用以代替默认的颜色缓冲。在GLFW中，需要在创建窗口之前调用glfwWindowHint来设置包含多重采样的样本数量。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glfwWindowHint(GLFW_SAMPLES, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>在调用了上述接口后，再使用glfwCreateWindow创建渲染窗口时，每个屏幕坐标就会使用一个包含4个子采样点的颜色缓冲了。GLFW会自动创建一个每像素4个子采样点的深度和样本缓冲。这也意味着所有缓冲的大小都增长了4倍。另外，还需要启用GL_MULTISAMPLE来确保启用了多重采样。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glEnable(GL_MULTISAMPLE);<br></code></pre></td></tr></table></figure>
</li>
<li><p><img src="/2019/02/09/高级OpenGL（下）/anti_aliasing_sample.png" alt="开启MSAA对比"></p>
</li>
</ul>
<h3 id="离屏MSAA"><a href="#离屏MSAA" class="headerlink" title="离屏MSAA"></a>离屏MSAA</h3><ul>
<li>若想要使用自己的帧缓冲来进行离屏渲染，那么就必须要手动生成多重采样缓冲。</li>
<li>与普通帧缓冲创建使用过程类似，只需要将附件改成对应的多重采样附件。</li>
</ul>
<h4 id="多重采样纹理附件"><a href="#多重采样纹理附件" class="headerlink" title="多重采样纹理附件"></a>多重采样纹理附件</h4><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, tex);<br>glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, samples, GL_RGB, width, height, GL_TRUE);<br>glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, <span class="hljs-number">0</span>);<br><br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, tex, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li>为了创建一个支持储存多个采样点的纹理，我们使用<font color="#D2691E" size="4"> <em>glTexImage2DMultisample</em> </font>来替代glTexImage2D，它的纹理目标是GL_TEXTURE_2D_MULTISAPLE。</li>
<li>它的第二个参数设置的是纹理所拥有的样本个数。如果最后一个参数为GL_TRUE，图像将会对每个纹素使用相同的样本位置以及相同数量的子采样点个数。</li>
<li>使用glFramebufferTexture2D将多重采样纹理附加到帧缓冲上，但这里纹理类型使用的是GL_TEXTURE_2D_MULTISAMPLE。</li>
</ul>
<h4 id="多重采样渲染缓冲对象"><a href="#多重采样渲染缓冲对象" class="headerlink" title="多重采样渲染缓冲对象"></a>多重采样渲染缓冲对象</h4><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> rbo;<br>glGenRenderbuffers(<span class="hljs-number">1</span>, &amp;rbo);<br>glBindRenderbuffer(GL_RENDERBUFFER, rbo);<br>glRenderbufferStorageMultisample(GL_RENDERBUFFER, <span class="hljs-number">4</span>, GL_DEPTH24_STENCIL8, SCR_WIDTH, SCR_HEIGHT);<br>glBindRenderbuffer(GL_RENDERBUFFER, <span class="hljs-number">0</span>);<br>glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);<br></code></pre></td></tr></table></figure>
<ul>
<li>我们所要做的只是在指定（当前绑定的）渲染缓冲的内存存储时，将glRenderbufferStorage的调用改为<font color="#D2691E" size="4"> <em>glRenderbufferStorageMultisample</em> </font>就可以了。</li>
</ul>
<h4 id="渲染到多重采样帧缓冲"><a href="#渲染到多重采样帧缓冲" class="headerlink" title="渲染到多重采样帧缓冲"></a>渲染到多重采样帧缓冲</h4><ul>
<li>渲染到多重采样帧缓冲对象的过程都是自动的。只要我们在帧缓冲绑定时绘制任何东西，光栅器就会负责所有的多重采样运算。我们最终会得到一个多重采样颜色缓冲以及/或深度和模板缓冲。因为多重采样缓冲有一点特别，我们不能直接将它们的缓冲图像用于其他运算，比如在着色器中对它们进行采样。</li>
<li>一个多重采样的图像包含比普通图像更多的信息，我们所要做的是缩小或者还原(Resolve)图像。多重采样帧缓冲的还原通常是通过<font color="#D2691E" size="4"> <em>glBlitFramebuffer</em> </font>来完成，它能够将一个帧缓冲中的某个区域复制到另一个帧缓冲中，并且将多重采样缓冲还原。</li>
<li><p><font color="#D2691E" size="4"> <em>glBlitFramebuffer</em> </font>会将一个用4个屏幕空间坐标所定义的源区域复制到一个同样用4个屏幕空间坐标所定义的目标区域中。将帧缓冲分开绑定至GL_READ_FRAMEBUFFER与GL_DRAW_FRAMEBUFFER。glBlitFramebuffer函数会根据这两个目标，决定哪个是源帧缓冲，哪个是目标帧缓冲。接下来，将图像位块传送(Blit)到默认的帧缓冲中，将多重采样的帧缓冲传送到屏幕上。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">glBindFramebuffer(GL_READ_FRAMEBUFFER, framebuffer);<br>glBindFramebuffer(GL_DRAW_FRAMEBUFFER, intermediateFBO);<br>glBlitFramebuffer(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCR_WIDTH, SCR_HEIGHT, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, SCR_WIDTH, SCR_HEIGHT, GL_COLOR_BUFFER_BIT, GL_NEAREST);<br></code></pre></td></tr></table></figure>
</li>
<li><p><img src="/2019/02/09/高级OpenGL（下）/offscreen.png" alt="离屏MSAA"></p>
</li>
</ul>
<h3 id="自定义抗锯齿算法"><a href="#自定义抗锯齿算法" class="headerlink" title="自定义抗锯齿算法"></a>自定义抗锯齿算法</h3><figure class="hljs highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2DMS</span> screenTextureMS;<br><span class="hljs-type">vec4</span> colorSample = <span class="hljs-built_in">texelFetch</span>(screenTextureMS, TexCoords, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 第4个子样本</span><br></code></pre></td></tr></table></figure>

    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/OpenGL/" rel="tag"><i class="fas fa-tags"></i>OpenGL</a>
        
      </div>
      
    </footer>
  </article>
  
  
  <nav class="page-nav">
    <div class="page-nav-next page-nav-item">
      
      <a href="/2018/12/23/高级OpenGL（上）/" rel="next" title="高级OpenGL（上）"><i class="fas fa-angle-left"></i><span class="nav-title">高级OpenGL（上）</span></a>
      
    </div>
    <div class="page-nav-prev page-nav-item">
      
      <a href="/2019/02/19/游戏角色染色实现/" rel="prev" title="游戏角色染色实现"><span class="nav-title">游戏角色染色实现</span><i class="fas fa-angle-right"></i></a>
      
    </div>
  </nav>
  
  
  

<div class="comments" id="comments">
  
  
  <div id="vcomments" class="vcomments"></div>
  <script defer src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script defer src="//unpkg.com/valine/dist/Valine.min.js"></script>
  <script type="text/javascript">
  $(document).ready(function () {
    new Valine({
      "el": "#vcomments",
      "appId": "g87PyVdDsH5EP8VCTtaGlIBo-gzGzoHsz",
      "appKey": "wboY6qvCvYXBESIQQOWkFzYq",
      "verify": "false",
      "notify": "false",
      "avatar": "mm",
      "meta": ["nick", "mail", "link"],
      "pageSize": 10,
      "lang": "zh-cn",
      "visitor": "false",
      "highlight": "true",
      "placeholder": "在这里说点什么……",
      "avatarForce": "false"
    });
  });
  </script>
  
  
</div>



  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control">
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/myavatar.png" alt="MoriMiya">
  
  <h1 class="author-name">MoriMiya</h1>
  <h2 class="author-description"></h2>
  <div class="site-count">
    
    
    
    
    <div class="archives-count count-block">
      <div class="site-count-title">归档</div>
      <div><a href="/archives/">32</a></div>
    </div>
    
    
    
    <div class="categories-count count-block">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">26</a></div>
    </div>
    
    
    
    <div class="tags-count count-block">
      <div class="site-count-title">标签</div>
      <div><a href="/tags/">26</a></div>
    </div>
    
    
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    
    
    
    <hr>
    <div class="post-toc sidebar-item" id="toc-div">
      <div><i class="fas fa-list-ol"></i>文章目录</div>
      <div class="post-toc-content"><ol class="list-group toc"><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#高级数据-Advanced-Data"><span class="toc-text">高级数据(Advanced Data)</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#缓冲"><span class="toc-text">缓冲</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#分批顶点属性"><span class="toc-text">分批顶点属性</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#复制缓冲"><span class="toc-text">复制缓冲</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#高级GLSL-Advanced-GLSL"><span class="toc-text">高级GLSL(Advanced GLSL)</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#GLSL的内建变量"><span class="toc-text">GLSL的内建变量</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#顶点着色器变量"><span class="toc-text">顶点着色器变量</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#gl-PointSize（输出变量）"><span class="toc-text">gl_PointSize（输出变量）</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#gl-VertexID（输入变量）"><span class="toc-text">gl_VertexID（输入变量）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#片段着色器变量"><span class="toc-text">片段着色器变量</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#gl-FragCoord（输入变量）"><span class="toc-text">gl_FragCoord（输入变量）</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#gl-FrontFacing（输入变量）"><span class="toc-text">gl_FrontFacing（输入变量）</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#gl-FragDepth（输出变量）"><span class="toc-text">gl_FragDepth（输出变量）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#接口块"><span class="toc-text">接口块</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#Uniform缓冲对象"><span class="toc-text">Uniform缓冲对象</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#简介"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#Uniform块布局"><span class="toc-text">Uniform块布局</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#共享-Shared-布局"><span class="toc-text">共享(Shared)布局</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#std140布局"><span class="toc-text">std140布局</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#紧凑-Packed-布局"><span class="toc-text">紧凑(Packed)布局</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#使用Uniform缓冲"><span class="toc-text">使用Uniform缓冲</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#例子"><span class="toc-text">例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#几何着色器-Geometry-Shader"><span class="toc-text">几何着色器(Geometry Shader)</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#使用几何着色器"><span class="toc-text">使用几何着色器</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#几何着色器例子"><span class="toc-text">几何着色器例子</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#将例子显示"><span class="toc-text">将例子显示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#爆破物体"><span class="toc-text">爆破物体</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#法向量可视化"><span class="toc-text">法向量可视化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#实例化-Instancing"><span class="toc-text">实例化(Instancing)</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#glDrawArraysInstanced和glDrawElementsInstanced"><span class="toc-text">glDrawArraysInstanced和glDrawElementsInstanced</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#gl-InstanceID"><span class="toc-text">gl_InstanceID</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#实例化数组-Instanced-Array"><span class="toc-text">实例化数组(Instanced Array)</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#使用实例化绘制小行星带"><span class="toc-text">使用实例化绘制小行星带</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#抗锯齿-Anti-Aliasing"><span class="toc-text">抗锯齿(Anti Aliasing)</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#锯齿产生原因"><span class="toc-text">锯齿产生原因</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#多重采样抗锯齿-Multisample-Anti-aliasing-MSAA"><span class="toc-text">多重采样抗锯齿(Multisample Anti-aliasing, MSAA)</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#OpenGL中的MSAA"><span class="toc-text">OpenGL中的MSAA</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#离屏MSAA"><span class="toc-text">离屏MSAA</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#多重采样纹理附件"><span class="toc-text">多重采样纹理附件</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#多重采样渲染缓冲对象"><span class="toc-text">多重采样渲染缓冲对象</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#渲染到多重采样帧缓冲"><span class="toc-text">渲染到多重采样帧缓冲</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#自定义抗锯齿算法"><span class="toc-text">自定义抗锯齿算法</span></a></li></ol></li></ol></div>
    </div>
    
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接<p></p></div>
      <ul>
        
        <li><i class="fab fa-github"></i><a href="https://github.com/morimiya" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
    
    <hr>
    <div class="blogroll sidebar-item">
      <div><i class="fas fa-link"></i>友情链接</div>
      <ul>
        
        <li><i class="fas fa-link"></i><a href="https://github.com/" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">MoriMiya</span><span class="year"><i class="far fa-copyright"></i>2018 - 2021</span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
