<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#33363b">
    <meta name="msapplication-TileColor" content="#33363b">
    
    
    
    
    <meta name="keywords" content="Life, ARIA, Hexo">
    
    
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    
    
    <link rel="icon" type="image/png" sizes="192x192" href="/favicons/android-chrome-192x192.png">
    
    
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    
    
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
    
    
    <link rel="mask-icon" href="/favicons/safari-pinned-tab.svg" color="#33363b">
    
    
    <link rel="manifest" href="/favicons/site.webmanifest">
    
    
    <meta name="msapplication-config" content="/favicons/browserconfig.xml">
    
    
    <link rel="alternate" href="/atom.xml" title="MoriMiya" type="application/atom+xml">
    
    
    <link rel="shortcut icon" type="image/x-icon" href="/favicons/favicon.ico">
    
    
    <link rel="stylesheet" type="text/css" href="/css/normalize.css">
    <link rel="stylesheet" type="text/css" href="/css/index.css">
    
    <link rel="stylesheet" type="text/css" href="/css/sidebar.css">
    
    
<link rel="stylesheet" type="text/css" href="/css/page.css">
<link rel="stylesheet" type="text/css" href="/css/post.css">

    <link rel="stylesheet" type="text/css" href="/css/custom.css">
    <link rel="stylesheet" type="text/css" href="/css/atom-one-dark.css">
    <link rel="stylesheet" type="text/css" href="/css/lightgallery.min.css">
    <script type="text/javascript" src="/js/jquery.min.js"></script>
    <script defer type="text/javascript" src="/js/util.js"></script>
    <script defer type="text/javascript" src="/js/clipboard.min.js"></script>
    <script defer type="text/javascript" src="/js/scrollspy.js"></script>
    <script defer type="text/javascript" src="/js/fontawesome-all.min.js"></script>
    <script defer type="text/javascript" src="/js/lightgallery.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-fullscreen.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-hash.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-pager.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-thumbnail.min.js"></script>
    <script defer type="text/javascript" src="/js/lg-zoom.min.js"></script>
    
    <script defer src="/js/busuanzi.pure.mini.js"></script>
    
    
    <script defer type="text/javascript" src="/js/search.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var searchPath = "search.xml";
      if (searchPath.length === 0) {
        searchPath = "search.xml";
      }
      var path = "/" + searchPath;
      searchFunc(path, "search-input", "search-result");
    });
    </script>
    
    
    
    <script defer type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-MML-AM_CHTML"></script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ["$","$"], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code"]
      }
    });
    </script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += " has-jax";
      }
    });
    </script>
    
    
    <script defer type="text/javascript" src="/js/index.js"></script>
    <script type="text/javascript">
    $(document).ready(function () {
      var cb = null;
      var els = $(".post figure.highlight");
      if (els.length) {
        // Enabled Hexo highlight line number.
        $(els).each(function (i, e) {
          $(e).before("<button class=\"copy button\">复制</button>");
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              // nextElementSibling is figure,highlight.
              // And following is the sequence of Hexo's internal
              // highlight layout with line number.
              return trigger.nextElementSibling.firstChild.firstChild.firstChild.lastChild.firstChild.firstChild;
          }
        });
      } else {
        // Disabled Hexo highlight line number.
        els = $(".post pre code");
        $(els).each(function (i, e) {
          // Add button before pre, not code.
          $(e).parent().before("<button class=\"copy button\">复制</button>");
        });
        cb = new ClipboardJS("button.copy", {
          "target": function (trigger) {
              // Get target element by DOM API.
              // nextElementSibling is figure,highlight.
              // And following is the sequence of Hexo's internal
              // highlight layout without line number.
              return trigger.nextElementSibling.firstChild;
          }
        });
      }
      cb.on("success", function (e) {
        e.clearSelection();
        var trigger = e.trigger;
        // Change button text as a user tip.
        trigger.innerHTML = "已复制";
        $(trigger).addClass("copied");
        // Change button text back;
        setTimeout(function () {
          trigger.innerHTML = "复制";
          $(trigger).removeClass("copied");
        }, 1500);
      });
    });
    </script>
    
    <script defer type="text/javascript" src="/js/custom.js"></script>
    <title>高级OpenGL（上） | MoriMiya - Don't you want to be alive before you die?</title>
  </head>
  <body itemscope="" itemtype="http://schema.org/WebPage" lang="zh_CN" data-spy="scroll" data-target=".list-group">
    
<header id="header" class="header" style="background: #33363b;">
  <div class="container">
    <div class="header-container">
      <div class="header-title">
        <h1 class="title"><a href="/">MoriMiya</a></h1>
        <h2 class="subtitle">Don't you want to be alive before you die?</h2>
      </div>
      
      <div class="logo">
        <img src="/images/logo.png" alt="logo">
      </div>
      
    </div>
    <nav id="nav" class="nav">
      <a id="nav-toggle" class="nav-toggle" aria-hidden="true"><i class="fas fa-bars" aria-label="切换导航栏"></i></a>
      <ul id="menu" role="menubar" aria-hidden="false">
        
        <li role="menuitem"><a href="/"><i class="fas fa-home"></i><span class="menu-text">首页</span></a></li>
        
        <li role="menuitem"><a href="/archives/"><i class="fas fa-archive"></i><span class="menu-text">归档</span></a></li>
        
        <li role="menuitem"><a href="/categories/"><i class="fas fa-th-list"></i><span class="menu-text">分类</span></a></li>
        
        <li role="menuitem"><a href="/tags/"><i class="fas fa-tags"></i><span class="menu-text">标签</span></a></li>
        
        <li role="menuitem"><a href="/about/"><i class="fas fa-user-edit"></i><span class="menu-text">关于</span></a></li>
        
      </ul>
    </nav>
  </div>
</header>


    <main id="main" class="main">
      <div class="container">
        <div class="main-container">
          <div class="content">
            
<div id="post" class="page">
  
  <article class="article post card animate" itemscope="" itemtype="http://schema.org/Article">
    <div class="post-block">
      <link itemprop="mainEntityOfPage" href="http://morimiya.me/2018/12/23/高级OpenGL（上）/">
      <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
       <meta itemprop="name" content="MoriMiya">
       <meta itemprop="description" content="">
       <meta itemprop="image" content="/images/myavatar.png">
      </span>
      <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
       <meta itemprop="name" content="MoriMiya">
      </span>
    </div>
    <header class="post-header">
      <h1 class="post-title" itemprop="name headline">高级OpenGL（上）</h1>
      <div class="post-meta">
        
        <span class="post-date">
          <i class="far fa-calendar-plus"></i><span><time title="post-date" itemprop="dateCreated datePublished" datetime="2018-12-23T01:06:22+08:00">2018-12-23 01:06:22</time></span>
        </span>
        
        
        
        <span class="post-meta-divider divider">|</span>
        
        <span class="post-categories">
          
          <i class="far fa-folder-open"></i><span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/OpenGL/" itemprop="url" rel="index"><span itemprop="name">OpenGL</span></a></span><i class="fas fa-angle-right"></i><span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/OpenGL/高级OpenGL/" itemprop="url" rel="index"><span itemprop="name">高级OpenGL</span></a></span>
        </span>
        
        
        
        
      </div>
    </header>
    <main class="post-main" itemprop="articleBody">
      <blockquote>
<p><a href="https://learnopengl-cn.github.io" target="_blank" rel="noopener">https://learnopengl-cn.github.io</a> 高级OpenGL学习笔记</p>
<p>深度测试，模板测试，混合，面剔除，帧缓冲，立方体贴图。</p>
</blockquote>
<a id="more"></a>
<h2 id="深度测试-Depth-testing"><a href="#深度测试-Depth-testing" class="headerlink" title="深度测试(Depth testing)"></a>深度测试(Depth testing)</h2><ul>
<li>将3D世界中的东西用2D屏幕来表示，我们需要知道物体的前后关系以让物体以正确的方式渲染。在OpenGL中是通过储存在深度缓冲（或z缓冲(z-buffer)）中的深度值(Depth Value)来确定一个片段是处于其它片段后方的。</li>
</ul>
<h3 id="深度测试运行机制"><a href="#深度测试运行机制" class="headerlink" title="深度测试运行机制"></a>深度测试运行机制</h3><h4 id="深度缓冲"><a href="#深度缓冲" class="headerlink" title="深度缓冲"></a>深度缓冲</h4><ul>
<li>深度缓冲就像颜色缓冲(Color Buffer)（储存所有的片段颜色：视觉输出）一样，在每个片段中储存了信息，并且（通常）和颜色缓冲有着一样的宽度和高度。深度缓冲是由窗口系统自动创建的，它会以16、24或32位float的形式储存它的深度值。在大部分的系统中，深度缓冲的精度都是24位的。</li>
</ul>
<h4 id="深度测试规则"><a href="#深度测试规则" class="headerlink" title="深度测试规则"></a>深度测试规则</h4><ul>
<li><p>深度测试默认是禁用的，所以如果要启用深度测试的话，我们需要用GL_DEPTH_TEST选项来启用它：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glEnable(GL_DEPTH_TEST);<br></code></pre></td></tr></table></figure>
</li>
<li><p>当深度测试(Depth Testing)被启用的时候，OpenGL会将一个片段的的深度值与深度缓冲的内容进行对比。OpenGL会执行一个深度测试，如果这个测试通过了的话，深度缓冲将会更新为新的深度值（深度缓冲中储存该片段的z值）。如果深度测试失败了，片段将会被丢弃。</p>
</li>
<li><p>因为深度被缓存，一般情况下，在每个渲染迭代前会使用GL_DEPTH_BUFFER_BIT来清除深度缓冲：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br></code></pre></td></tr></table></figure>
</li>
<li><p>OpenGL允许我们禁用深度缓冲的写入：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glDepthMask(GL_FALSE);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="深度测试时机"><a href="#深度测试时机" class="headerlink" title="深度测试时机"></a>深度测试时机</h4><ul>
<li>深度缓冲是在片段着色器运行之后（以及模板测试(Stencil Testing)运行之后，我们将在下一节中讨论）在屏幕空间中运行的。屏幕空间坐标与通过OpenGL的glViewport所定义的视口密切相关，并且可以直接使用GLSL内建变量gl_FragCoord从片段着色器中直接访问。gl_FragCoord的x和y分量代表了片段的屏幕空间坐标（其中(0, 0)位于左下角）。gl_FragCoord中也包含了一个z分量，它包含了片段真正的深度值。z值就是需要与深度缓冲内容所对比的那个值。</li>
</ul>
<h4 id="提前深度测试"><a href="#提前深度测试" class="headerlink" title="提前深度测试"></a>提前深度测试</h4><ul>
<li>现在大部分的GPU都提供一个叫做提前深度测试(Early Depth Testing)的硬件特性。提前深度测试允许深度测试在片段着色器之前运行。只要我们清楚一个片段永远不会是可见的（它在其他物体之后），我们就能提前丢弃这个片段。</li>
<li>片段着色器通常开销都是很大的，所以我们应该尽可能避免运行它们。当使用提前深度测试时，片段着色器的一个限制是你不能写入片段的深度值。如果一个片段着色器对它的深度值进行了写入，提前深度测试是不可能的。OpenGL不能提前知道深度值。</li>
</ul>
<hr>
<h3 id="深度测试函数"><a href="#深度测试函数" class="headerlink" title="深度测试函数"></a>深度测试函数</h3><ul>
<li>OpenGL允许我们修改深度测试中使用的比较运算符。这允许我们来控制OpenGL什么时候该通过或丢弃一个片段，什么时候去更新深度缓冲。我们可以调用glDepthFunc函数来设置比较运算符（或者说深度函数(Depth Function)）：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glDepthFunc(GL_LESS);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_ALWAYS</td>
<td>永远通过深度测试</td>
</tr>
<tr>
<td>GL_NEVER</td>
<td>永远不通过深度测试</td>
</tr>
<tr>
<td>GL_LESS</td>
<td>在片段深度值小于缓冲的深度值时通过测试</td>
</tr>
<tr>
<td>GL_EQUAL</td>
<td>在片段深度值等于缓冲区的深度值时通过测试</td>
</tr>
<tr>
<td>GL_LEQUAL</td>
<td>在片段深度值小于等于缓冲区的深度值时通过测试</td>
</tr>
<tr>
<td>GL_GREATER</td>
<td>在片段深度值大于缓冲区的深度值时通过测试</td>
</tr>
<tr>
<td>GL_NOTEQUAL</td>
<td>在片段深度值不等于缓冲区的深度值时通过测试</td>
</tr>
<tr>
<td>GL_GEQUAL</td>
<td>在片段深度值大于等于缓冲区的深度值时通过测试</td>
</tr>
</tbody>
</table>
</div>
<hr>
<h3 id="深度值"><a href="#深度值" class="headerlink" title="深度值"></a>深度值</h3><h4 id="深度值精度"><a href="#深度值精度" class="headerlink" title="深度值精度"></a>深度值精度</h4><ul>
<li>使用线性深度缓冲(Linear Depth Buffer)会使得对1000单位远的物体和只有1单位远的充满细节的物体使用相同的精度，这与投影性质不相符，我们希望在近处有更精细的精度，而远处的精度可以很粗糙。</li>
<li>由投影矩阵所得的深度缓冲值函数：<script type="math/tex; mode=display">F_{depth} = \frac{1/z - 1/near}{1/far - 1/near}</script></li>
<li><img src="/2018/12/23/高级OpenGL（上）/depth_non_linear_graph.png" alt="z值和最终的深度缓冲值之间的非线性关系"></li>
</ul>
<h4 id="深度值可视化"><a href="#深度值可视化" class="headerlink" title="深度值可视化"></a>深度值可视化</h4><ul>
<li><p>片段着色器改为：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    FragColor = vec4(vec3(gl_FragCoord.z), <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可视化的深度值如下图，几乎全白，很靠近物体的时候才会有黑色，体现了深度值的非线性特性。</p>
</li>
<li><img src="/2018/12/23/高级OpenGL（上）/depth_testing_depth.png" alt="深度值可视化"></li>
</ul>
<hr>
<h3 id="深度冲突"><a href="#深度冲突" class="headerlink" title="深度冲突"></a>深度冲突</h3><ul>
<li>一个很常见的视觉错误会在两个平面或者三角形非常紧密地平行排列在一起时会发生，深度缓冲没有足够的精度来决定两个形状哪个在前面。结果就是这两个形状不断地在切换前后顺序，这会导致很奇怪的花纹。这个现象叫做深度冲突(Z-fighting)，因为它看起来像是这两个形状在争夺(Fight)谁该处于顶端。</li>
<li>由于深度值非线性，远近平面距离短时处于较远处的物体更容易出现深度冲突。</li>
<li><img src="/2018/12/23/高级OpenGL（上）/z_fighting.png" alt="深度冲突"></li>
<li><img src="/2018/12/23/高级OpenGL（上）/depth_testing_zfighting.png" alt="深度冲突"></li>
</ul>
<h4 id="防止深度冲突"><a href="#防止深度冲突" class="headerlink" title="防止深度冲突"></a>防止深度冲突</h4><ul>
<li><p>第一个也是最重要的技巧是永远不要把多个物体摆得太靠近，以至于它们的一些三角形会重叠。通过在两个物体之间设置一个用户无法注意到的偏移值，你可以完全避免这两个物体之间的深度冲突。在箱子和地板的例子中，我们可以将箱子沿着正y轴稍微移动一点。箱子位置的这点微小改变将不太可能被注意到，但它能够完全减少深度冲突的发生。然而，这需要对每个物体都手动调整，并且需要进行彻底的测试来保证场景中没有物体会产生深度冲突。</p>
</li>
<li><p>第二个技巧是尽可能将近平面设置远一些。在前面我们提到了精度在靠近近平面时是非常高的，所以如果我们将近平面远离观察者，我们将会对整个平截头体有着更大的精度。然而，将近平面设置太远将会导致近处的物体被裁剪掉，所以这通常需要实验和微调来决定最适合你的场景的近平面距离。</p>
</li>
<li><p>另外一个很好的技巧是牺牲一些性能，使用更高精度的深度缓冲。大部分深度缓冲的精度都是24位的，但现在大部分的显卡都支持32位的深度缓冲，这将会极大地提高精度。所以，牺牲掉一些性能，你就能获得更高精度的深度测试，减少深度冲突。</p>
</li>
</ul>
<hr>
<h2 id="模板测试-Stencil-testing"><a href="#模板测试-Stencil-testing" class="headerlink" title="模板测试(Stencil testing)"></a>模板测试(Stencil testing)</h2><ul>
<li>一个模板缓冲中，（通常）每个模板值(Stencil Value)是8位的。所以每个像素/片段一共能有256种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。<blockquote>
<p>每个窗口库都需要为你配置一个模板缓冲。GLFW自动做了这件事，所以我们不需要告诉GLFW来创建一个，但其它的窗口库可能不会默认给你创建一个模板库，所以记得要查看库的文档。</p>
</blockquote>
</li>
</ul>
<h3 id="使用模板缓冲"><a href="#使用模板缓冲" class="headerlink" title="使用模板缓冲"></a>使用模板缓冲</h3><h4 id="大体步骤"><a href="#大体步骤" class="headerlink" title="大体步骤"></a>大体步骤</h4><ol>
<li><p>启用模板缓冲的写入。可以启用GL_STENCIL_TEST来启用模板测试。和颜色和深度缓冲一样，你也需要在每次迭代之前清除模板缓冲。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glEnable(GL_STENCIL_TEST);<br>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);<br></code></pre></td></tr></table></figure>
</li>
<li><p>和颜色和深度缓冲一样，你也需要在每次迭代之前清除模板缓冲。</p>
</li>
<li>禁用模板缓冲的写入。</li>
<li>渲染（其它）物体，这次根据模板缓冲的内容丢弃特定的片段。</li>
</ol>
<h4 id="掩码设置"><a href="#掩码设置" class="headerlink" title="掩码设置"></a>掩码设置</h4><ul>
<li>和深度测试的glDepthMask函数一样，模板缓冲也有一个类似的函数。glStencilMask允许我们设置一个位掩码(Bitmask)，它会与将要写入缓冲的模板值进行与(AND)运算。默认情况下设置的位掩码所有位都为1，不影响输出，但如果我们将它设置为0x00，写入缓冲的所有模板值最后都会变成0.这与深度测试中的glDepthMask(GL_FALSE)是等价的。</li>
<li>大部分情况下你都只会使用0x00或者0xFF作为模板掩码(Stencil Mask)，但是知道有选项可以设置自定义的位掩码总是好的。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glStencilMask(<span class="hljs-number">0xFF</span>); <span class="hljs-comment">// 每一位写入模板缓冲时都保持原样</span><br>glStencilMask(<span class="hljs-number">0x00</span>); <span class="hljs-comment">// 每一位在写入模板缓冲时都会变成0（禁用写入）</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h4><h5 id="glStencilFunc"><a href="#glStencilFunc" class="headerlink" title="glStencilFunc"></a>glStencilFunc</h5><ul>
<li>glStencilFunc决定模板与何值进行何种比较，且支持比较前进行掩码计算。</li>
<li>glStencilFunc(GLenum func, GLint ref, GLuint mask)一共包含三个参数：<ol>
<li>func：设置模板测试函数(Stencil Test Function)。这个测试函数将会应用到已储存的模板值上和glStencilFunc函数的ref值上。可用的选项有：GL_NEVER、GL_LESS、GL_LEQUAL、GL_GREATER、GL_GEQUAL、GL_EQUAL、GL_NOTEQUAL和GL_ALWAYS。它们的语义和深度缓冲的函数类似。</li>
<li>ref：设置了模板测试的参考值(Reference Value)。模板缓冲的内容将会与这个值进行比较。</li>
<li>mask：设置一个掩码，它将会与参考值和储存的模板值在测试比较它们之前进行与(AND)运算。初始情况下所有位都为1。</li>
</ol>
</li>
</ul>
<h5 id="glStencilOp"><a href="#glStencilOp" class="headerlink" title="glStencilOp"></a>glStencilOp</h5><ul>
<li>glStencilOp告诉OpenGL如何更新缓冲。</li>
<li>glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass)一共包含三个参数：<ol>
<li>sfail：模板测试失败时采取的行为。</li>
<li>dpfail：模板测试通过，但深度测试失败时采取的行为。</li>
<li>dppass：模板测试和深度测试都通过时采取的行为。</li>
</ol>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_KEEP</td>
<td>保持当前储存的模板值</td>
</tr>
<tr>
<td>GL_ZERO</td>
<td>将模板值设置为0</td>
</tr>
<tr>
<td>GL_REPLACE</td>
<td>将模板值设置为glStencilFunc函数设置的ref值</td>
</tr>
<tr>
<td>GL_INCR</td>
<td>如果模板值小于最大值则将模板值加1</td>
</tr>
<tr>
<td>GL_INCR_WRAP</td>
<td>与GL_INCR一样，但如果模板值超过了最大值则归零</td>
</tr>
<tr>
<td>GL_DECR</td>
<td>如果模板值大于最小值则将模板值减1</td>
</tr>
<tr>
<td>GL_DECR_WRAP</td>
<td>与GL_DECR一样，但如果模板值小于0则将其设置为最大值</td>
</tr>
<tr>
<td>GL_INVERT</td>
<td>按位翻转当前的模板缓冲值</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>默认情况下glStencilOp是设置为(GL_KEEP, GL_KEEP, GL_KEEP)的，所以不论任何测试的结果是如何，模板缓冲都会保留它的值。默认的行为不会更新模板缓冲，所以如果你想写入模板缓冲的话，你需要至少对其中一个选项设置不同的值。</li>
</ul>
<hr>
<h3 id="模板缓冲例子"><a href="#模板缓冲例子" class="headerlink" title="模板缓冲例子"></a>模板缓冲例子</h3><h4 id="物体轮廓"><a href="#物体轮廓" class="headerlink" title="物体轮廓"></a>物体轮廓</h4><ul>
<li><p>绘制轮廓步骤</p>
<ol>
<li>在绘制（需要添加轮廓的）物体之前，将模板函数设置为GL_ALWAYS，每当物体的片段被渲染时，将模板缓冲更新为1。</li>
<li>渲染物体。</li>
<li>禁用模板写入以及深度测试。</li>
<li>将每个物体缩放一点点。</li>
<li>使用一个不同的片段着色器，输出一个单独的（边框）颜色。</li>
<li>再次绘制物体，但只在它们片段的模板值不等于1时才绘制。</li>
<li>再次启用模板写入和深度测试。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 开启模板缓冲</span><br>glEnable(GL_DEPTH_TEST);<br><span class="hljs-comment">// 设置测试通过时的替换模板值</span><br>glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);  <br><br><span class="hljs-comment">// 清空模板缓冲</span><br>glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);<br><br>glStencilMask(<span class="hljs-number">0x00</span>); <span class="hljs-comment">// 记得保证我们在绘制地板的时候不会更新模板缓冲</span><br>normalShader.use();<br>DrawFloor()  <br><br><span class="hljs-comment">// 第一次绘制物体，让片段都通过模板测试。</span><br>glStencilFunc(GL_ALWAYS, <span class="hljs-number">1</span>, <span class="hljs-number">0xFF</span>);<br>glStencilMask(<span class="hljs-number">0xFF</span>);<br>DrawTwoContainers();<br><br><span class="hljs-comment">// 第二次绘制物体，禁止模板缓冲写入，将物体放大一点点，只通过模板缓冲值不等于1的片段。</span><br>glStencilFunc(GL_NOTEQUAL, <span class="hljs-number">1</span>, <span class="hljs-number">0xFF</span>);<br>glStencilMask(<span class="hljs-number">0x00</span>);<br>glDisable(GL_DEPTH_TEST);<br>shaderSingleColor.use();<br>DrawTwoScaledUpContainers();<br>glStencilMask(<span class="hljs-number">0xFF</span>);<br>glEnable(GL_DEPTH_TEST);<br></code></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><img src="/2018/12/23/高级OpenGL（上）/物体轮廓.jpg" alt="物体轮廓"></p>
</li>
</ul>
<hr>
<h2 id="混合-Blending"><a href="#混合-Blending" class="headerlink" title="混合(Blending)"></a>混合(Blending)</h2><ul>
<li>OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色。这也是混合这一名字的出处，我们混合(Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。</li>
</ul>
<h3 id="丢弃片段-discard"><a href="#丢弃片段-discard" class="headerlink" title="丢弃片段(discard)"></a>丢弃片段(discard)</h3><ul>
<li>在绘制物体时，有些时候，我们会希望丢弃某些片段，如alpha为0的片段。</li>
<li><p>GLSL给了我们discard命令，一旦被调用，它就会保证片段不会被进一步处理，所以就不会进入颜色缓冲。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#version 330 core</span><br>out vec4 FragColor;<br><br>in vec2 TexCoords;<br><br>uniform sampler2D texture1;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;             <br>    vec4 texColor = texture(texture1, TexCoords);<br>    <span class="hljs-keyword">if</span>(texColor.a &lt; <span class="hljs-number">0.1</span>)<br>        discard;<br>    FragColor = texColor;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><img src="/2018/12/23/高级OpenGL（上）/discard.png" alt="使用discard去掉alpha值小于1的片段"></p>
</li>
<li>从上图可以看出，采样纹理的边缘的时候，OpenGL会对边缘的值和纹理下一个重复的值进行插值，从而造成草头上有点绿。（这是因为它的环绕方式被设置为了GL_REPEAT，将纹理的环绕方式设置为GL_CLAMP_TO_EDGE即可解决）。<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h3><ul>
<li>截至上面，我们对一个片段的操作均为要么丢弃，要么渲染，并未能做到渲染多个透明度级别的图像。</li>
<li>OpenGL提供了glEnable(GL_BLEND)方法来启用混合，但我们需要告知OpenGL如何混合。</li>
</ul>
<h4 id="混合方程"><a href="#混合方程" class="headerlink" title="混合方程"></a>混合方程</h4><script type="math/tex; mode=display">\vec C_{result} = \vec C_{source} * \vec F_{source} + \vec C_{destination} * \vec F_{destination}</script><p>$\vec C_{source}$ ：源颜色向量，这是源自纹理的颜色向量。</p>
<p>$\vec C_{destination}$ ：目标颜色向量。这是当前储存在颜色缓冲中的颜色向量。</p>
<p>$\vec F_{destination}$ ：目标因子值，指定了alpha对目标颜色的影响。</p>
<p>$\vec F_{source}$ ：源因子值，指定了alpha对源颜色的影响。</p>
<p>$\vec C_{constant}$ ：常数颜色向量，通过glBlendColor函数来另外设置。</p>
<ul>
<li>片段着色器运行完成后，并且所有的测试都通过之后，这个混合方程(Blend Equation)才会应用到片段颜色输出与当前颜色缓冲中的值（当前片段之前储存的之前片段的颜色）上。源颜色和目标颜色将会由OpenGL自动设定，但源因子和目标因子的值可以由我们来决定。</li>
</ul>
<h4 id="混合使用"><a href="#混合使用" class="headerlink" title="混合使用"></a>混合使用</h4><ul>
<li>在混合方程中，对于OpenGL而言，因子值是不知道的，我们将通过glBlendFunc(GLenum sfactor, GLenum dfactor)来设置源和目标因子。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>选项</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_ZERO</td>
<td>因子等于0</td>
</tr>
<tr>
<td>GL_ONE</td>
<td>因子等于1</td>
</tr>
<tr>
<td>GL_SRC_COLOR</td>
<td>因子等于源颜色向量 $\vec C_{source}$</td>
</tr>
<tr>
<td>GL_ONE_MINUS_SRC_COLOR</td>
<td>因子等于1− $\vec C_{source}$</td>
</tr>
<tr>
<td>GL_DST_COLOR</td>
<td>因子等于目标颜色向量 $\vec C_{destination}$</td>
</tr>
<tr>
<td>GL_ONE_MINUS_DST_COLOR</td>
<td>因子等于1− $\vec C_{destination}$</td>
</tr>
<tr>
<td>GL_SRC_ALPHA</td>
<td>因子等于 $\vec C_{source}$ 的alpha分量</td>
</tr>
<tr>
<td>GL_ONE_MINUS_SRC_ALPHA</td>
<td>因子等于1− $\vec C_{source}$ 的alpha分量</td>
</tr>
<tr>
<td>GL_DST_ALPHA</td>
<td>因子等于 $\vec C_{destination}$ 的alpha分量</td>
</tr>
<tr>
<td>GL_ONE_MINUS_DST_ALPHA</td>
<td>因子等于1− $\vec C_{destination}$ 的alpha分量</td>
</tr>
<tr>
<td>GL_CONSTANT_COLOR</td>
<td>因子等于常数颜色向量 $\vec C_{constant}$</td>
</tr>
<tr>
<td>GL_ONE_MINUS_CONSTANT_COLOR</td>
<td>因子等于1− $\vec C_{constant}$</td>
</tr>
<tr>
<td>GL_CONSTANT_ALPHA</td>
<td>因子等于 $\vec C_{constant}$ 的alpha分量</td>
</tr>
<tr>
<td>GL_ONE_MINUS_CONSTANT_ALPHA</td>
<td>因子等于1− $\vec C_{constant}$ 的alpha分量</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>使用使用glBlendFuncSeparate为RGB和alpha通道分别设置不同的选项：<ul>
<li>glBlendFuncSeparate(GLenum srcRGB, GLenum destRGB, GLenum srcAlpha, GLenum destAlpha)</li>
</ul>
</li>
<li><p>使用glBlendEquation(GLenum mode)允许我们设置运算符，默认是相加。</p>
<ul>
<li>GL<em>FUNC_ADD：默认选项，将两个分量相加： $\vec C</em>{result}$ = Src + Dst</li>
<li>GL<em>FUNC_SUBTRACT：将两个分量相减： $\vec C</em>{result}$ = Src − Dst</li>
<li>GL<em>FUNC_REVERSE_SUBTRACT：将两个分量相减，但顺序相反： $\vec C</em>{result}$ = Dst − Src</li>
</ul>
</li>
<li><p>使用混合渲染半透明纹理效果：</p>
</li>
<li><img src="/2018/12/23/高级OpenGL（上）/blending_withoutsort.png" alt="使用混合渲染半透明纹理效果"></li>
<li>可以看到，最前面的窗口挡住了后面的一个窗口，这是由于深度测试与混合一起使用造成的问题。深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。</li>
<li>在不考虑旋转、缩放或者其它的变换，以及物体形状的情况下，我们通过对物体远近进行排序，逆序渲染，可以得到比较好的效果：</li>
<li><img src="/2018/12/23/高级OpenGL（上）/blending_withsort.png" alt="使用混合渲染半透明纹理效果"></li>
</ul>
<hr>
<h2 id="面剔除-Face-culling"><a href="#面剔除-Face-culling" class="headerlink" title="面剔除(Face culling)"></a>面剔除(Face culling)</h2><ul>
<li>对于一个被渲染的物体，我们看不见其背面部分，这部分的渲染其实是没必要的，可以通过面剔除的方法来实现这种想法。</li>
<li>OpenGL能够检查所有面向(Front Facing)观察者的面，并渲染它们，而丢弃那些背向(Back Facing)的面，节省我们很多的片段着色器调用（它们的开销很大！）。但我们仍要告诉OpenGL哪些面是正向面(Front Face)，哪些面是背向面(Back Face)。OpenGL使用了一个很聪明的技巧，分析顶点数据的环绕顺序(Winding Order)。</li>
</ul>
<h3 id="环绕顺序"><a href="#环绕顺序" class="headerlink" title="环绕顺序"></a>环绕顺序</h3><ul>
<li>当我们定义一组三角形顶点时，我们会以特定的环绕顺序来定义它们，可能是顺时针(Clockwise)的，也可能是逆时针(Counter-clockwise)的。每个三角形由3个顶点所组成，我们会从三角形中间来看，为这3个顶点设定一个环绕顺序。</li>
<li><img src="/2018/12/23/高级OpenGL（上）/faceculling_windingorder.png" alt="三角形顶点环绕顺序"></li>
<li>每组组成三角形图元的三个顶点就包含了一个环绕顺序。OpenGL在渲染图元的时候将使用这个信息来决定一个三角形是一个正向三角形还是背向三角形。默认情况下，逆时针顶点所定义的三角形将会被处理为正向三角形。</li>
<li>一般的，面向观察者视角所见的三角形为正向的。</li>
<li><img src="/2018/12/23/高级OpenGL（上）/faceculling_frontback.png" alt="三角形顶点环绕顺序"></li>
</ul>
<h3 id="面剔除"><a href="#面剔除" class="headerlink" title="面剔除"></a>面剔除</h3><ul>
<li>OpenGL提供glEnable(GL_CULL_FACE)方法供我们开启面剔除。</li>
<li>我们还可以通过glCullFace方法来修改要剔除的面的类型：<ul>
<li>GL_BACK：只剔除背向面。</li>
<li>GL_FRONT：只剔除正向面。</li>
<li>GL_FRONT_AND_BACK：剔除正向面和背向面。</li>
</ul>
</li>
<li>OpenGL也提供了glFrontFace方法，供我们设定何种环绕顺序为正向面：<ul>
<li>GL_CW：顺时针。</li>
<li>GL_CCW：逆时针。</li>
</ul>
</li>
<li>通过开启面剔除及设置正向面为顺时针方向，我们可以只渲染立方体背面：</li>
<li><img src="/2018/12/23/高级OpenGL（上）/face_culling.png" alt="面剔除效果"></li>
</ul>
<hr>
<h2 id="帧缓冲-Framebuffers"><a href="#帧缓冲-Framebuffers" class="headerlink" title="帧缓冲(Framebuffers)"></a>帧缓冲(Framebuffers)</h2><ul>
<li>用于写入颜色值的颜色缓冲、用于写入深度信息的深度缓冲和允许我们根据一些条件丢弃特定片段的模板缓冲。这些缓冲结合起来叫做帧缓冲(Framebuffer)，它被储存在内存中。OpenGL允许我们定义我们自己的帧缓冲，也就是说我们能够定义我们自己的颜色缓冲，甚至是深度缓冲和模板缓冲。</li>
</ul>
<h3 id="创建帧缓冲"><a href="#创建帧缓冲" class="headerlink" title="创建帧缓冲"></a>创建帧缓冲</h3><ul>
<li><p>帧缓冲的创建、使用、销毁步骤如下：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> fbo;<br><span class="hljs-comment">// 创建一个帧缓冲对象(Framebuffer Object, FBO)</span><br>glGenFramebuffers(<span class="hljs-number">1</span>, &amp;fbo);<br><span class="hljs-comment">// 绑定帧缓冲</span><br>glBindFramebuffer(GL_FRAMEBUFFER, fbo);<br><span class="hljs-comment">// 附加缓冲，颜色附件等操作...</span><br>...<br><span class="hljs-comment">// 检查帧缓冲是否完整</span><br>glCheckFramebufferStatus(GL_FRAMEBUFFER) == GL_FRAMEBUFFER_COMPLETE<br><span class="hljs-comment">// 再次激活默认帧缓冲</span><br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 在完成所有的帧缓冲操作之后，删除这个帧缓冲对象</span><br>glDeleteFramebuffers(<span class="hljs-number">1</span>, &amp;fbo);<br></code></pre></td></tr></table></figure>
</li>
<li><p>在创建完帧缓冲后，并不能马上进行使用，因为其是不完整的。一个完整的帧缓冲需要满足以下的条件：</p>
<ul>
<li>附加至少一个缓冲（颜色、深度或模板缓冲）。</li>
<li>至少有一个颜色附件(Attachment)。</li>
<li>所有的附件都必须是完整的（保留了内存）。</li>
<li>每个缓冲都应该有相同的样本数。</li>
</ul>
</li>
</ul>
<h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><h4 id="为帧缓存创建纹理"><a href="#为帧缓存创建纹理" class="headerlink" title="为帧缓存创建纹理"></a>为帧缓存创建纹理</h4><ul>
<li><p>当把一个纹理附加到帧缓冲的时候，所有的渲染指令将会写入到这个纹理中，就想它是一个普通的颜色/深度或模板缓冲一样。使用纹理的优点是，所有渲染操作的结果将会被储存在一个纹理图像中，我们之后可以在着色器中很方便地使用它。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> texture;<br>glGenTextures(<span class="hljs-number">1</span>, &amp;texture);<br>glBindTexture(GL_TEXTURE_2D, texture);<br><br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB, SCREEN_WIDTH, SCREEN_HEIGHT, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="hljs-literal">NULL</span>);<br><br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br></code></pre></td></tr></table></figure>
</li>
<li><p>我们将其大小设置为屏幕大小（非必要，但后面的例子中会直接使用其替换整个窗口屏幕），数据传入NULL。</p>
</li>
<li>即，我们仅创建了一片内存，并没有对其进行数据填充。填充这个纹理将会在我们渲染到帧缓冲之后来进行。同样注意我们并不关心环绕方式或多级渐远纹理，我们在大多数情况下都不会需要它们。</li>
<li><p>创建完纹理后，我们需要将其附加到帧缓冲上。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>glFrameBufferTexture2D有以下的参数：</p>
<ul>
<li>target：帧缓冲的目标（绘制、读取或者两者皆有）</li>
<li>attachment：我们想要附加的附件类型。当前我们正在附加一个颜色附件。注意最后的0意味着我们可以附加多个颜色附件。</li>
<li>textarget：你希望附加的纹理类型</li>
<li>texture：要附加的纹理本身</li>
<li>level：多级渐远纹理的级别。我们将它保留为0。</li>
</ul>
</li>
<li><p>除了颜色附件之外，我们还可以附加一个深度和模板缓冲纹理到帧缓冲对象中。要附加深度缓冲的话，我们将附件类型设置为GL_DEPTH_ATTACHMENT。注意纹理的格式(Format)和内部格式(Internalformat)类型将变为GL_DEPTH_COMPONENT，来反映深度缓冲的储存格式。要附加模板缓冲的话，你要将第二个参数设置为GL_STENCIL_ATTACHMENT，并将纹理的格式设定为GL_STENCIL_INDEX。</p>
</li>
<li><p>也可以将深度缓冲和模板缓冲附加为一个单独的纹理。纹理的每32位数值将包含24位的深度信息和8位的模板信息。使用GL_DEPTH_STENCIL_ATTACHMENT类型，并配置纹理的格式，让它包含合并的深度和模板值。</p>
</li>
<li>将一个深度和模板缓冲附加为一个纹理到帧缓冲的例子：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">glTexImage2D(<br>  GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_DEPTH24_STENCIL8, SCREEN_WIDTH, SCREEN_HEIGHT, <span class="hljs-number">0</span>,<br>  GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8, <span class="hljs-literal">NULL</span><br>);<br><br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_TEXTURE_2D, texture, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="渲染缓冲对象附件"><a href="#渲染缓冲对象附件" class="headerlink" title="渲染缓冲对象附件"></a>渲染缓冲对象附件</h4><ul>
<li>渲染缓冲对象(Renderbuffer Object)是在纹理之后引入到OpenGL中，作为一个可用的帧缓冲附件类型的，和纹理图像一样，渲染缓冲对象是一个真正的缓冲，即一系列的字节、整数、像素等。渲染缓冲对象附加的好处是，它会将数据储存为OpenGL原生的渲染格式，它是为离屏渲染到帧缓冲优化过的。</li>
<li>渲染缓冲对象直接将所有的渲染数据储存到它的缓冲中，不会做任何针对纹理格式的转换，让它变为一个更快的可写储存介质。然而，渲染缓冲对象通常都是只写的，所以你不能读取它们（比如使用纹理访问）。当然你仍然还是能够使用 <em>glReadPixels</em> 来读取它，这会从当前绑定的帧缓冲，而不是附件本身，中返回特定区域的像素。</li>
<li>因为它的数据已经是原生的格式了，当写入或者复制它的数据到其它缓冲中时是非常快的。所以，交换缓冲这样的操作在使用渲染缓冲对象时会非常快。我们在每个渲染迭代最后使用的glfwSwapBuffers，也可以通过渲染缓冲对象实现：只需要写入一个渲染缓冲图像，并在最后交换到另外一个渲染缓冲就可以了。渲染缓冲对象对这种操作非常完美。</li>
<li><p>使用渲染缓冲对象：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> rbo;<br>glGenRenderbuffers(<span class="hljs-number">1</span>, &amp;rbo);<br><span class="hljs-comment">// 绑定这个渲染缓冲对象</span><br>glBindRenderbuffer(GL_RENDERBUFFER, rbo);<br><span class="hljs-comment">// 创建一个深度和模板渲染缓冲对象</span><br>glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, SCREEN_WIDTH, SCREEN_HEIGHT);<br><span class="hljs-comment">// 附加这个渲染缓冲对象</span><br>glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);<br></code></pre></td></tr></table></figure>
</li>
<li><p>由于渲染缓冲对象通常都是只写的，它们会经常用于深度和模板附件，因为大部分时间我们都不需要从深度和模板缓冲中读取值，只关心深度和模板测试。我们需要深度和模板值用于测试，但不需要对它们进行采样，所以渲染缓冲对象非常适合它们。当我们不需要从这些缓冲中采样的时候，通常都会选择渲染缓冲对象，因为它会更优化一点。</p>
</li>
<li>渲染缓冲对象能为你的帧缓冲对象提供一些优化，但知道什么时候使用渲染缓冲对象，什么时候使用纹理是很重要的。通常的规则是，如果你不需要从一个缓冲中采样数据，那么对这个缓冲使用渲染缓冲对象会是明智的选择。如果你需要从缓冲中采样颜色或深度值等数据，那么你应该选择纹理附件。性能方面它不会产生非常大的影响的。</li>
</ul>
<h3 id="渲染到纹理"><a href="#渲染到纹理" class="headerlink" title="渲染到纹理"></a>渲染到纹理</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 创建一个帧缓冲对象，并绑定它</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> framebuffer;<br>glGenFramebuffers(<span class="hljs-number">1</span>, &amp;framebuffer);<br>glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);<br><br><span class="hljs-comment">// 生成纹理</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> texColorBuffer;<br>glGenTextures(<span class="hljs-number">1</span>, &amp;texColorBuffer);<br>glBindTexture(GL_TEXTURE_2D, texColorBuffer);<br>glTexImage2D(GL_TEXTURE_2D, <span class="hljs-number">0</span>, GL_RGB, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, <span class="hljs-literal">NULL</span>);<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );<br>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>glBindTexture(GL_TEXTURE_2D, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 将它附加到当前绑定的帧缓冲对象</span><br>glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texColorBuffer, <span class="hljs-number">0</span>);  <br><br><span class="hljs-comment">// 创建渲染缓冲对象作为深度和模板附件渲染缓冲对象</span><br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> rbo;<br>glGenRenderbuffers(<span class="hljs-number">1</span>, &amp;rbo);<br>glBindRenderbuffer(GL_RENDERBUFFER, rbo);<br>glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, <span class="hljs-number">800</span>, <span class="hljs-number">600</span>);  <br>glBindRenderbuffer(GL_RENDERBUFFER, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 将渲染缓冲对象附加到帧缓冲的深度和模板附件</span><br>glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);<br><br><span class="hljs-comment">// 完整性检查</span><br><span class="hljs-keyword">if</span>(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ERROR::FRAMEBUFFER:: Framebuffer is not complete!"</span> &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br><br><span class="hljs-comment">// 解绑帧缓冲</span><br>glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// render loop</span><br><span class="hljs-keyword">while</span> (!glfwWindowShouldClose(window))<br>&#123;<br>  glBindFramebuffer(GL_FRAMEBUFFER, framebuffer);<br>  glClearColor(<span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">0.1f</span>, <span class="hljs-number">1.0f</span>);<br>  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); <span class="hljs-comment">// 我们现在不使用模板缓冲</span><br>  glEnable(GL_DEPTH_TEST);<br>  DrawScene();<br><br>  glBindFramebuffer(GL_FRAMEBUFFER, <span class="hljs-number">0</span>); <span class="hljs-comment">// 返回默认缓冲</span><br>  glClearColor(<span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">1.0f</span>);<br>  glClear(GL_COLOR_BUFFER_BIT);<br><br>  screenShader.use();<br>  glBindVertexArray(quadVAO);<br>  glDisable(GL_DEPTH_TEST);<br>  glBindTexture(GL_TEXTURE_2D, textureColorbuffer);<br>  glDrawArrays(GL_TRIANGLES, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><img src="/2018/12/23/高级OpenGL（上）/framebuffers_screen_texture.png" alt="渲染帧缓冲"></li>
</ul>
<h3 id="核效果"><a href="#核效果" class="headerlink" title="核效果"></a>核效果</h3><ul>
<li><p>在一个纹理图像上做后期处理的另外一个好处是，我们可以从纹理的其它地方采样颜色值。比如说我们可以在当前纹理坐标的周围取一小块区域，对当前纹理值周围的多个纹理值进行采样。我们可以结合它们创建出很有意思的效果。</p>
</li>
<li><p>核(Kernel)（或卷积矩阵(Convolution Matrix)）是一个类矩阵的数值数组，它的中心为当前的像素，它会用它的核值乘以周围的像素值，并将结果相加变成一个值。所以，基本上我们是在对当前像素周围的纹理坐标添加一个小的偏移量，并根据核将结果合并。</p>
</li>
<li>通过核，我们可以实现锐化，边缘检测，模糊等效果。</li>
<li>下面是核的一个例子：<script type="math/tex; mode=display">\begin{bmatrix} 2 & 2 & 2 \\ 2 & -15 & 2 \\ 2 & 2 & 2 \end{bmatrix}</script></li>
</ul>
<blockquote>
<p>大部分核将所有的权重加起来之后都应该会等于1，如果它们加起来不等于1，这就意味着最终的纹理颜色将会比原纹理值更亮或者更暗了。</p>
</blockquote>
<ul>
<li><p>片段着色器实现：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">const</span> <span class="hljs-keyword">float</span> offset = <span class="hljs-number">1.0</span> / <span class="hljs-number">300.0</span>;  <br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    vec2 offsets[<span class="hljs-number">9</span>] = vec2[](<br>        vec2(-offset,  offset), <span class="hljs-comment">// 左上</span><br>        vec2( <span class="hljs-number">0.0f</span>,    offset), <span class="hljs-comment">// 正上</span><br>        vec2( offset,  offset), <span class="hljs-comment">// 右上</span><br>        vec2(-offset,  <span class="hljs-number">0.0f</span>),   <span class="hljs-comment">// 左</span><br>        vec2( <span class="hljs-number">0.0f</span>,    <span class="hljs-number">0.0f</span>),   <span class="hljs-comment">// 中</span><br>        vec2( offset,  <span class="hljs-number">0.0f</span>),   <span class="hljs-comment">// 右</span><br>        vec2(-offset, -offset), <span class="hljs-comment">// 左下</span><br>        vec2( <span class="hljs-number">0.0f</span>,   -offset), <span class="hljs-comment">// 正下</span><br>        vec2( offset, -offset)  <span class="hljs-comment">// 右下</span><br>    );<br><br>    <span class="hljs-keyword">float</span> kernel[<span class="hljs-number">9</span>] = <span class="hljs-keyword">float</span>[](<br>        <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,<br>        <span class="hljs-number">-1</span>,  <span class="hljs-number">9</span>, <span class="hljs-number">-1</span>,<br>        <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span><br>    );<br><br>    vec3 sampleTex[<span class="hljs-number">9</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>    &#123;<br>        sampleTex[i] = vec3(texture(screenTexture, TexCoords.st + offsets[i]));<br>    &#125;<br>    vec3 col = vec3(<span class="hljs-number">0.0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++)<br>        col += sampleTex[i] * kernel[i];<br><br>    FragColor = vec4(col, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>边缘检测的效果：</p>
</li>
<li><img src="/2018/12/23/高级OpenGL（上）/kernel.jpg" alt="边缘检测"></li>
</ul>
<hr>
<h2 id="立方体贴图-Cubemaps"><a href="#立方体贴图-Cubemaps" class="headerlink" title="立方体贴图(Cubemaps)"></a>立方体贴图(Cubemaps)</h2><ul>
<li>简单来说，立方体贴图就是一个包含了6个2D纹理的纹理，每个2D纹理都组成了立方体的一个面。</li>
</ul>
<h3 id="创建立方体贴图"><a href="#创建立方体贴图" class="headerlink" title="创建立方体贴图"></a>创建立方体贴图</h3><figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> textureID;<br>glGenTextures(<span class="hljs-number">1</span>, &amp;textureID);<br>glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);<br><br><span class="hljs-keyword">int</span> width, height, nrChannels;<br><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> *data;  <br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; textures_faces.size(); i++)<br>&#123;<br>    data = stbi_load(textures_faces[i].c_str(), &amp;width, &amp;height, &amp;nrChannels, <span class="hljs-number">0</span>);<br>    glTexImage2D(<br>        GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,<br>        <span class="hljs-number">0</span>, GL_RGB, width, height, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data<br>    );<br>&#125;<br><br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br><span class="hljs-comment">//对应的是纹理的第三个维度（和位置的z一样）。我们将环绕方式设置为GL_CLAMP_TO_EDGE，</span><br><span class="hljs-comment">//这是因为正好处于两个面之间的纹理坐标可能不能击中一个面（由于一些硬件限制），</span><br><span class="hljs-comment">//所以通过使用GL_CLAMP_TO_EDGE，OpenGL将在我们对两个面之间采样的时候，永远返回它们的边界值。</span><br>glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);<br></code></pre></td></tr></table></figure>
<ul>
<li>因为立方体贴图包含有6个纹理，每个面一个，我们需要调用glTexImage2D函数6次，其第一个参数是纹理目标，是从GL_TEXTURE_CUBE_MAP_POSITIVE_X开始线性+1递增的枚举值：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>纹理目标</th>
<th>方位</th>
</tr>
</thead>
<tbody>
<tr>
<td>GL_TEXTURE_CUBE_MAP_POSITIVE_X</td>
<td>右</td>
</tr>
<tr>
<td>GL_TEXTURE_CUBE_MAP_NEGATIVE_X</td>
<td>左</td>
</tr>
<tr>
<td>GL_TEXTURE_CUBE_MAP_POSITIVE_Y</td>
<td>上</td>
</tr>
<tr>
<td>GL_TEXTURE_CUBE_MAP_NEGATIVE_Y</td>
<td>下</td>
</tr>
<tr>
<td>GL_TEXTURE_CUBE_MAP_POSITIVE_Z</td>
<td>后</td>
</tr>
<tr>
<td>GL_TEXTURE_CUBE_MAP_NEGATIVE_Z</td>
<td>前</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>在绘制使用立方体贴图的物体之前，我们要先激活对应的纹理单元，并绑定立方体贴图。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">glActiveTexture(GL_TEXTURE0);<br>glBindTexture(GL_TEXTURE_CUBE_MAP, cubemapTexture);<br></code></pre></td></tr></table></figure>
</li>
<li><p>在片段着色器中进行采样时，我们会使用vec3而不再是vec2，毕竟是个三维盒子，采样器也改为了samplerCube。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">in vec3 textureDir; <span class="hljs-comment">// 代表3D纹理坐标的方向向量</span><br>uniform samplerCube cubemap; <span class="hljs-comment">// 立方体贴图的纹理采样器</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;             <br>    FragColor = texture(cubemap, textureDir);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="天空盒"><a href="#天空盒" class="headerlink" title="天空盒"></a>天空盒</h3><ul>
<li>天空盒是一个包含了整个场景的（大）立方体，它包含周围环境的6个图像，让玩家以为他处在一个比实际大得多的环境当中。游戏中使用天空盒的例子有群山、白云或星空。</li>
<li><img src="/2018/12/23/高级OpenGL（上）/cubemaps_skybox.png" alt="天空盒"></li>
</ul>
<h4 id="加载天空盒"><a href="#加载天空盒" class="headerlink" title="加载天空盒"></a>加载天空盒</h4><ul>
<li>加载天空盒的本质是创建6个图像的纹理过程，具体代码如下：<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; faces;<br>&#123;<br>    <span class="hljs-string">"right.jpg"</span>,<br>    <span class="hljs-string">"left.jpg"</span>,<br>    <span class="hljs-string">"top.jpg"</span>,<br>    <span class="hljs-string">"bottom.jpg"</span>,<br>    <span class="hljs-string">"front.jpg"</span>,<br>    <span class="hljs-string">"back.jpg"</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-title">loadCubemap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>&gt; faces)</span><br></span>&#123;<br>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> textureID;<br>    glGenTextures(<span class="hljs-number">1</span>, &amp;textureID);<br>    glBindTexture(GL_TEXTURE_CUBE_MAP, textureID);<br><br>    <span class="hljs-keyword">int</span> width, height, nrChannels;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; faces.size(); i++)<br>    &#123;<br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>* data = stbi_load(faces[i].c_str(), &amp;width, &amp;height, &amp;nrChannels, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (data)<br>        &#123;<br>            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i,<br>                         <span class="hljs-number">0</span>, GL_RGB, width, height, <span class="hljs-number">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data<br>            );<br>            stbi_image_free(data);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Cubemap texture failed to load at path: "</span> &lt;&lt; faces[i] &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>            stbi_image_free(data);<br>        &#125;<br>    &#125;<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br>    glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);<br><br>    <span class="hljs-keyword">return</span> textureID;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="显示天空盒"><a href="#显示天空盒" class="headerlink" title="显示天空盒"></a>显示天空盒</h4><ul>
<li>当我们把天空盒的原点放置在(0, 0, 0)上时，它的每一个位置向量都是从原点出发的方向向量。这个方向向量正是获取立方体上特定位置的纹理值所需要的。正是因为这个，我们只需要提供位置向量而不用纹理坐标了。</li>
<li>绘制天空盒时，我们可以首先对其进行，并且禁用深度写入。这样子天空盒就会永远被绘制在其它物体的背后了。但是这样的处理方式带来的消耗也是明显的，整个屏幕会被绘制一遍天空盒，会存在大量overdraw的情况。</li>
<li>之所以先绘制天空盒，再绘制场景中的其他物体，是因为什么想要保证天空盒必然出现在任何其他物体背后，如果我们能通过某种方式，将天空盒的深度值设置为恒大于场景中的其他物体，那么便不需要优先绘制天空盒，相反，我们可以在最后绘制，只绘制其通过深度测试的部分。</li>
<li>透视除法是在顶点着色器运行之后执行的，将gl_Position的xyz坐标除以w分量。我们又从深度测试小节中知道，相除结果的z分量等于顶点的深度值。使用这些信息，我们可以将输出位置的z分量等于它的w分量，让z分量永远等于1.0，这样子的话，当透视除法执行之后，z分量会变为w / w = 1.0。</li>
<li><p>故顶点着色器的代码便是：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;<br>    TexCoords = aPos;<br>    vec4 pos = projection * view * vec4(aPos, <span class="hljs-number">1.0</span>);<br>    gl_Position = pos.xyww;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>我们还要改变一下深度函数，将它从默认的GL_LESS改为GL_LEQUAL。深度缓冲将会填充上天空盒的1.0值，所以我们需要保证天空盒在值小于或等于深度缓冲而不是小于时通过深度测试。</p>
</li>
</ul>
<h3 id="环境映射"><a href="#环境映射" class="headerlink" title="环境映射"></a>环境映射</h3><ul>
<li>使用环境立方体贴图的技术叫做环境映射(Environment Mapping)，其中最流行的两个是反射(Reflection)和折射(Refraction)。</li>
</ul>
<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><ul>
<li>反射这个属性表现为物体（或物体的一部分）反射它周围环境，即根据观察者的视角，物体的颜色或多或少等于它的环境。镜子就是一个反射性物体：它会根据观察者的视角反射它周围的环境。</li>
<li><img src="/2018/12/23/高级OpenGL（上）/cubemaps_reflection_theory.png" alt="反射"></li>
<li><p>我们根据观察方向向量 $\vec I$ 和物体的法向量 $\vec N$ ，来计算反射向量 $\vec R$ 。我们可以使用GLSL内建的reflect函数来计算这个反射向量。最终的 $\vec R$ 向量将会作为索引/采样立方体贴图的方向向量，返回环境的颜色值。最终的结果是物体看起来反射了天空盒。</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#version 330 core</span><br>out vec4 FragColor;<br><br>in vec3 Normal;<br>in vec3 Position;<br><br>uniform vec3 cameraPos;<br>uniform samplerCube skybox;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;             <br>    vec3 I = normalize(Position - cameraPos);<br>    vec3 R = reflect(I, normalize(Normal));<br>    FragColor = vec4(texture(skybox, R).rgb, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><img src="/2018/12/23/高级OpenGL（上）/reflection.png" alt="反射"></p>
</li>
</ul>
<h4 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h4><ul>
<li>折射是光线由于传播介质的改变而产生的方向变化。</li>
<li>折射是通过<a href="https://en.wikipedia.org/wiki/Snell%27s_law" target="_blank" rel="noopener">斯涅尔定律(Snell’s Law)</a>来描述的，使用环境贴图的话看起来像是这样：</li>
<li><img src="/2018/12/23/高级OpenGL（上）/cubemaps_refraction_theory.png" alt="折射"></li>
<li>折射可以使用GLSL的内建refract函数来轻松实现，它需要一个法向量、一个观察方向和两个材质之间的折射率(Refractive Index)。</li>
<li>折射率决定了材质中光线弯曲的程度，每个材质都有自己的折射率。一些最常见的折射率可以在下表中找到：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>材质</th>
<th>折射率</th>
</tr>
</thead>
<tbody>
<tr>
<td>空气</td>
<td>1.00</td>
</tr>
<tr>
<td>水</td>
<td>1.33</td>
</tr>
<tr>
<td>冰</td>
<td>1.309</td>
</tr>
<tr>
<td>玻璃</td>
<td>1.52</td>
</tr>
<tr>
<td>钻石</td>
<td>2.42</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>假设场景中的物体为玻璃材质，则：</p>
<figure class="hljs highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span><br></span>&#123;             <br>    <span class="hljs-keyword">float</span> ratio = <span class="hljs-number">1.00</span> / <span class="hljs-number">1.52</span>;<br>    vec3 I = normalize(Position - cameraPos);<br>    vec3 R = refract(I, normalize(Normal), ratio);<br>    FragColor = vec4(texture(skybox, R).rgb, <span class="hljs-number">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><img src="/2018/12/23/高级OpenGL（上）/refraction.png" alt="折射"></p>
</li>
</ul>
<h3 id="环境动态贴图"><a href="#环境动态贴图" class="headerlink" title="环境动态贴图"></a>环境动态贴图</h3><ul>
<li>前面的反射和折射均是建立在场景中只有一个物体的情况下实现的，但场景中有多个物体时，一个物体的反射/折射会受到其他物体的影响，而上面的实现只是从天空盒中进行采样，没有考虑其他物体对环境的影响。</li>
<li><p><img src="/2018/12/23/高级OpenGL（上）/double_man.png" alt="多个物体的反射"></p>
</li>
<li><p>通过使用帧缓冲，我们能够为物体的6个不同角度创建出场景的纹理，并在每个渲染迭代中将它们储存到一个立方体贴图中。之后我们就可以使用这个（动态生成的）立方体贴图来创建出更真实的，包含其它物体的，反射和折射表面了。这就叫做动态环境映射(Dynamic Environment Mapping)，因为我们动态创建了物体周围的立方体贴图，并将其用作环境贴图。</p>
</li>
<li><p>虽然它看起来很棒，但它有一个很大的缺点：我们需要为使用环境贴图的物体渲染场景6次，这是对程序是非常大的性能开销。现代的程序通常会尽可能使用天空盒，并在可能的时候使用预编译的立方体贴图，只要它们能产生一点动态环境贴图的效果。虽然动态环境贴图是一个很棒的技术，但是要想在不降低性能的情况下让它工作还是需要非常多的技巧的。</p>
</li>
<li><p>尚未进行实现。。。。</p>
</li>
</ul>
<h3 id="使用漫反射贴图-反射贴图的效果"><a href="#使用漫反射贴图-反射贴图的效果" class="headerlink" title="使用漫反射贴图+反射贴图的效果"></a>使用漫反射贴图+反射贴图的效果</h3><ul>
<li><img src="/2018/12/23/高级OpenGL（上）/combine.png" alt=""></li>
</ul>

    </main>
    <footer class="post-footer">
      
      <div class="post-tags">
        
        <a class="post-tag button" href="/tags/OpenGL/" rel="tag"><i class="fas fa-tags"></i>OpenGL</a>
        
      </div>
      
    </footer>
  </article>
  
  
  <nav class="page-nav">
    <div class="page-nav-next page-nav-item">
      
      <a href="/2018/12/10/模型加载/" rel="next" title="模型加载"><i class="fas fa-angle-left"></i><span class="nav-title">模型加载</span></a>
      
    </div>
    <div class="page-nav-prev page-nav-item">
      
      <a href="/2019/02/09/高级OpenGL（下）/" rel="prev" title="高级OpenGL（下）"><span class="nav-title">高级OpenGL（下）</span><i class="fas fa-angle-right"></i></a>
      
    </div>
  </nav>
  
  
  

<div class="comments" id="comments">
  
  
  <div id="vcomments" class="vcomments"></div>
  <script defer src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script defer src="//unpkg.com/valine/dist/Valine.min.js"></script>
  <script type="text/javascript">
  $(document).ready(function () {
    new Valine({
      "el": "#vcomments",
      "appId": "g87PyVdDsH5EP8VCTtaGlIBo-gzGzoHsz",
      "appKey": "wboY6qvCvYXBESIQQOWkFzYq",
      "verify": "false",
      "notify": "false",
      "avatar": "mm",
      "meta": ["nick", "mail", "link"],
      "pageSize": 10,
      "lang": "zh-cn",
      "visitor": "false",
      "highlight": "true",
      "placeholder": "在这里说点什么……",
      "avatarForce": "false"
    });
  });
  </script>
  
  
</div>



  
</div>

          </div>
          
          
          
<aside class="sidebar" id="sidebar" style="background: url(/images/background.png);">
  
  <div class="search">
    <div class="form-group">
      <i class="fas fa-search"></i><input type="search" id="search-input" name="q" results="0" placeholder="搜索" class="form-control">
    </div>
  </div>
  <div class="search-result-box" id="search-result"></div>
  
  
<div class="info sidebar-item" id="info">
  
  <img class="author-avatar" src="/images/myavatar.png" alt="MoriMiya">
  
  <h1 class="author-name">MoriMiya</h1>
  <h2 class="author-description"></h2>
  <div class="site-count">
    
    
    
    
    <div class="archives-count count-block">
      <div class="site-count-title">归档</div>
      <div><a href="/archives/">29</a></div>
    </div>
    
    
    
    <div class="categories-count count-block">
      <div class="site-count-title">分类</div>
      <div><a href="/categories/">23</a></div>
    </div>
    
    
    
    <div class="tags-count count-block">
      <div class="site-count-title">标签</div>
      <div><a href="/tags/">25</a></div>
    </div>
    
    
    
    
  </div>
  
  <div class="rss">
    <a class="rss-link button sidebar-item" href="/atom.xml"><i class="fas fa-rss"></i>RSS</a>
  </div>
  
</div>


  <div class="sidebar-sticky">
    
    
    
    
    
    <hr>
    <div class="post-toc sidebar-item" id="toc-div">
      <div><i class="fas fa-list-ol"></i>文章目录</div>
      <div class="post-toc-content"><ol class="list-group toc"><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#深度测试-Depth-testing"><span class="toc-text">深度测试(Depth testing)</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#深度测试运行机制"><span class="toc-text">深度测试运行机制</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#深度缓冲"><span class="toc-text">深度缓冲</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#深度测试规则"><span class="toc-text">深度测试规则</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#深度测试时机"><span class="toc-text">深度测试时机</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#提前深度测试"><span class="toc-text">提前深度测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#深度测试函数"><span class="toc-text">深度测试函数</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#深度值"><span class="toc-text">深度值</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#深度值精度"><span class="toc-text">深度值精度</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#深度值可视化"><span class="toc-text">深度值可视化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#深度冲突"><span class="toc-text">深度冲突</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#防止深度冲突"><span class="toc-text">防止深度冲突</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#模板测试-Stencil-testing"><span class="toc-text">模板测试(Stencil testing)</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#使用模板缓冲"><span class="toc-text">使用模板缓冲</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#大体步骤"><span class="toc-text">大体步骤</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#掩码设置"><span class="toc-text">掩码设置</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#模板函数"><span class="toc-text">模板函数</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#glStencilFunc"><span class="toc-text">glStencilFunc</span></a></li><li class="toc-item toc-level-5"><a class="list-group-item toc-link" href="#glStencilOp"><span class="toc-text">glStencilOp</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#模板缓冲例子"><span class="toc-text">模板缓冲例子</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#物体轮廓"><span class="toc-text">物体轮廓</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#混合-Blending"><span class="toc-text">混合(Blending)</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#丢弃片段-discard"><span class="toc-text">丢弃片段(discard)</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#混合"><span class="toc-text">混合</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#混合方程"><span class="toc-text">混合方程</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#混合使用"><span class="toc-text">混合使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#面剔除-Face-culling"><span class="toc-text">面剔除(Face culling)</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#环绕顺序"><span class="toc-text">环绕顺序</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#面剔除"><span class="toc-text">面剔除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#帧缓冲-Framebuffers"><span class="toc-text">帧缓冲(Framebuffers)</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#创建帧缓冲"><span class="toc-text">创建帧缓冲</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#附件"><span class="toc-text">附件</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#为帧缓存创建纹理"><span class="toc-text">为帧缓存创建纹理</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#渲染缓冲对象附件"><span class="toc-text">渲染缓冲对象附件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#渲染到纹理"><span class="toc-text">渲染到纹理</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#核效果"><span class="toc-text">核效果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="list-group-item toc-link" href="#立方体贴图-Cubemaps"><span class="toc-text">立方体贴图(Cubemaps)</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#创建立方体贴图"><span class="toc-text">创建立方体贴图</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#天空盒"><span class="toc-text">天空盒</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#加载天空盒"><span class="toc-text">加载天空盒</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#显示天空盒"><span class="toc-text">显示天空盒</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#环境映射"><span class="toc-text">环境映射</span></a><ol class="list-group toc-child"><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#反射"><span class="toc-text">反射</span></a></li><li class="toc-item toc-level-4"><a class="list-group-item toc-link" href="#折射"><span class="toc-text">折射</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#环境动态贴图"><span class="toc-text">环境动态贴图</span></a></li><li class="toc-item toc-level-3"><a class="list-group-item toc-link" href="#使用漫反射贴图-反射贴图的效果"><span class="toc-text">使用漫反射贴图+反射贴图的效果</span></a></li></ol></li></ol></div>
    </div>
    
    
    
    <hr>
    <div class="social-link sidebar-item">
      <div><i class="far fa-address-card"></i>社交链接<p></p></div>
      <ul>
        
        <li><i class="fab fa-github"></i><a href="https://github.com/morimiya" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
    
    <hr>
    <div class="blogroll sidebar-item">
      <div><i class="fas fa-link"></i>友情链接</div>
      <ul>
        
        <li><i class="fas fa-link"></i><a href="https://github.com/" target="_blank">GitHub</a></li>
        
      </ul>
    </div>
    
  </div>
</aside>


          
        </div>
      </div>
    </main>
    
<footer id="footer" class="footer" style="background: #33363b;">
  <div class="container">
    <div class="back-to-top">
      <button id="back-to-top"><i class="fas fa-angle-double-up" aria-label="回到顶部"></i></button>
    </div>
    <div class="footer-container">
      <div class="footer-left">
        <div class="copyright">
          <span class="author">MoriMiya</span><span class="year"><i class="far fa-copyright"></i>2018 - 2021</span>
        </div>
        
        <div class="busuanzi">
          <span id="busuanzi_container_site_pv"><i class="fas fa-eye" aria-label="站点点击量" aria-hidden="false"></i><span id="busuanzi_value_site_pv"></span></span><span id="busuanzi_container_site_uv"><i class="fas fa-user" aria-label="站点用户数" aria-hidden="false"></i><span id="busuanzi_value_site_uv"></span></span><span id="busuanzi_container_page_pv"><i class="far fa-file-alt"></i><span id="busuanzi_value_page_pv" aria-label="页面点击量" aria-hidden="false"></span></span>
        </div>
        
      </div>
      <div class="footer-right">
        <div class="custom-info">
          
          托管于<i class="fab fa-github-alt"></i><a href="https://pages.github.com/" target="_blank">GitHub Pages</a>
          
        </div>
        <div class="powered-by">
          由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/AlynxZhou/hexo-theme-aria/" target="_blank">ARIA</a>
        </div>
      </div>
    </div>
  </div>
</footer>


  </body>
</html>
